//
//	Package - transpiled by c4go
//
//	If you have found any issues, please raise an issue at:
//	https://github.com/Konstantin8105/c4go/
//

/* AST Error :
unknown node type: `value: Int 1000`
*/
/* AST Error :
unknown node type: `value: Int 1100`
*/
/* AST Error :
unknown node type: `value: Int 256`
*/
/* AST Error :
unknown node type: `value: Int 512`
*/
/* AST Error :
unknown node type: `value: Int 1024`
*/
/* AST Error :
unknown node type: `value: Int 2048`
*/
/* AST Error :
unknown node type: `value: Int 4096`
*/
/* AST Error :
unknown node type: `value: Int 8192`
*/
/* AST Error :
unknown node type: `value: Int 16384`
*/
/* AST Error :
unknown node type: `value: Int 32768`
*/
/* AST Error :
unknown node type: `value: Int 1`
*/
/* AST Error :
unknown node type: `value: Int 2`
*/
/* AST Error :
unknown node type: `value: Int 4`
*/
/* AST Error :
unknown node type: `value: Int 8`
*/
/* AST Error :
unknown node type: `value: Int 8`
*/
/* AST Error :
unknown node type: `value: Int 16`
*/
/* AST Error :
unknown node type: `value: Int 0`
*/
/* AST Error :
unknown node type: `value: Int 1`
*/
/* AST Error :
unknown node type: `value: Int 2`
*/
/* AST Error :
unknown node type: `value: Int 3`
*/
/* AST Error :
unknown node type: `value: Int 4`
*/
/* AST Error :
unknown node type: `value: Int 0`
*/
/* AST Error :
unknown node type: `value: Int 1`
*/
/* AST Error :
unknown node type: `value: Int 2`
*/
/* AST Error :
unknown node type: `value: Int 3`
*/
/* AST Error :
unknown node type: `value: Int 4`
*/
/* AST Error :
cannot parse line: `AllocSizeAttr 0x5598b331adb8 <col:14> Implicit 1`. could not match regexp with string
^(?P<address>[0-9a-fx]+) <(?P<position>.*)>(?P<inherited> Inherited)?(?P<a> \d+)(?P<b> \d+)?[\s]*$
0x5598b331adb8 <col:14> Implicit 1

*/
/* AST Error :
cannot parse line: `AllocSizeAttr 0x5598b331af38 <col:14> Inherited Implicit 1`. could not match regexp with string
^(?P<address>[0-9a-fx]+) <(?P<position>.*)>(?P<inherited> Inherited)?(?P<a> \d+)(?P<b> \d+)?[\s]*$
0x5598b331af38 <col:14> Inherited Implicit 1

*/
/* AST Error :
cannot parse line: `AllocSizeAttr 0x5598b331af68 <col:14> Implicit 1`. could not match regexp with string
^(?P<address>[0-9a-fx]+) <(?P<position>.*)>(?P<inherited> Inherited)?(?P<a> \d+)(?P<b> \d+)?[\s]*$
0x5598b331af68 <col:14> Implicit 1

*/
/* AST Error :
cannot parse line: `AllocSizeAttr 0x5598b331b318 <col:14> Implicit 1 2`. could not match regexp with string
^(?P<address>[0-9a-fx]+) <(?P<position>.*)>(?P<inherited> Inherited)?(?P<a> \d+)(?P<b> \d+)?[\s]*$
0x5598b331b318 <col:14> Implicit 1 2

*/
/* AST Error :
cannot parse line: `AllocSizeAttr 0x5598b331b4a0 <col:14> Inherited Implicit 1 2`. could not match regexp with string
^(?P<address>[0-9a-fx]+) <(?P<position>.*)>(?P<inherited> Inherited)?(?P<a> \d+)(?P<b> \d+)?[\s]*$
0x5598b331b4a0 <col:14> Inherited Implicit 1 2

*/
/* AST Error :
cannot parse line: `AllocSizeAttr 0x5598b331b4d0 <line:556:14> Implicit 1 2`. could not match regexp with string
^(?P<address>[0-9a-fx]+) <(?P<position>.*)>(?P<inherited> Inherited)?(?P<a> \d+)(?P<b> \d+)?[\s]*$
0x5598b331b4d0 <line:556:14> Implicit 1 2

*/
/* AST Error :
cannot parse line: `AllocSizeAttr 0x5598b331b888 <col:14> Implicit 2`. could not match regexp with string
^(?P<address>[0-9a-fx]+) <(?P<position>.*)>(?P<inherited> Inherited)?(?P<a> \d+)(?P<b> \d+)?[\s]*$
0x5598b331b888 <col:14> Implicit 2

*/
/* AST Error :
cannot parse line: `AllocSizeAttr 0x5598b331ba18 <col:14> Inherited Implicit 2`. could not match regexp with string
^(?P<address>[0-9a-fx]+) <(?P<position>.*)>(?P<inherited> Inherited)?(?P<a> \d+)(?P<b> \d+)?[\s]*$
0x5598b331ba18 <col:14> Inherited Implicit 2

*/
/* AST Error :
cannot parse line: `AllocSizeAttr 0x5598b331ba48 <line:564:14> Implicit 2`. could not match regexp with string
^(?P<address>[0-9a-fx]+) <(?P<position>.*)>(?P<inherited> Inherited)?(?P<a> \d+)(?P<b> \d+)?[\s]*$
0x5598b331ba48 <line:564:14> Implicit 2

*/
/* AST Error :
cannot parse line: `AllocSizeAttr 0x5598b331d090 <col:14> Implicit 2`. could not match regexp with string
^(?P<address>[0-9a-fx]+) <(?P<position>.*)>(?P<inherited> Inherited)?(?P<a> \d+)(?P<b> \d+)?[\s]*$
0x5598b331d090 <col:14> Implicit 2

*/
/* AST Error :
cannot parse line: `AllocSizeAttr 0x5598b331d240 <col:14> Inherited Implicit 2`. could not match regexp with string
^(?P<address>[0-9a-fx]+) <(?P<position>.*)>(?P<inherited> Inherited)?(?P<a> \d+)(?P<b> \d+)?[\s]*$
0x5598b331d240 <col:14> Inherited Implicit 2

*/
/* AST Error :
cannot parse line: `AllocSizeAttr 0x5598b331d270 <line:605:14> Implicit 2`. could not match regexp with string
^(?P<address>[0-9a-fx]+) <(?P<position>.*)>(?P<inherited> Inherited)?(?P<a> \d+)(?P<b> \d+)?[\s]*$
0x5598b331d270 <line:605:14> Implicit 2

*/
/* AST Error :
unknown node type: `value: Int 32`
*/
/* AST Error :
unknown node type: `value: Int 32`
*/
/* AST Error :
unknown node type: `value: Int 32`
*/
/* AST Error :
unknown node type: `value: Int 32`
*/
/* AST Error :
unknown node type: `value: Int 32`
*/
/* AST Error :
unknown node type: `value: Int 32`
*/
/* AST Error :
unknown node type: `value: Int 32`
*/
/* AST Error :
unknown node type: `value: Int 32`
*/
/* AST Error :
unknown node type: `value: Int 32`
*/
/* AST Error :
unknown node type: `value: Int 32`
*/
/* AST Error :
unknown node type: `value: Int 32`
*/
/* AST Error :
unknown node type: `value: Int 60`
*/
/* AST Error :
unknown node type: `value: Int 235`
*/
// Warning (*ast.VarDecl):  GOPATH/History_frame3DD/src/NRutil.c:57 :unknown type used C type, because cannot resolve type 'uint16_t *' : cannot resolve star `*` for uint16_t * : cannot resolve type 'uint16_t' : I couldn't find an appropriate Go type for the C type 'uint16_t'.
// Warning (*ast.BinaryOperator):  GOPATH/History_frame3DD/src/NRutil.c:59 :cannot transpile BinaryOperator with type 'uint16_t *' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. cannot transpileToExpr. err = cannot transpileImplicitCastExpr. err = cannot transpileToExpr. err = error in transpileCallExpr : name of call function is malloc. function: calloc. err = cannot resolve type 'uint16_t' : I couldn't find an appropriate Go type for the C type 'uint16_t'.
// Warning (*ast.BinaryOperator):  GOPATH/History_frame3DD/src/NRutil.c:59 :cannot transpileToStmt : cannot transpileToExpr. err = cannot transpile BinaryOperator with type 'uint16_t *' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. cannot transpileToExpr. err = cannot transpileImplicitCastExpr. err = cannot transpileToExpr. err = error in transpileCallExpr : name of call function is malloc. function: calloc. err = cannot resolve type 'uint16_t' : I couldn't find an appropriate Go type for the C type 'uint16_t'.
// Warning (*ast.BinaryOperator):  GOPATH/History_frame3DD/src/NRutil.c:61 :cannot transpile BinaryOperator with type 'uint16_t *' : result type = {}. Error: operator is `-`. pointer operation is not valid : cannot transpile pointerArithmetic. err = cannot transpile pointerArithmetic. err = cannot resolve type 'uint16_t *' : cannot resolve star `*` for uint16_t * : cannot resolve type 'uint16_t' : I couldn't find an appropriate Go type for the C type 'uint16_t'.
// Warning (*ast.BinaryOperator):  GOPATH/History_frame3DD/src/NRutil.c:61 :cannot transpile BinaryOperator with type 'uint16_t *' : result type = {unknown52}. Error: operator is `+`. cannot atomic for left part. cannot transpileToExpr. err = cannot transpile BinaryOperator with type 'uint16_t *' : result type = {}. Error: operator is `-`. pointer operation is not valid : cannot transpile pointerArithmetic. err = cannot transpile pointerArithmetic. err = cannot resolve type 'uint16_t *' : cannot resolve star `*` for uint16_t * : cannot resolve type 'uint16_t' : I couldn't find an appropriate Go type for the C type 'uint16_t'.
// Warning (*ast.ReturnStmt):  GOPATH/History_frame3DD/src/NRutil.c:61 :cannot transpileToStmt : cannot transpileReturnStmt. err = cannot transpileToExpr. err = cannot transpile BinaryOperator with type 'uint16_t *' : result type = {unknown52}. Error: operator is `+`. cannot atomic for left part. cannot transpileToExpr. err = cannot transpile BinaryOperator with type 'uint16_t *' : result type = {}. Error: operator is `-`. pointer operation is not valid : cannot transpile pointerArithmetic. err = cannot transpile pointerArithmetic. err = cannot resolve type 'uint16_t *' : cannot resolve star `*` for uint16_t * : cannot resolve type 'uint16_t' : I couldn't find an appropriate Go type for the C type 'uint16_t'.
// Warning (*ast.FunctionDecl): {prefix: n:u16vector,t1:uint16_t *(long, long),t2:}.  GOPATH/History_frame3DD/src/NRutil.c:54 :ReturnType: uint16_t *. cannot resolve type 'uint16_t *' : cannot resolve star `*` for uint16_t * : cannot resolve type 'uint16_t' : I couldn't find an appropriate Go type for the C type 'uint16_t'.
// Warning (*ast.BinaryOperator):  GOPATH/History_frame3DD/src/NRutil.c:260 :cannot transpile BinaryOperator with type 'uint16_t *' : result type = {}. Error: operator is `-`. pointer operation is not valid : cannot transpile pointerArithmetic. err = cannot transpile pointerArithmetic. err = cannot resolve type 'uint16_t *' : cannot resolve star `*` for uint16_t * : cannot resolve type 'uint16_t' : I couldn't find an appropriate Go type for the C type 'uint16_t'.
// Warning (*ast.ParenExpr):  GOPATH/History_frame3DD/src/NRutil.c:260 :cannot transpile ParenExpr. err = cannot transpileToExpr. err = cannot transpile BinaryOperator with type 'uint16_t *' : result type = {}. Error: operator is `-`. pointer operation is not valid : cannot transpile pointerArithmetic. err = cannot transpile pointerArithmetic. err = cannot resolve type 'uint16_t *' : cannot resolve star `*` for uint16_t * : cannot resolve type 'uint16_t' : I couldn't find an appropriate Go type for the C type 'uint16_t'.
// Warning (*ast.ImplicitCastExpr):  GOPATH/History_frame3DD/src/NRutil.c:260 :argument position is 0. cannot transpileToExpr. err = cannot transpileImplicitCastExpr. err = cannot transpileToExpr. err = cannot transpileImplicitCastExpr. err = cannot transpileToExpr. err = cannot transpile ParenExpr. err = cannot transpileToExpr. err = cannot transpile BinaryOperator with type 'uint16_t *' : result type = {}. Error: operator is `-`. pointer operation is not valid : cannot transpile pointerArithmetic. err = cannot transpile pointerArithmetic. err = cannot resolve type 'uint16_t *' : cannot resolve star `*` for uint16_t * : cannot resolve type 'uint16_t' : I couldn't find an appropriate Go type for the C type 'uint16_t'.
// Warning (*ast.CallExpr):  GOPATH/History_frame3DD/src/NRutil.c:260 :cannot transpileToStmt : cannot transpileToExpr. err = error in transpileCallExpr : name of call function is _. argument position is 0. cannot transpileToExpr. err = cannot transpileImplicitCastExpr. err = cannot transpileToExpr. err = cannot transpileImplicitCastExpr. err = cannot transpileToExpr. err = cannot transpile ParenExpr. err = cannot transpileToExpr. err = cannot transpile BinaryOperator with type 'uint16_t *' : result type = {}. Error: operator is `-`. pointer operation is not valid : cannot transpile pointerArithmetic. err = cannot transpile pointerArithmetic. err = cannot resolve type 'uint16_t *' : cannot resolve star `*` for uint16_t * : cannot resolve type 'uint16_t' : I couldn't find an appropriate Go type for the C type 'uint16_t'.
// Warning (*ast.FunctionDecl): {prefix: n:free_u16vector,t1:void (uint16_t *, long, long),t2:}.  GOPATH/History_frame3DD/src/NRutil.c:257 :FieldList type: uint16_t *. cannot resolve type 'uint16_t *' : cannot resolve star `*` for uint16_t * : cannot resolve type 'uint16_t' : I couldn't find an appropriate Go type for the C type 'uint16_t'.

package main
// #cgo CFLAGS : -I../History_frame3DD/src/viewer/ -I../History_frame3DD/src/microstran/ 
// #include </usr/include/unistd.h>
import "C"




import "unicode"
import "reflect"
import "runtime"
import "os"
import "math"
import "math/rand"
import "fmt"
import "golang.org/x/sys/unix"
import "unsafe"
import "github.com/Konstantin8105/c4go/noarch"
// vec3_struct - transpiled function from  GOPATH/History_frame3DD/src/microstran/vec3.h:34
//	FRAME3DD: Static and dynamic structural analysis of 2D & 3D frames and trusses
//	Copyright (C) 2007-2008 John Pye
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
//
//	@file
//	3D vector type and related functions/methods.
//
//
//	3D vector type used by the microstran parser
//
/* AST Error :
unknown node type: `value: Int 1000`
*//* AST Error :
unknown node type: `value: Int 1100`
*//* AST Error :
unknown node type: `value: Int 256`
*//* AST Error :
unknown node type: `value: Int 512`
*//* AST Error :
unknown node type: `value: Int 1024`
*//* AST Error :
unknown node type: `value: Int 2048`
*//* AST Error :
unknown node type: `value: Int 4096`
*//* AST Error :
unknown node type: `value: Int 8192`
*//* AST Error :
unknown node type: `value: Int 16384`
*//* AST Error :
unknown node type: `value: Int 32768`
*//* AST Error :
unknown node type: `value: Int 1`
*//* AST Error :
unknown node type: `value: Int 2`
*//* AST Error :
unknown node type: `value: Int 4`
*//* AST Error :
unknown node type: `value: Int 8`
*//* AST Error :
unknown node type: `value: Int 8`
*//* AST Error :
unknown node type: `value: Int 16`
*//* AST Error :
unknown node type: `value: Int 0`
*//* AST Error :
unknown node type: `value: Int 1`
*//* AST Error :
unknown node type: `value: Int 2`
*//* AST Error :
unknown node type: `value: Int 3`
*//* AST Error :
unknown node type: `value: Int 4`
*//* AST Error :
unknown node type: `value: Int 0`
*//* AST Error :
unknown node type: `value: Int 1`
*//* AST Error :
unknown node type: `value: Int 2`
*//* AST Error :
unknown node type: `value: Int 3`
*//* AST Error :
unknown node type: `value: Int 4`
*//* AST Error :
cannot parse line: `AllocSizeAttr 0x5598b331adb8 <col:14> Implicit 1`. could not match regexp with string
^(?P<address>[0-9a-fx]+) <(?P<position>.*)>(?P<inherited> Inherited)?(?P<a> \d+)(?P<b> \d+)?[\s]*$
0x5598b331adb8 <col:14> Implicit 1

*//* AST Error :
cannot parse line: `AllocSizeAttr 0x5598b331af38 <col:14> Inherited Implicit 1`. could not match regexp with string
^(?P<address>[0-9a-fx]+) <(?P<position>.*)>(?P<inherited> Inherited)?(?P<a> \d+)(?P<b> \d+)?[\s]*$
0x5598b331af38 <col:14> Inherited Implicit 1

*//* AST Error :
cannot parse line: `AllocSizeAttr 0x5598b331af68 <col:14> Implicit 1`. could not match regexp with string
^(?P<address>[0-9a-fx]+) <(?P<position>.*)>(?P<inherited> Inherited)?(?P<a> \d+)(?P<b> \d+)?[\s]*$
0x5598b331af68 <col:14> Implicit 1

*//* AST Error :
cannot parse line: `AllocSizeAttr 0x5598b331b318 <col:14> Implicit 1 2`. could not match regexp with string
^(?P<address>[0-9a-fx]+) <(?P<position>.*)>(?P<inherited> Inherited)?(?P<a> \d+)(?P<b> \d+)?[\s]*$
0x5598b331b318 <col:14> Implicit 1 2

*//* AST Error :
cannot parse line: `AllocSizeAttr 0x5598b331b4a0 <col:14> Inherited Implicit 1 2`. could not match regexp with string
^(?P<address>[0-9a-fx]+) <(?P<position>.*)>(?P<inherited> Inherited)?(?P<a> \d+)(?P<b> \d+)?[\s]*$
0x5598b331b4a0 <col:14> Inherited Implicit 1 2

*//* AST Error :
cannot parse line: `AllocSizeAttr 0x5598b331b4d0 <line:556:14> Implicit 1 2`. could not match regexp with string
^(?P<address>[0-9a-fx]+) <(?P<position>.*)>(?P<inherited> Inherited)?(?P<a> \d+)(?P<b> \d+)?[\s]*$
0x5598b331b4d0 <line:556:14> Implicit 1 2

*//* AST Error :
cannot parse line: `AllocSizeAttr 0x5598b331b888 <col:14> Implicit 2`. could not match regexp with string
^(?P<address>[0-9a-fx]+) <(?P<position>.*)>(?P<inherited> Inherited)?(?P<a> \d+)(?P<b> \d+)?[\s]*$
0x5598b331b888 <col:14> Implicit 2

*//* AST Error :
cannot parse line: `AllocSizeAttr 0x5598b331ba18 <col:14> Inherited Implicit 2`. could not match regexp with string
^(?P<address>[0-9a-fx]+) <(?P<position>.*)>(?P<inherited> Inherited)?(?P<a> \d+)(?P<b> \d+)?[\s]*$
0x5598b331ba18 <col:14> Inherited Implicit 2

*//* AST Error :
cannot parse line: `AllocSizeAttr 0x5598b331ba48 <line:564:14> Implicit 2`. could not match regexp with string
^(?P<address>[0-9a-fx]+) <(?P<position>.*)>(?P<inherited> Inherited)?(?P<a> \d+)(?P<b> \d+)?[\s]*$
0x5598b331ba48 <line:564:14> Implicit 2

*//* AST Error :
cannot parse line: `AllocSizeAttr 0x5598b331d090 <col:14> Implicit 2`. could not match regexp with string
^(?P<address>[0-9a-fx]+) <(?P<position>.*)>(?P<inherited> Inherited)?(?P<a> \d+)(?P<b> \d+)?[\s]*$
0x5598b331d090 <col:14> Implicit 2

*//* AST Error :
cannot parse line: `AllocSizeAttr 0x5598b331d240 <col:14> Inherited Implicit 2`. could not match regexp with string
^(?P<address>[0-9a-fx]+) <(?P<position>.*)>(?P<inherited> Inherited)?(?P<a> \d+)(?P<b> \d+)?[\s]*$
0x5598b331d240 <col:14> Inherited Implicit 2

*//* AST Error :
cannot parse line: `AllocSizeAttr 0x5598b331d270 <line:605:14> Implicit 2`. could not match regexp with string
^(?P<address>[0-9a-fx]+) <(?P<position>.*)>(?P<inherited> Inherited)?(?P<a> \d+)(?P<b> \d+)?[\s]*$
0x5598b331d270 <line:605:14> Implicit 2

*//* AST Error :
unknown node type: `value: Int 32`
*//* AST Error :
unknown node type: `value: Int 32`
*//* AST Error :
unknown node type: `value: Int 32`
*//* AST Error :
unknown node type: `value: Int 32`
*//* AST Error :
unknown node type: `value: Int 32`
*//* AST Error :
unknown node type: `value: Int 32`
*//* AST Error :
unknown node type: `value: Int 32`
*//* AST Error :
unknown node type: `value: Int 32`
*//* AST Error :
unknown node type: `value: Int 32`
*//* AST Error :
unknown node type: `value: Int 32`
*//* AST Error :
unknown node type: `value: Int 32`
*//* AST Error :
unknown node type: `value: Int 60`
*//* AST Error :
unknown node type: `value: Int 235`
*/type vec3_struct struct {
	x float64
	y float64
	z float64
}
// vec3 - transpiled function from  GOPATH/History_frame3DD/src/microstran/vec3.h:34
type vec3 = vec3_struct
// FCOMPLEX - transpiled function from  GOPATH/History_frame3DD/src/NRutil.h:10
// @file
//	Memory allocation functions from Numerical Recipes in C, by Press,
//	Cambridge University Press, 1988
//	http://www.nr.com/public-domain.html
//
// also in complex.h
type FCOMPLEX struct {
	r float32
	i float32
}
// fcomplex - transpiled function from  GOPATH/History_frame3DD/src/NRutil.h:10
type fcomplex = FCOMPLEX
// main - transpiled function from  GOPATH/History_frame3DD/src/main.c:65
func main() {
	argc := int32(len(os.Args))
	argv := [][]byte{}
	for _, argvSingle := range os.Args {
		argv = append(argv, []byte(argvSingle))
	}
	defer noarch.AtexitRun()
	//
	//   This file is part of FRAME3DD:
	// Static and dynamic structural analysis of 2D and 3D frames and trusses with
	// elastic and geometric stiffness.
	// ---------------------------------------------------------------------------
	// http://frame3dd.sourceforge.net/
	// ---------------------------------------------------------------------------
	// Copyright (C) 1992-2014  Henri P. Gavin
	//
	//    FRAME3DD is free software: you can redistribute it and/or modify
	//    it under the terms of the GNU General Public License as published by
	//    the Free Software Foundation, either version 3 of the License, or
	//    (at your option) any later version.
	//
	//    FRAME3DD is distributed in the hope that it will be useful,
	//    but WITHOUT ANY WARRANTY; without even the implied warranty of
	//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	//    GNU General Public License for more details.
	//
	//    You should have received a copy of the GNU General Public License
	//    along with FRAME3DD.  If not, see <http://www.gnu.org/licenses/>.
	//
	// @file
	// Main FRAME3DD program driver
	//
	// @mainpage
	//FRAME3DD: a program for static and dynamic structural analysis of 2D and 3D
	//frames and trusses with elastic and geometric stiffness.
	//
	//Also included is a system for parsing Microstran .arc 'Archive' files and
	//for parsing calculated force and displacement output files (.p1 format) from
	//Microstran. See @ref mstranp. It is intended that ultimately the .arc format
	//be an alternative method of inputting data to the FRAME3DD program,
	//but currently these two parts of the code are distinct.
	//
	//For more information go to http://frame3dd.sourceforge.net/
	//
	//The input file format for FRAME is defined in doc/user_manual.html
	//
	//Henri P. Gavin hpgavin@duke.edu (main FRAME3DD code)
	//John Pye john.pye@anu.edu.au (Microstran parser and viewer)
	//
	//For compilation/installation, see README.txt.
	//
	//
	// compile the Frame3DD analysis into another code, such as a GUI
	// compile Frame3DD to run as a stand-alone code through the terminal
	// the input  data filename
	var IN_file []byte = make([]byte, 128)
	var OUT_file []byte = make([]byte, 128)
	var title []byte = make([]byte, 512)
	var errMsg []byte = make([]byte, 512)
	var meshpath []byte = []byte("EMPTY_MESH\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00")
	var plotpath []byte = []byte("EMPTY_PLOT\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00")
	var infcpath []byte = []byte("EMPTY_INFC\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00")
	var modepath []byte = []byte("EMPTY_MODE\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00")
	var strippedInputFile []byte = []byte("EMPTY_TEMP\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00")
	// the output data filename
	// the title of the analysis
	// the text of an error message
	// mesh data path
	// plot file path
	// int  file path
	// mode data path
	// temp data path
	// input and output file pointer
	var fp *noarch.File
	// X,Y,Z node coordinates (global)
	var xyz []vec3
	// node size radius, for finite sizes
	var rj []float32
	var Ax []float32
	var Asy []float32
	var Asz []float32
	var Jx []float32
	var Iy []float32
	var Iz []float32
	var E []float32
	var G []float32
	var p []float32
	var U [][][]float32
	var W [][][]float32
	var P [][][]float32
	var T [][][]float32
	var Dp [][]float32
	var d []float32
	var EMs []float32
	var NMs []float32
	var NMx []float32
	var NMy []float32
	var NMz []float32
	var gX []float32 = make([]float32, 32)
	var gY []float32 = make([]float32, 32)
	var gZ []float32 = make([]float32, 32)
	var pan float32 = float32(1)
	var scale float32 = float32(1)
	var dx float32 = float32(1)
	// cross section areas, incl. shear
	// section inertias
	// elastic modulus and shear moduli
	// roll of each member, radians
	// uniform distributed member loads
	// trapizoidal distributed member loads
	// member concentrated loads
	// member temperature  loads
	// prescribed node displacements
	// member densities and extra inertia
	// mass of a node
	// inertia of a node in global coord
	// gravitational acceleration in global X
	// gravitational acceleration in global Y
	// gravitational acceleration in global Z
	// >0: pan during animation; 0: don't
	// zoom scale for 3D plotting in Gnuplot
	// x-increment for internal force data
	// equilibrium stiffness matrix
	var K [][]float64
	var traceK float64
	var M [][]float64
	var traceM float64
	var eqF_mech [][][]float64
	var eqF_temp [][][]float64
	var F_mech [][]float64
	var F_temp [][]float64
	var F []float64
	var R []float64
	var dR []float64
	var D []float64
	var dD []float64
	var dF []float64
	var L []float64
	var Le []float64
	var Q [][]float64
	var tol float64 = 1e-09
	var shift float64
	var struct_mass float64
	var total_mass float64
	var f []float64
	var V [][]float64
	var rms_resid float64 = 1
	var error_ float64 = 1
	var Cfreq float64
	var Kc [][]float64
	var Mc [][]float64
	var exagg_static float64 = 10
	var exagg_modal float64 = 10
	// **Ks=NULL, // Broyden secant stiffness matrix
	// trace of the global stiffness matrix
	// global mass matrix
	// trace of the global mass matrix
	// equivalent end forces from mech loads global
	// equivalent end forces from temp loads global
	// mechanical load vectors, all load cases
	// thermal load vectors, all load cases
	// total load vectors for a load case
	// total reaction force vector
	// incremental reaction force vector
	// displacement vector
	// incremental displacement vector
	//dDdD = 0.0, // dD' * dD
	// equilibrium error in nonlinear anlys
	// node-to-node length of each element
	// effcve lngth, accounts for node size
	// local member node end-forces
	// tolerance for modal convergence
	// shift-factor for rigid-body-modes
	// mass of structural system
	// total structural mass and extra mass
	// resonant frequencies
	// resonant mode-shapes
	// root mean square of residual displ. error
	// rms equilibrium error and reactions
	// frequency used for Guyan condensation
	// condensed stiffness and mass matrices
	// exaggerate static displ. in mesh data
	// exaggerate modal displ. in mesh data
	// peak internal forces, moments, and displacments
	// in each frame element and each load case
	var pkNx [][]float64
	var pkVy [][]float64
	var pkVz [][]float64
	var pkTx [][]float64
	var pkMy [][]float64
	var pkMz [][]float64
	var pkDx [][]float64
	var pkDy [][]float64
	var pkDz [][]float64
	var pkRx [][]float64
	var pkSy [][]float64
	var pkSz [][]float64
	// number of Nodes
	var nN int32
	var nE int32
	var nL int32
	var lc int32
	var DoF int32
	var i int32
	var j int32
	var nR int32
	var nD []int32 = make([]int32, 32)
	var nF []int32 = make([]int32, 32)
	var nU []int32 = make([]int32, 32)
	var nW []int32 = make([]int32, 32)
	var nP []int32 = make([]int32, 32)
	var nT []int32 = make([]int32, 32)
	var nI int32
	var nX int32
	var nC int32
	var N1 []int32
	var N2 []int32
	var shear int32
	var geom int32
	var anlyz int32 = 1
	var q []int32
	var r []int32
	var sumR int32
	var nM int32
	var Mmethod int32
	var nM_calc int32
	var lump int32 = 1
	var iter int32
	var ok int32 = 1
	var anim []int32 = make([]int32, 128)
	var Cdof int32
	var Cmethod int32
	var c []int32
	var m []int32
	var filetype int32
	var debug int32
	var verbose int32 = 1
	var axial_strain_warning int32
	var ExitCode int32
	// number of frame Elements
	// number of Load cases
	// number of Degrees of Freedom
	// number of restrained nodes
	// number of prescribed nodal displ'nts
	// number of loaded nodes
	// number of members w/ unifm dist loads
	// number of members w/ trapz dist loads
	// number of members w/ conc point loads
	// number of members w/ temp. changes
	// number of nodes w/ extra inertia
	// number of elemts w/ extra mass
	// number of condensed nodes
	// begin and end node numbers
	// indicates shear deformation
	// indicates  geometric nonlinearity
	// 1: stiffness analysis, 0: data check
	// reaction data, total no. of reactions
	// number of desired modes
	// 1: Subspace Jacobi, 2: Stodola
	// number of modes to calculate
	// 1: lumped, 0: consistent mass matrix
	// number of iterations
	// number of (-ve) diag. terms of L D L'
	// the modes to be animated
	// number of condensed degrees o freedom
	// matrix condensation method
	// vector of DoF's to condense
	// vector of modes to condense
	// 1 if .CSV, 2 if file is Matlab
	// 1: debugging screen output, 0: none
	// 1: copious screen output, 0: none
	// 0: "ok", 1: strain > 0.001
	// error code returned by Frame3DD
	//   over-ride input file value
	var shear_flag int32 = -1
	var geom_flag int32 = -1
	var anlyz_flag int32 = -1
	var D3_flag int32 = -1
	var lump_flag int32 = -1
	var modal_flag int32 = -1
	var write_matrix int32 = -1
	var axial_sign int32 = -1
	var condense_flag int32 = -1
	//   over-ride input file value
	//   over-ride input file value
	//   over-ride 3D plotting check
	//   over-ride input file value
	//   over-ride input file value
	//   write stiffness and mass matrix
	//   suppress 't' or 'c' in output data
	// over-ride input file value
	// *scanf return value for err checking
	var sfrv int32
	// over-ride input file value
	var exagg_flag float64 = -1
	var tol_flag float64 = -1
	var shift_flag float64 = -1
	// over-ride input file value
	// over-ride input file value
	// over-ride input file value
	var pan_flag float32 = float32(-1)
	// Input Data file name extension
	var extn []byte = make([]byte, 16)
	parse_options(argc, argv, IN_file, OUT_file, c4goUnsafeConvert_int32(&shear_flag), c4goUnsafeConvert_int32(&geom_flag), c4goUnsafeConvert_int32(&anlyz_flag), c4goUnsafeConvert_float64(&exagg_flag), c4goUnsafeConvert_int32(&D3_flag), c4goUnsafeConvert_int32(&lump_flag), c4goUnsafeConvert_int32(&modal_flag), c4goUnsafeConvert_float64(&tol_flag), c4goUnsafeConvert_float64(&shift_flag), c4goUnsafeConvert_float32(&pan_flag), c4goUnsafeConvert_int32(&write_matrix), c4goUnsafeConvert_int32(&axial_sign), c4goUnsafeConvert_int32(&condense_flag), c4goUnsafeConvert_int32(&verbose), c4goUnsafeConvert_int32(&debug))
	if verbose != 0 {
		//  display program name, version and license type
		textColor('w', 'b', 'b', 'x')
		noarch.Fprintf(noarch.Stdout, []byte("\n FRAME3DD version: %s\n\x00"), []byte("20140514+\x00"))
		noarch.Fprintf(noarch.Stdout, []byte(" Analysis of 2D and 3D structural frames with elastic and geometric stiffness.\n\x00"))
		//frame3dd.sf.net\n");
		noarch.Fprintf(noarch.Stdout, []byte(" http://frame3dd.sf.net\n\x00"))
		noarch.Fprintf(noarch.Stdout, []byte(" GPL Copyright (C) 1992-2014, Henri P. Gavin\n\x00"))
		noarch.Fprintf(noarch.Stdout, []byte(" This is free software with absolutely no warranty.\n\x00"))
		noarch.Fprintf(noarch.Stdout, []byte(" For details, see the GPL license file, LICENSE.txt\n\x00"))
		color(0)
		noarch.Fprintf(noarch.Stdout, []byte("\n\x00"))
	}
	if (func() *noarch.File {
		fp = noarch.Fopen(IN_file, []byte("r\x00"))
		return fp
	}()) == nil {
		// open the input data file
		// open input data file
		noarch.Sprintf(errMsg, []byte("\n ERROR: cannot open input data file '%s'\n\x00"), IN_file)
		errorMsg(errMsg)
		display_help()
		if argc == 1 {
			noarch.Fprintf(noarch.Stderr, []byte(" Press the 'Enter' key to close.\n\x00"))
			// clear the buffer ??
			_ = noarch.Getchar()
			// wait for the Enter key
			for noarch.Not(noarch.Getchar()) {
			}
		}
		unix.Exit(11)
	}
	// .CSV or .FMM or other?
	filetype = get_file_ext(IN_file, extn)
	// temp_file_location("frame3dd.3dd",strippedInputFile,FRAME3DD_PATHMAX);
	output_path([]byte("frame3dd.3dd\x00"), strippedInputFile, 512, nil)
	// strip comments from input data
	parse_input(fp, strippedInputFile)
	noarch.Fclose(fp)
	if (func() *noarch.File {
		fp = noarch.Fopen(strippedInputFile, []byte("r\x00"))
		return fp
	}()) == nil {
		// open stripped input file
		noarch.Sprintf(errMsg, []byte("\n ERROR: cannot open stripped input data file '%s'\n\x00"), strippedInputFile)
		errorMsg(errMsg)
		unix.Exit(13)
	}
	frame3dd_getline(fp, title, 512)
	if verbose != 0 {
		//  display analysis title
		textColor('w', 'g', 'b', 'x')
		noarch.Fprintf(noarch.Stdout, []byte("\n\x00"))
		noarch.Fprintf(noarch.Stdout, []byte(" ** %s ** \n\x00"), title)
		color(0)
		noarch.Fprintf(noarch.Stdout, []byte("\n\x00"))
	}
	// number of nodes
	sfrv = noarch.Fscanf(fp, []byte("%d\x00"), c4goUnsafeConvert_int32(&nN))
	if sfrv != 1 {
		sferr([]byte("nN value for number of nodes\x00"))
	}
	if verbose != 0 {
		// display nN
		noarch.Fprintf(noarch.Stdout, []byte(" number of nodes \x00"))
		dots(noarch.Stdout, 36)
		noarch.Fprintf(noarch.Stdout, []byte(" nN =%4d \x00"), nN)
	}
	// allocate memory for node data ...
	// rigid radius around each node
	rj = vector(1, nN)
	// node coordinates
	xyz = make([]vec3, 1*int32(uint32(1+nN)))
	read_node_data(fp, nN, xyz, rj)
	if verbose != 0 {
		fmt.Printf(" ... complete\n")
	}
	// total number of degrees of freedom
	DoF = 6*nN
	// allocate memory for reaction data ...
	q = ivector(1, DoF)
	// allocate memory for reaction data ...
	r = ivector(1, DoF)
	read_reaction_data(fp, DoF, nN, c4goUnsafeConvert_int32(&nR), q, r, c4goUnsafeConvert_int32(&sumR), verbose)
	if verbose != 0 {
		noarch.Fprintf(noarch.Stdout, []byte(" ... complete\n\x00"))
	}
	// number of frame elements
	sfrv = noarch.Fscanf(fp, []byte("%d\x00"), c4goUnsafeConvert_int32(&nE))
	if sfrv != 1 {
		sferr([]byte("nE value for number of frame elements\x00"))
	}
	if verbose != 0 {
		// display nE
		noarch.Fprintf(noarch.Stdout, []byte(" number of frame elements\x00"))
		dots(noarch.Stdout, 28)
		noarch.Fprintf(noarch.Stdout, []byte(" nE =%4d \x00"), nE)
	}
	if nN > nE+1 {
		// not enough elements
		noarch.Fprintf(noarch.Stderr, []byte("\n  warning: %d nodes and %d members...\x00"), nN, nE)
		noarch.Fprintf(noarch.Stderr, []byte(" not enough elements to connect all nodes.\n\x00"))
	}
	// allocate memory for frame elements ...
	// length of each element
	L = dvector(1, nE)
	// effective length of each element
	Le = dvector(1, nE)
	// node #1 of each element
	N1 = ivector(1, nE)
	// node #2 of each element
	N2 = ivector(1, nE)
	// cross section area of each element
	Ax = vector(1, nE)
	// shear area in local y direction
	Asy = vector(1, nE)
	// shear area in local z direction
	Asz = vector(1, nE)
	// torsional moment of inertia
	Jx = vector(1, nE)
	// bending moment of inertia about y-axis
	Iy = vector(1, nE)
	// bending moment of inertia about z-axis
	Iz = vector(1, nE)
	// frame element Young's modulus
	E = vector(1, nE)
	// frame element shear modulus
	G = vector(1, nE)
	// element rotation angle about local x axis
	p = vector(1, nE)
	// element mass density
	d = vector(1, nE)
	read_frame_element_data(fp, nN, nE, xyz, rj, L, Le, N1, N2, Ax, Asy, Asz, Jx, Iy, Iz, E, G, p, d)
	if verbose != 0 {
		noarch.Fprintf(noarch.Stdout, []byte(" ... complete\n\x00"))
	}
	read_run_data(fp, OUT_file, c4goUnsafeConvert_int32(&shear), shear_flag, c4goUnsafeConvert_int32(&geom), geom_flag, meshpath, plotpath, infcpath, c4goUnsafeConvert_float64(&exagg_static), exagg_flag, c4goUnsafeConvert_float32(&scale), c4goUnsafeConvert_float32(&dx), c4goUnsafeConvert_int32(&anlyz), anlyz_flag, debug)
	// number of load cases
	sfrv = noarch.Fscanf(fp, []byte("%d\x00"), c4goUnsafeConvert_int32(&nL))
	if sfrv != 1 {
		sferr([]byte("nL value for number of load cases\x00"))
	}
	if verbose != 0 {
		// display nL
		noarch.Fprintf(noarch.Stdout, []byte(" number of load cases \x00"))
		dots(noarch.Stdout, 31)
		noarch.Fprintf(noarch.Stdout, []byte(" nL = %3d \n\x00"), nL)
	}
	if nL < 1 {
		// not enough load cases
		errorMsg([]byte("\n ERROR: the number of load cases must be at least 1\n\x00"))
		unix.Exit(101)
	}
	if nL >= 32 {
		// too many load cases
		noarch.Sprintf(errMsg, []byte("\n ERROR: maximum of %d load cases allowed\n\x00"), 32-1)
		errorMsg(errMsg)
		unix.Exit(102)
	}
	// allocate memory for loads ...
	// uniform load on each member
	U = D3matrix(1, nL, 1, nE, 1, 4)
	// trapezoidal load on each member
	W = D3matrix(1, nL, 1, 10*nE, 1, 13)
	// internal point load each member
	P = D3matrix(1, nL, 1, 10*nE, 1, 5)
	// internal temp change each member
	T = D3matrix(1, nL, 1, nE, 1, 8)
	// prescribed displacement of each node
	Dp = matrix(1, nL, 1, DoF)
	// mechanical load vector
	F_mech = dmatrix(1, nL, 1, DoF)
	// temperature load vector
	F_temp = dmatrix(1, nL, 1, DoF)
	// external load vector
	F = dvector(1, DoF)
	// equilibrium error {F} - [K]{D}
	dF = dvector(1, DoF)
	// eqF due to mech loads
	eqF_mech = D3dmatrix(1, nL, 1, nE, 1, 12)
	// eqF due to temp loads
	eqF_temp = D3dmatrix(1, nL, 1, nE, 1, 12)
	// global stiffness matrix
	K = dmatrix(1, DoF, 1, DoF)
	// end forces for each member
	Q = dmatrix(1, nE, 1, 12)
	// displacments of each node
	D = dvector(1, DoF)
	// incremental displ. of each node
	dD = dvector(1, DoF)
	// reaction forces
	R = dvector(1, DoF)
	// incremental reaction forces
	dR = dvector(1, DoF)
	// lumped mass for each frame element
	EMs = vector(1, nE)
	// node mass for each node
	NMs = vector(1, nN)
	// node inertia about global X axis
	NMx = vector(1, nN)
	// node inertia about global Y axis
	NMy = vector(1, nN)
	// node inertia about global Z axis
	NMz = vector(1, nN)
	// vector of condensed degrees of freedom
	c = ivector(1, DoF)
	// vector of condensed mode numbers
	m = ivector(1, DoF)
	// peak axial forces, shears, torques, and moments along each element
	pkNx = dmatrix(1, nL, 1, nE)
	pkVy = dmatrix(1, nL, 1, nE)
	pkVz = dmatrix(1, nL, 1, nE)
	pkTx = dmatrix(1, nL, 1, nE)
	pkMy = dmatrix(1, nL, 1, nE)
	pkMz = dmatrix(1, nL, 1, nE)
	// peak displacements and slopes along each element
	pkDx = dmatrix(1, nL, 1, nE)
	pkDy = dmatrix(1, nL, 1, nE)
	pkDz = dmatrix(1, nL, 1, nE)
	pkRx = dmatrix(1, nL, 1, nE)
	pkSy = dmatrix(1, nL, 1, nE)
	pkSz = dmatrix(1, nL, 1, nE)
	read_and_assemble_loads(fp, nN, nE, nL, DoF, xyz, L, Le, N1, N2, Ax, Asy, Asz, Iy, Iz, E, G, p, d, gX, gY, gZ, r, shear, nF, nU, nW, nP, nT, nD, Q, F_temp, F_mech, F, U, W, P, T, Dp, eqF_mech, eqF_temp, verbose)
	if verbose != 0 {
		// display load data complete
		noarch.Fprintf(noarch.Stdout, []byte("                                                     \x00"))
		noarch.Fprintf(noarch.Stdout, []byte(" load data ... complete\n\x00"))
	}
	read_mass_data(fp, IN_file, nN, nE, c4goUnsafeConvert_int32(&nI), c4goUnsafeConvert_int32(&nX), d, EMs, NMs, NMx, NMy, NMz, L, Ax, c4goUnsafeConvert_float64(&total_mass), c4goUnsafeConvert_float64(&struct_mass), c4goUnsafeConvert_int32(&nM), c4goUnsafeConvert_int32(&Mmethod), modal_flag, c4goUnsafeConvert_int32(&lump), lump_flag, c4goUnsafeConvert_float64(&tol), tol_flag, c4goUnsafeConvert_float64(&shift), shift_flag, c4goUnsafeConvert_float64(&exagg_modal), modepath, anim, c4goUnsafeConvert_float32(&pan), pan_flag, verbose, debug)
	if verbose != 0 {
		// display mass data complete
		noarch.Fprintf(noarch.Stdout, []byte("                                                     \x00"))
		noarch.Fprintf(noarch.Stdout, []byte(" mass data ... complete\n\x00"))
	}
	read_condensation_data(fp, nN, nM, c4goUnsafeConvert_int32(&nC), c4goUnsafeConvert_int32(&Cdof), c4goUnsafeConvert_int32(&Cmethod), condense_flag, c, m, verbose)
	if nC > 0 && verbose != 0 {
		//  display condensation data complete
		noarch.Fprintf(noarch.Stdout, []byte("                                      \x00"))
		noarch.Fprintf(noarch.Stdout, []byte(" matrix condensation data ... complete\n\x00"))
	}
	// close the input data file
	noarch.Fclose(fp)
	// open the output data file for appending
	fp = noarch.Fopen(OUT_file, []byte("a\x00"))
	if fp == nil {
		// unable to append to output data file
		noarch.Fprintf(noarch.Stderr, []byte("Unable to append to output data file '%s'!\n\x00"), OUT_file)
		unix.Exit(14)
	}
	write_input_data(fp, title, nN, nE, nL, nD, nR, nF, nU, nW, nP, nT, xyz, rj, N1, N2, Ax, Asy, Asz, Jx, Iy, Iz, E, G, p, d, gX, gY, gZ, F_temp, F_mech, Dp, r, U, W, P, T, shear, anlyz, geom)
	if anlyz != 0 {
		// solve the problem
		rand.Seed(int64(uint32(noarch.Time(nil))))
		{
			// begin load case analysis loop
			for lc = 1; lc <= nL; lc++ {
				if verbose != 0 {
					// display the load case number
					noarch.Fprintf(noarch.Stdout, []byte("\n\x00"))
					textColor('y', 'g', 'b', 'x')
					noarch.Fprintf(noarch.Stdout, []byte(" Load Case %d of %d ... \x00"), lc, nL)
					noarch.Fprintf(noarch.Stdout, []byte("                                          \x00"))
					noarch.Fflush(noarch.Stdout)
					color(0)
					noarch.Fprintf(noarch.Stdout, []byte("\n\x00"))
				}
				{
					//  initialize displacements and displ. increment to {0}
					//  initialize reactions     and react. increment to {0}
					for i = 1; i <= DoF; i++ {
						dR[i] = 0
						R[i] = dR[i]
						dD[i] = R[i]
						D[i] = dD[i]
					}
				}
				{
					//  initialize internal element end forces Q = {0}
					for i = 1; i <= nE; i++ {
						for j = 1; j <= 12; j++ {
							Q[i][j] = 0
						}
					}
				}
				//  elastic stiffness matrix  [K({D}^(i))], {D}^(0)={0} (i=0)
				assemble_K(K, DoF, nE, xyz, rj, L, Le, N1, N2, Ax, Asy, Asz, Jx, Iy, Iz, E, G, p, shear, geom, Q, debug)
				if nT[lc] > 0 {
					if verbose != 0 {
						// first apply temperature loads only, if there are any ...
						noarch.Fprintf(noarch.Stdout, []byte(" Linear Elastic Analysis ... Temperature Loads\n\x00"))
					}
					//  solve {F_t} = [K({D=0})] * {D_t}
					solve_system(K, dD, F_temp[lc], dR, DoF, q, r, c4goUnsafeConvert_int32(&ok), verbose, c4goUnsafeConvert_float64(&rms_resid))
					{
						// increment {D_t} = {0} + {D_t} temp.-induced displ
						for i = 1; i <= DoF; i++ {
							if q[i] != 0 {
								D[i] += dD[i]
							}
						}
					}
					{
						// increment {R_t} = {0} + {R_t} temp.-induced react
						for i = 1; i <= DoF; i++ {
							if r[i] != 0 {
								R[i] += dR[i]
							}
						}
					}
					if geom != 0 {
						// assemble K = Ke + Kg
						// compute   {Q}={Q_t} ... temp.-induced forces
						element_end_forces(Q, nE, xyz, L, Le, N1, N2, Ax, Asy, Asz, Jx, Iy, Iz, E, G, p, eqF_temp[lc], eqF_mech[lc], D, shear, geom, c4goUnsafeConvert_int32(&axial_strain_warning))
						// assemble temp.-stressed stiffness [K({D_t})]
						assemble_K(K, DoF, nE, xyz, rj, L, Le, N1, N2, Ax, Asy, Asz, Jx, Iy, Iz, E, G, p, shear, geom, Q, debug)
					}
				}
				if nF[lc] > 0 || nU[lc] > 0 || nW[lc] > 0 || nP[lc] > 0 || nD[lc] > 0 || gX[lc] != 0 || gY[lc] != 0 || gZ[lc] != 0 {
					if verbose != 0 {
						// ... then apply mechanical loads only, if there are any ...
						noarch.Fprintf(noarch.Stdout, []byte(" Linear Elastic Analysis ... Mechanical Loads\n\x00"))
					}
					{
						// incremental displ at react'ns = prescribed displ
						for i = 1; i <= DoF; i++ {
							if r[i] != 0 {
								dD[i] = float64(Dp[lc][i])
							}
						}
					}
					//  solve {F_m} = [K({D_t})] * {D_m}
					solve_system(K, dD, F_mech[lc], dR, DoF, q, r, c4goUnsafeConvert_int32(&ok), verbose, c4goUnsafeConvert_float64(&rms_resid))
					{
						// combine {D} = {D_t} + {D_m}
						for i = 1; i <= DoF; i++ {
							if q[i] != 0 {
								D[i] += dD[i]
							} else {
								D[i] = float64(Dp[lc][i])
								dD[i] = 0
							}
						}
					}
					{
						// combine {R} = {R_t} + {R_m} --- for linear systems
						for i = 1; i <= DoF; i++ {
							if r[i] != 0 {
								R[i] += dR[i]
							}
						}
					}
				}
				{
					//  combine {F} = {F_t} + {F_m}
					for i = 1; i <= DoF; i++ {
						F[i] = F_temp[lc][i]+F_mech[lc][i]
					}
				}
				//  element forces {Q} for displacements {D}
				element_end_forces(Q, nE, xyz, L, Le, N1, N2, Ax, Asy, Asz, Jx, Iy, Iz, E, G, p, eqF_temp[lc], eqF_mech[lc], D, shear, geom, c4goUnsafeConvert_int32(&axial_strain_warning))
				//  check the equilibrium error
				error_ = equilibrium_error(dF, F, K, D, DoF, q, r)
				if geom != 0 && verbose != 0 {
					noarch.Fprintf(noarch.Stdout, []byte("\n Non-Linear Elastic Analysis ...\n\x00"))
				}
				if geom != 0 {
					//
					// *   if ( geom ) { // initialize Broyden secant stiffness matrix, Ks
					// *    Ks  = dmatrix( 1, DoF, 1, DoF );
					// *    for (i=1;i<=DoF;i++) {
					// *     for(j=i;j<=DoF;j++) {
					// *      Ks[i][j]=Ks[j][i]=K[i][j];
					// *     }
					// *    }
					// *   }
					//
					// quasi Newton-Raphson iteration for geometric nonlinearity
					// re-initialize
					error_ = 1
					ok = 0
					iter = 0
				}
				for geom != 0 && error_ > tol && iter < 500 && ok >= 0 {
					iter ++
					//  assemble stiffness matrix [K({D}^(i))]
					assemble_K(K, DoF, nE, xyz, rj, L, Le, N1, N2, Ax, Asy, Asz, Jx, Iy, Iz, E, G, p, shear, geom, Q, debug)
					//  compute equilibrium error, {dF}, at iteration i
					//  {dF}^(i) = {F} - [K({D}^(i))]*{D}^(i)
					//  convergence criteria = || {dF}^(i) ||  /  || F ||
					error_ = equilibrium_error(dF, F, K, D, DoF, q, r)
					//  Powell-Symmetric-Broyden secant stiffness update
					// PSB_update ( Ks, dF, dD, DoF );  /* not helpful?   */
					//  solve {dF}^(i) = [K({D}^(i))] * {dD}^(i)
					solve_system(K, dD, dF, dR, DoF, q, r, c4goUnsafeConvert_int32(&ok), verbose, c4goUnsafeConvert_float64(&rms_resid))
					if ok < 0 {
						//  K is not positive definite
						noarch.Fprintf(noarch.Stderr, []byte("   The stiffness matrix is not pos-def. \n\x00"))
						noarch.Fprintf(noarch.Stderr, []byte("   Reduce loads and re-run the analysis.\n\x00"))
						ExitCode = 181
						break
					}
					{
						//  increment {D}^(i+1) = {D}^(i) + {dD}^(i)
						for i = 1; i <= DoF; i++ {
							if q[i] != 0 {
								D[i] += dD[i]
							}
						}
					}
					//  element forces {Q} for displacements {D}^(i)
					element_end_forces(Q, nE, xyz, L, Le, N1, N2, Ax, Asy, Asz, Jx, Iy, Iz, E, G, p, eqF_temp[lc], eqF_mech[lc], D, shear, geom, c4goUnsafeConvert_int32(&axial_strain_warning))
					if verbose != 0 {
						//  display equilibrium error
						noarch.Fprintf(noarch.Stdout, []byte("   NR iteration %3d ---\x00"), iter)
						noarch.Fprintf(noarch.Stdout, []byte(" RMS relative equilibrium error = %8.2e \n\x00"), error_)
					}
				}
				if axial_strain_warning > 0 && ExitCode == 0 {
					// end quasi Newton-Raphson iteration
					//   strain limit failure ...
					ExitCode = 182
				}
				if axial_strain_warning > 0 && ExitCode == 181 {
					//   strain limit _and_ buckling failure ...
					ExitCode = 183
				}
				if geom != 0 {
					compute_reaction_forces(R, F, K, D, DoF, r)
				}
				if write_matrix != 0 {
					//  dealocate Broyden secant stiffness matrix, Ks
					// if ( geom ) free_dmatrix(Ks, 1, DoF, 1, DoF );
					// write static stiffness matrix
					save_ut_dmatrix([]byte("Ks\x00"), K, DoF, []byte("w\x00"))
				}
				if verbose != 0 && ok >= 0 {
					//  display RMS equilibrium error
					evaluate(float32(error_), float32(rms_resid), float32(tol), geom)
				}
				write_static_results(fp, nN, nE, nL, lc, DoF, N1, N2, F, D, R, r, Q, rms_resid, ok, axial_sign)
				if filetype == 1 {
					// .CSV format output
					write_static_csv(OUT_file, title, nN, nE, nL, lc, DoF, N1, N2, F, D, R, r, Q, error_, ok)
				}
				if filetype == 2 {
					// .m matlab format output
					write_static_mfile(OUT_file, title, nN, nE, nL, lc, DoF, N1, N2, F, D, R, r, Q, error_, ok)
				}
				//
				// *  if ( verbose )
				// *   printf("\n   If the program pauses here for very long,"
				// *   " hit CTRL-C to stop execution, \n"
				// *   "    reduce exagg_static in the Input Data,"
				// *   " and re-run the analysis. \n");
				//
				write_internal_forces(OUT_file, fp, infcpath, lc, nL, title, dx, xyz, Q, nN, nE, L, N1, N2, Ax, Asy, Asz, Jx, Iy, Iz, E, G, p, d, gX[lc], gY[lc], gZ[lc], nU[lc], U[lc], nW[lc], W[lc], nP[lc], P[lc], D, shear, error_)
				static_mesh(IN_file, infcpath, meshpath, plotpath, title, nN, nE, nL, lc, DoF, xyz, L, N1, N2, p, D, exagg_static, D3_flag, anlyz, dx, scale)
			}
		}
	} else {
		if verbose != 0 {
			// end load case loop
			//  data check only
			// display data check only
			noarch.Fprintf(noarch.Stdout, []byte("\n * %s *\n\x00"), title)
			noarch.Fprintf(noarch.Stdout, []byte("  DATA CHECK ONLY.\n\x00"))
		}
		static_mesh(IN_file, infcpath, meshpath, plotpath, title, nN, nE, nL, lc, DoF, xyz, L, N1, N2, p, D, exagg_static, D3_flag, anlyz, dx, scale)
	}
	if nM > 0 {
		if verbose&anlyz != 0 {
			// carry out modal analysis
			noarch.Fprintf(noarch.Stdout, []byte("\n\n Modal Analysis ...\n\x00"))
		}
		// Bathe
		if nM+8 < 2*nM {
			nM_calc = nM + 8
		} else {
			nM_calc = 2 * nM
		}
		M = dmatrix(1, DoF, 1, DoF)
		f = dvector(1, nM_calc)
		V = dmatrix(1, DoF, 1, nM_calc)
		assemble_M(M, DoF, nN, nE, xyz, rj, L, N1, N2, Ax, Jx, Iy, Iz, p, d, EMs, NMs, NMx, NMy, NMz, lump, debug)
		{
			//  compute traceK and traceM
			for j = 1; j <= DoF; j++ {
				if noarch.Not(r[j]) {
					traceK += K[j][j]
					traceM += M[j][j]
				}
			}
		}
		{
			//  modify K and M for reactions
			for i = 1; i <= DoF; i++ {
				if r[i] != 0 {
					// apply reactions to upper triangle
					K[i][i] = traceK*10000
					M[i][i] = traceM
					for j = i+1; j <= DoF; j++ {
						M[i][j] = 0
						M[j][i] = M[i][j]
						K[i][j] = M[j][i]
						K[j][i] = K[i][j]
					}
				}
			}
		}
		if write_matrix != 0 {
			// write Kd and Md matrices
			// dynamic stff matx
			save_ut_dmatrix([]byte("Kd\x00"), K, DoF, []byte("w\x00"))
			// dynamic mass matx
			save_ut_dmatrix([]byte("Md\x00"), M, DoF, []byte("w\x00"))
		}
		if anlyz != 0 {
			if Mmethod == 1 {
				// subspace or stodola methods
				subspace(K, M, DoF, nM_calc, f, V, tol, shift, c4goUnsafeConvert_int32(&iter), c4goUnsafeConvert_int32(&ok), verbose)
			}
			if Mmethod == 2 {
				stodola(K, M, DoF, nM_calc, f, V, tol, shift, c4goUnsafeConvert_int32(&iter), c4goUnsafeConvert_int32(&ok), verbose)
			}
			for j = 1; j <= nM_calc; j++ {
				f[j] = math.Sqrt(f[j])/(2*3.141592653589793)
			}
			write_modal_results(fp, nN, nE, nI, DoF, M, f, V, total_mass, struct_mass, iter, sumR, nM, shift, lump, tol, ok)
		}
	}
	noarch.Fprintf(fp, []byte("\f\n\x00"))
	noarch.Fclose(fp)
	if nM > 0 && anlyz != 0 {
		// write modal analysis results
		modal_mesh(IN_file, meshpath, modepath, plotpath, title, nN, nE, DoF, nM, xyz, L, N1, N2, p, M, f, V, exagg_modal, D3_flag, anlyz)
		animate(IN_file, meshpath, modepath, plotpath, title, anim, nN, nE, DoF, nM, xyz, L, p, N1, N2, f, V, exagg_modal, D3_flag, pan, scale)
	}
	if nC > 0 {
		if verbose != 0 {
			// matrix condensation of stiffness and mass
			noarch.Fprintf(noarch.Stdout, []byte("\n Matrix Condensation ...\n\x00"))
		}
		if Cdof > nM && Cmethod == 3 {
			noarch.Fprintf(noarch.Stderr, []byte("  Cdof > nM ... Cdof = %d  nM = %d \n\x00"), Cdof, nM)
			noarch.Fprintf(noarch.Stderr, []byte("  The number of condensed degrees of freedom\x00"))
			noarch.Fprintf(noarch.Stderr, []byte(" may not exceed the number of computed modes\x00"))
			noarch.Fprintf(noarch.Stderr, []byte(" when using dynamic condensation.\n\x00"))
			unix.Exit(94)
		}
		Kc = dmatrix(1, Cdof, 1, Cdof)
		Mc = dmatrix(1, Cdof, 1, Cdof)
		if m[1] > 0 && nM > 0 {
			Cfreq = f[m[1]]
		}
		if Cmethod == 1 && anlyz != 0 {
			// static condensation only
			static_condensation(K, DoF, c, Cdof, Kc, 0)
			if verbose != 0 {
				noarch.Fprintf(noarch.Stdout, []byte("   static condensation of K complete\n\x00"))
			}
		}
		if Cmethod == 2 && anlyz != 0 {
			//  dynamic condensation
			paz_condensation(M, K, DoF, c, Cdof, Mc, Kc, Cfreq, 0)
			if verbose != 0 {
				noarch.Fprintf(noarch.Stdout, []byte("   Paz condensation of K and M complete\x00"))
				noarch.Fprintf(noarch.Stdout, []byte(" ... dynamics matched at %f Hz.\n\x00"), Cfreq)
			}
		}
		if Cmethod == 3 && nM > 0 && anlyz != 0 {
			modal_condensation(M, K, DoF, r, c, Cdof, Mc, Kc, V, f, m, 0)
			if verbose != 0 {
				noarch.Fprintf(noarch.Stdout, []byte("   modal condensation of K and M complete\n\x00"))
			}
		}
		save_dmatrix([]byte("Kc\x00"), Kc, 1, Cdof, 1, Cdof, 0, []byte("w\x00"))
		save_dmatrix([]byte("Mc\x00"), Mc, 1, Cdof, 1, Cdof, 0, []byte("w\x00"))
		free_dmatrix(Kc, 1, Cdof, 1, Cdof)
		free_dmatrix(Mc, 1, Cdof, 1, Cdof)
	}
	// deallocate memory used for each frame analysis variable
	deallocate(nN, nE, nL, nF, nU, nW, nP, nT, DoF, nM, xyz, rj, L, Le, N1, N2, q, r, Ax, Asy, Asz, Jx, Iy, Iz, E, G, p, U, W, P, T, Dp, F_mech, F_temp, eqF_mech, eqF_temp, F, dF, K, Q, D, dD, R, dR, d, EMs, NMs, NMx, NMy, NMz, M, f, V, c, m, pkNx, pkVy, pkVz, pkTx, pkMy, pkMz, pkDx, pkDy, pkDz, pkRx, pkSy, pkSz)
	if verbose != 0 {
		noarch.Fprintf(noarch.Stdout, []byte("\n\x00"))
	}
	if argc == 1 {
		// wait for keyboard entry to close the terminal
		noarch.Fprintf(noarch.Stderr, []byte(" The Output Data was appended to %s \n\x00"), OUT_file)
		noarch.Fprintf(noarch.Stderr, []byte(" A Gnuplot script was written to %s \n\x00"), plotpath)
		noarch.Fprintf(noarch.Stderr, []byte(" Press the 'Enter' key to close.\n\x00"))
		// clear the buffer ??
		_ = noarch.Getchar()
		// wait for the Enter key to be hit
		for noarch.Not(noarch.Getchar()) {
		}
	}
	color(0)
	noarch.Exit(int32(ExitCode))
}
// assemble_K - transpiled function from  GOPATH/History_frame3DD/src/frame3dd.c:87
func assemble_K(K [][]float64, DoF int32, nE int32, xyz []vec3, r []float32, L []float64, Le []float64, N1 []int32, N2 []int32, Ax []float32, Asy []float32, Asz []float32, Jx []float32, Iy []float32, Iz []float32, E []float32, G []float32, p []float32, shear int32, geom int32, Q [][]float64, debug int32) {
	//
	// This file is part of FRAME3DD:
	// Static and dynamic structural analysis of 2D and 3D frames and trusses with
	// elastic and geometric stiffness.
	// ---------------------------------------------------------------------------
	// http://frame3dd.sourceforge.net/
	// ---------------------------------------------------------------------------
	// Copyright (C) 1992-2014  Henri P. Gavin
	//
	//    FRAME3DD is free software: you can redistribute it and/or modify
	//    it under the terms of the GNU General Public License as published by
	//    the Free Software Foundation, either version 3 of the License, or
	//    (at your option) any later version.
	//
	//    FRAME3DD is distributed in the hope that it will be useful,
	//    but WITHOUT ANY WARRANTY; without even the implied warranty of
	//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	//    GNU General Public License for more details.
	//
	//    You should have received a copy of the GNU General Public License
	//    along with FRAME3DD.  If not, see <http://www.gnu.org/licenses/>.
	//
	// NOTE main 'driver' routine is now moved to main.c
	// #define MATRIX_DEBUG
	// forward declarations
	//
	// * ASSEMBLE_K  -  assemble global stiffness matrix from individual elements 23feb94
	//
	// element stiffness matrix in global coord
	var k [][]float64
	// member-structure DoF index table
	var ind [][]int32
	var res int32
	var i int32
	var j int32
	var ii int32
	var jj int32
	var l int32
	var ll int32
	var stiffness_fn []byte = make([]byte, 128)
	for i = 1; i <= DoF; i++ {
		for j = 1; j <= DoF; j++ {
			K[i][j] = 0
		}
	}
	k = dmatrix(1, 12, 1, 12)
	ind = imatrix(1, 12, 1, nE)
	for i = 1; i <= nE; i++ {
		ind[1][i] = 6*N1[i]-5
		ind[7][i] = 6*N2[i]-5
		ind[2][i] = ind[1][i]+1
		ind[8][i] = ind[7][i]+1
		ind[3][i] = ind[1][i]+2
		ind[9][i] = ind[7][i]+2
		ind[4][i] = ind[1][i]+3
		ind[10][i] = ind[7][i]+3
		ind[5][i] = ind[1][i]+4
		ind[11][i] = ind[7][i]+4
		ind[6][i] = ind[1][i]+5
		ind[12][i] = ind[7][i]+5
	}
	for i = 1; i <= nE; i++ {
		elastic_K(k, xyz, r, L[i], Le[i], N1[i], N2[i], Ax[i], Asy[i], Asz[i], Jx[i], Iy[i], Iz[i], E[i], G[i], p[i], shear)
		if geom != 0 {
			geometric_K(k, xyz, r, L[i], Le[i], N1[i], N2[i], Ax[i], Asy[i], Asz[i], Jx[i], Iy[i], Iz[i], E[i], G[i], p[i], -Q[i][1], shear)
		}
		if debug != 0 {
			res = noarch.Sprintf(stiffness_fn, []byte("k_%03d\x00"), i)
			save_dmatrix(stiffness_fn, k, 1, 12, 1, 12, 0, []byte("w\x00"))
		}
		for l = 1; l <= 12; l++ {
			ii = ind[l][i]
			for ll = 1; ll <= 12; ll++ {
				jj = ind[ll][i]
				K[ii][jj] += k[l][ll]
			}
		}
	}
	free_dmatrix(k, 1, 12, 1, 12)
	free_imatrix(ind, 1, 12, 1, nE)
}
// elastic_K - transpiled function from  GOPATH/History_frame3DD/src/frame3dd.c:151
func elastic_K(k [][]float64, xyz []vec3, r []float32, L float64, Le float64, n1 int32, n2 int32, Ax float32, Asy float32, Asz float32, J float32, Iy float32, Iz float32, E float32, G float32, p float32, shear int32) {
	//
	// * ELASTIC_K - space frame elastic stiffness matrix in global coordnates 22oct02
	//
	// coord Xformn
	var t1 float64
	var t2 float64
	var t3 float64
	var t4 float64
	var t5 float64
	var t6 float64
	var t7 float64
	var t8 float64
	var t9 float64
	var Ksy float64
	var Ksz float64
	// shear deformatn coefficients
	var i int32
	var j int32
	coord_trans(xyz, L, n1, n2, c4goUnsafeConvert_float64(&t1), c4goUnsafeConvert_float64(&t2), c4goUnsafeConvert_float64(&t3), c4goUnsafeConvert_float64(&t4), c4goUnsafeConvert_float64(&t5), c4goUnsafeConvert_float64(&t6), c4goUnsafeConvert_float64(&t7), c4goUnsafeConvert_float64(&t8), c4goUnsafeConvert_float64(&t9), p)
	for i = 1; i <= 12; i++ {
		for j = 1; j <= 12; j++ {
			k[i][j] = 0
		}
	}
	if shear != 0 {
		Ksy = 12*float64(E)*float64(Iz)/(float64(G*Asy)*Le*Le)
		Ksz = 12*float64(E)*float64(Iy)/(float64(G*Asz)*Le*Le)
	} else {
		Ksz = 0
		Ksy = Ksz
	}
	k[7][7] = float64(E*Ax)/Le
	k[1][1] = k[7][7]
	k[8][8] = 12*float64(E)*float64(Iz)/(Le*Le*Le*(1+Ksy))
	k[2][2] = k[8][8]
	k[9][9] = 12*float64(E)*float64(Iy)/(Le*Le*Le*(1+Ksz))
	k[3][3] = k[9][9]
	k[10][10] = float64(G*J)/Le
	k[4][4] = k[10][10]
	k[11][11] = (4+Ksz)*float64(E)*float64(Iy)/(Le*(1+Ksz))
	k[5][5] = k[11][11]
	k[12][12] = (4+Ksy)*float64(E)*float64(Iz)/(Le*(1+Ksy))
	k[6][6] = k[12][12]
	k[3][5] = -6*float64(E)*float64(Iy)/(Le*Le*(1+Ksz))
	k[5][3] = k[3][5]
	k[2][6] = 6*float64(E)*float64(Iz)/(Le*Le*(1+Ksy))
	k[6][2] = k[2][6]
	k[1][7] = -k[1][1]
	k[7][1] = k[1][7]
	k[6][8] = -k[6][2]
	k[8][6] = k[6][8]
	k[8][12] = k[8][6]
	k[12][8] = k[8][12]
	k[5][9] = -k[5][3]
	k[9][5] = k[5][9]
	k[9][11] = k[9][5]
	k[11][9] = k[9][11]
	k[4][10] = -k[4][4]
	k[10][4] = k[4][10]
	k[3][11] = k[5][3]
	k[11][3] = k[3][11]
	k[2][12] = k[6][2]
	k[12][2] = k[2][12]
	k[2][8] = -k[2][2]
	k[8][2] = k[2][8]
	k[3][9] = -k[3][3]
	k[9][3] = k[3][9]
	k[5][11] = (2-Ksz)*float64(E)*float64(Iy)/(Le*(1+Ksz))
	k[11][5] = k[5][11]
	k[6][12] = (2-Ksy)*float64(E)*float64(Iz)/(Le*(1+Ksy))
	k[12][6] = k[6][12]
	// globalize
	atma(t1, t2, t3, t4, t5, t6, t7, t8, t9, k, r[n1], r[n2])
	{
		// check and enforce symmetry of elastic element stiffness matrix
		for i = 1; i <= 12; i++ {
			for j = i+1; j <= 12; j++ {
				if k[i][j] != k[j][i] {
					if math.Abs(k[i][j]/k[j][i]-1) > 1e-06 && (math.Abs(k[i][j]/k[i][i]) > 1e-06 || math.Abs(k[j][i]/k[i][i]) > 1e-06) {
						noarch.Fprintf(noarch.Stderr, []byte("elastic_K: element stiffness matrix not symetric ...\n\x00"))
						noarch.Fprintf(noarch.Stderr, []byte(" ... k[%d][%d] = %15.6e \n\x00"), i, j, k[i][j])
						noarch.Fprintf(noarch.Stderr, []byte(" ... k[%d][%d] = %15.6e   \x00"), j, i, k[j][i])
						noarch.Fprintf(noarch.Stderr, []byte(" ... relative error = %e \n\x00"), math.Abs(k[i][j]/k[j][i]-1))
						noarch.Fprintf(noarch.Stderr, []byte(" ... element matrix saved in file 'kt'\n\x00"))
						save_dmatrix([]byte("kt\x00"), k, 1, 12, 1, 12, 0, []byte("w\x00"))
					}
					k[j][i] = 0.5*(k[i][j]+k[j][i])
					k[i][j] = k[j][i]
				}
			}
		}
	}
}
// geometric_K - transpiled function from  GOPATH/History_frame3DD/src/frame3dd.c:232
func geometric_K(k [][]float64, xyz []vec3, r []float32, L float64, Le float64, n1 int32, n2 int32, Ax float32, Asy float32, Asz float32, J float32, Iy float32, Iz float32, E float32, G float32, p float32, T float64, shear int32) {
	//
	// * GEOMETRIC_K - space frame geometric stiffness matrix, global coordnates 20dec07
	//
	// coord Xformn
	var t1 float64
	var t2 float64
	var t3 float64
	var t4 float64
	var t5 float64
	var t6 float64
	var t7 float64
	var t8 float64
	var t9 float64
	var kg [][]float64
	// shear deformation coefficients
	var Ksy float64
	var Ksz float64
	var Dsy float64
	var Dsz float64
	var i int32
	var j int32
	coord_trans(xyz, L, n1, n2, c4goUnsafeConvert_float64(&t1), c4goUnsafeConvert_float64(&t2), c4goUnsafeConvert_float64(&t3), c4goUnsafeConvert_float64(&t4), c4goUnsafeConvert_float64(&t5), c4goUnsafeConvert_float64(&t6), c4goUnsafeConvert_float64(&t7), c4goUnsafeConvert_float64(&t8), c4goUnsafeConvert_float64(&t9), p)
	kg = dmatrix(1, 12, 1, 12)
	for i = 1; i <= 12; i++ {
		for j = 1; j <= 12; j++ {
			kg[i][j] = 0
		}
	}
	if shear != 0 {
		Ksy = 12*float64(E)*float64(Iz)/(float64(G*Asy)*Le*Le)
		Ksz = 12*float64(E)*float64(Iy)/(float64(G*Asz)*Le*Le)
		Dsy = (1+Ksy)*(1+Ksy)
		Dsz = (1+Ksz)*(1+Ksz)
	} else {
		Ksz = 0
		Ksy = Ksz
		Dsz = 1
		Dsy = Dsz
	}
	kg[7][7] = 0
	// T/L;
	kg[1][1] = kg[7][7]
	kg[8][8] = T/L*(1.2+2*Ksy+Ksy*Ksy)/Dsy
	kg[2][2] = kg[8][8]
	kg[9][9] = T/L*(1.2+2*Ksz+Ksz*Ksz)/Dsz
	kg[3][3] = kg[9][9]
	kg[10][10] = T/L*float64(J)/float64(Ax)
	kg[4][4] = kg[10][10]
	kg[11][11] = T*L*(2/15+Ksz/6+Ksz*Ksz/12)/Dsz
	kg[5][5] = kg[11][11]
	kg[12][12] = T*L*(2/15+Ksy/6+Ksy*Ksy/12)/Dsy
	kg[6][6] = kg[12][12]
	kg[7][1] = 0
	// -T/L;
	kg[1][7] = kg[7][1]
	kg[3][11] = -T/10/Dsz
	kg[11][3] = kg[3][11]
	kg[3][5] = kg[11][3]
	kg[5][3] = kg[3][5]
	kg[9][11] = T/10/Dsz
	kg[11][9] = kg[9][11]
	kg[5][9] = kg[11][9]
	kg[9][5] = kg[5][9]
	kg[2][12] = T/10/Dsy
	kg[12][2] = kg[2][12]
	kg[2][6] = kg[12][2]
	kg[6][2] = kg[2][6]
	kg[8][12] = -T/10/Dsy
	kg[12][8] = kg[8][12]
	kg[6][8] = kg[12][8]
	kg[8][6] = kg[6][8]
	kg[10][4] = -kg[4][4]
	kg[4][10] = kg[10][4]
	kg[2][8] = -T/L*(1.2+2*Ksy+Ksy*Ksy)/Dsy
	kg[8][2] = kg[2][8]
	kg[3][9] = -T/L*(1.2+2*Ksz+Ksz*Ksz)/Dsz
	kg[9][3] = kg[3][9]
	kg[5][11] = -T*L*(1/30+Ksz/6+Ksz*Ksz/12)/Dsz
	kg[11][5] = kg[5][11]
	kg[6][12] = -T*L*(1/30+Ksy/6+Ksy*Ksy/12)/Dsy
	kg[12][6] = kg[6][12]
	// globalize
	atma(t1, t2, t3, t4, t5, t6, t7, t8, t9, kg, r[n1], r[n2])
	{
		// check and enforce symmetry of geometric element stiffness matrix
		for i = 1; i <= 12; i++ {
			for j = i+1; j <= 12; j++ {
				if kg[i][j] != kg[j][i] {
					if math.Abs(kg[i][j]/kg[j][i]-1) > 1e-06 && (math.Abs(kg[i][j]/kg[i][i]) > 1e-06 || math.Abs(kg[j][i]/kg[i][i]) > 1e-06) {
						noarch.Fprintf(noarch.Stderr, []byte("geometric_K element stiffness matrix not symetric ...\n\x00"))
						noarch.Fprintf(noarch.Stderr, []byte(" ... kg[%d][%d] = %15.6e \n\x00"), i, j, kg[i][j])
						noarch.Fprintf(noarch.Stderr, []byte(" ... kg[%d][%d] = %15.6e   \x00"), j, i, kg[j][i])
						noarch.Fprintf(noarch.Stderr, []byte(" ... relative error = %e \n\x00"), math.Abs(kg[i][j]/kg[j][i]-1))
						noarch.Fprintf(noarch.Stderr, []byte(" ... element matrix saved in file 'kg'\n\x00"))
						save_dmatrix([]byte("kg\x00"), kg, 1, 12, 1, 12, 0, []byte("w\x00"))
					}
					kg[j][i] = 0.5*(kg[i][j]+kg[j][i])
					kg[i][j] = kg[j][i]
				}
			}
		}
	}
	{
		// add geometric stiffness matrix to elastic stiffness matrix ...
		for i = 1; i <= 12; i++ {
			for j = 1; j <= 12; j++ {
				k[i][j] += kg[i][j]
			}
		}
	}
	free_dmatrix(kg, 1, 12, 1, 12)
}
// solve_system - transpiled function from  GOPATH/History_frame3DD/src/frame3dd.c:352
func solve_system(K [][]float64, D []float64, F []float64, R []float64, DoF int32, q []int32, r []int32, ok []int32, verbose int32, rms_resid []float64) {
	//
	// * SOLVE_SYSTEM  -  solve {F} =   [K]{D} via L D L' decomposition        27dec01
	// * Prescribed displacements are "mechanical loads" not "temperature loads"
	//
	// diagonal vector of the L D L' decomp.
	var diag []float64
	// suppress verbose output
	verbose = 0
	diag = dvector(1, DoF)
	//  L D L' decomposition of K[q,q] into lower triangle of K[q,q] and diag[q]
	//  vectors F and D are unchanged
	ldl_dcmp_pm(K, DoF, diag, F, D, R, q, r, 1, 0, ok)
	if ok[0] < 0 {
		noarch.Fprintf(noarch.Stderr, []byte(" Make sure that all six\x00"))
		noarch.Fprintf(noarch.Stderr, []byte(" rigid body translations are restrained!\n\x00"))
	} else {
		// exit(31);
		// LDL'  back-substitution for D[q] and R[r]
		ldl_dcmp_pm(K, DoF, diag, F, D, R, q, r, 0, 1, ok)
		if verbose != 0 {
			noarch.Fprintf(noarch.Stdout, []byte("    LDL' RMS residual:\x00"))
		}
		ok[0] = 1
		rms_resid[0] = float64(ok[0])
		for {
			// improve solution for D[q] and R[r]
			ldl_mprove_pm(K, DoF, diag, F, D, R, q, r, rms_resid, ok)
			if verbose != 0 {
				noarch.Fprintf(noarch.Stdout, []byte("%9.2e\x00"), rms_resid[0])
			}
			if noarch.Not(ok[0]) {
				break
			}
		}
		if verbose != 0 {
			noarch.Fprintf(noarch.Stdout, []byte("\n\x00"))
		}
	}
	free_dvector(diag, 1, DoF)
}
// equilibrium_error - transpiled function from  GOPATH/History_frame3DD/src/frame3dd.c:390
func equilibrium_error(dF []float64, F []float64, K [][]float64, D []float64, DoF int32, q []int32, r []int32) float64 {
	//
	// * EQUILIBRIUM_ERROR -  compute {dF_q} =   {F_q} - [K_qq]{D_q} - [K_qr]{D_r}
	// * use only the upper-triangle of [K_qq]
	// * return ||dF||/||F||
	// * 2014-05-16
	//
	//  sum of squares of dF
	var ss_dF float64
	var ss_F float64
	var errF float64
	//  sum of squares of F
	var i int32
	var j int32
	{
		// compute equilibrium error at free coord's (q)
		for i = 1; i <= DoF; i++ {
			errF = 0
			if q[i] != 0 {
				errF = F[i]
				for j = 1; j <= DoF; j++ {
					if q[j] != 0 {
						if i <= j {
							// K_qq in upper triangle only
							errF -= K[i][j]*D[j]
						} else {
							errF -= K[j][i]*D[j]
						}
					}
				}
				for j = 1; j <= DoF; j++ {
					if r[j] != 0 {
						errF -= K[i][j]*D[j]
					}
				}
			}
			dF[i] = errF
		}
	}
	for i = 1; i <= DoF; i++ {
		if q[i] != 0 {
			ss_dF += dF[i]*dF[i]
		}
	}
	for i = 1; i <= DoF; i++ {
		if q[i] != 0 {
			ss_F += F[i]*F[i]
		}
	}
	// convergence criterion
	return math.Sqrt(ss_dF) / math.Sqrt(ss_F)
}
// element_end_forces - transpiled function from  GOPATH/History_frame3DD/src/frame3dd.c:425
func element_end_forces(Q [][]float64, nE int32, xyz []vec3, L []float64, Le []float64, N1 []int32, N2 []int32, Ax []float32, Asy []float32, Asz []float32, Jx []float32, Iy []float32, Iz []float32, E []float32, G []float32, p []float32, eqF_temp [][]float64, eqF_mech [][]float64, D []float64, shear int32, geom int32, axial_strain_warning []int32) {
	//
	// * ELEMENT_END_FORCES  -  evaluate the end forces for all elements
	// * 23feb94
	//
	// equivalent element end forces from temp loads
	// equivalent element end forces from mech loads
	var s []float64
	var axial_strain float64
	var m int32
	var j int32
	s = dvector(1, 12)
	axial_strain_warning[0] = 0
	for m = 1; m <= nE; m++ {
		frame_element_force(s, xyz, L[m], Le[m], N1[m], N2[m], Ax[m], Asy[m], Asz[m], Jx[m], Iy[m], Iz[m], E[m], G[m], p[m], eqF_temp[m], eqF_mech[m], D, shear, geom, c4goUnsafeConvert_float64(&axial_strain))
		for j = 1; j <= 12; j++ {
			Q[m][j] = s[j]
		}
		if math.Abs(axial_strain) > 0.001 {
			noarch.Fprintf(noarch.Stderr, []byte(" Warning! Frame element %2d has an average axial strain of %8.6f\n\x00"), m, axial_strain)
			axial_strain_warning[0] ++
		}
	}
	free_dvector(s, 1, 12)
}
// frame_element_force - transpiled function from  GOPATH/History_frame3DD/src/frame3dd.c:464
func frame_element_force(s []float64, xyz []vec3, L float64, Le float64, n1 int32, n2 int32, Ax float32, Asy float32, Asz float32, J float32, Iy float32, Iz float32, E float32, G float32, p float32, f_t []float64, f_m []float64, D []float64, shear int32, geom int32, axial_strain []float64) {
	//
	// * FRAME_ELEMENT_FORCE  -  evaluate the end forces in local coord's
	// * 12nov02
	//
	// coord Xformn
	var t1 float64
	var t2 float64
	var t3 float64
	var t4 float64
	var t5 float64
	var t6 float64
	var t7 float64
	var t8 float64
	var t9 float64
	var d1 float64
	var d2 float64
	var d3 float64
	var d4 float64
	var d5 float64
	var d6 float64
	var d7 float64
	var d8 float64
	var d9 float64
	var d10 float64
	var d11 float64
	var d12 float64
	var delta float64
	var Ksy float64
	var Ksz float64
	var Dsy float64
	var Dsz float64
	var T float64
	// x1, y1, z1, x2, y2, z2, /* node coordinates */
	//  Ls,                                         /* stretched length of element */
	// stretch in the frame element
	// shear deformation coeff's
	// axial force for geometric stiffness
	var f1 float64
	var f2 float64
	var f3 float64
	var f4 float64
	var f5 float64
	var f6 float64
	var f7 float64
	var f8 float64
	var f9 float64
	var f10 float64
	var f11 float64
	var f12 float64
	coord_trans(xyz, L, n1, n2, c4goUnsafeConvert_float64(&t1), c4goUnsafeConvert_float64(&t2), c4goUnsafeConvert_float64(&t3), c4goUnsafeConvert_float64(&t4), c4goUnsafeConvert_float64(&t5), c4goUnsafeConvert_float64(&t6), c4goUnsafeConvert_float64(&t7), c4goUnsafeConvert_float64(&t8), c4goUnsafeConvert_float64(&t9), p)
	n1 = 6*(n1-1)
	n2 = 6*(n2-1)
	d1 = D[n1+1]
	d2 = D[n1+2]
	d3 = D[n1+3]
	d4 = D[n1+4]
	d5 = D[n1+5]
	d6 = D[n1+6]
	d7 = D[n2+1]
	d8 = D[n2+2]
	d9 = D[n2+3]
	d10 = D[n2+4]
	d11 = D[n2+5]
	d12 = D[n2+6]
	if shear != 0 {
		Ksy = 12*float64(E)*float64(Iz)/(float64(G*Asy)*Le*Le)
		Ksz = 12*float64(E)*float64(Iy)/(float64(G*Asz)*Le*Le)
		Dsy = (1+Ksy)*(1+Ksy)
		Dsz = (1+Ksz)*(1+Ksz)
	} else {
		Ksz = 0
		Ksy = Ksz
		Dsz = 1
		Dsy = Dsz
	}
	// finite strain ... (not consistent with 2nd order formulation)
	//
	// * delta += ( pow(((d7-d1)*t4 + (d8-d2)*t5 + (d9-d3)*t6),2.0) +
	// *     pow(((d7-d1)*t7 + (d8-d2)*t8 + (d9-d3)*t9),2.0) )/(2.0*L);
	//
	// true strain ... (not appropriate for structural materials)
	//
	// * x1 = xyz[n1].x; y1 = xyz[n1].y; z1 = xyz[n1].z;
	// * x2 = xyz[n2].x; y2 = xyz[n2].y; z2 = xyz[n2].z;
	// *
	// *   Ls = pow((x2+d7-x1-d1),2.0) +
	// *        pow((y2+d8-y1-d2),2.0) +
	// *        pow((z2+d9-z1-d3),2.0);
	// *   Ls = sqrt(Ls) + Le - L;
	// *
	// * delta = Le*log(Ls/Le);
	//
	// axial element displacement ...
	delta = (d7-d1)*t1+(d8-d2)*t2+(d9-d3)*t3
	// log(Ls/Le);
	axial_strain[0] = delta/Le
	s[1] = -(float64(Ax*E)/Le)*((d7-d1)*t1+(d8-d2)*t2+(d9-d3)*t3)
	if geom != 0 {
		T = -s[1]
	}
	s[2] = -(12*float64(E)*float64(Iz)/(Le*Le*Le*(1+Ksy))+T/L*(1.2+2*Ksy+Ksy*Ksy)/Dsy)*((d7-d1)*t4+(d8-d2)*t5+(d9-d3)*t6)+(6*float64(E)*float64(Iz)/(Le*Le*(1+Ksy))+T/10/Dsy)*((d4+d10)*t7+(d5+d11)*t8+(d6+d12)*t9)
	s[3] = -(12*float64(E)*float64(Iy)/(Le*Le*Le*(1+Ksz))+T/L*(1.2+2*Ksz+Ksz*Ksz)/Dsz)*((d7-d1)*t7+(d8-d2)*t8+(d9-d3)*t9)-(6*float64(E)*float64(Iy)/(Le*Le*(1+Ksz))+T/10/Dsz)*((d4+d10)*t4+(d5+d11)*t5+(d6+d12)*t6)
	s[4] = -(float64(G*J)/Le)*((d10-d4)*t1+(d11-d5)*t2+(d12-d6)*t3)
	s[5] = (6*float64(E)*float64(Iy)/(Le*Le*(1+Ksz))+T/10/Dsz)*((d7-d1)*t7+(d8-d2)*t8+(d9-d3)*t9)+((4+Ksz)*float64(E)*float64(Iy)/(Le*(1+Ksz))+T*L*(2/15+Ksz/6+Ksz*Ksz/12)/Dsz)*(d4*t4+d5*t5+d6*t6)+((2-Ksz)*float64(E)*float64(Iy)/(Le*(1+Ksz))-T*L*(1/30+Ksz/6+Ksz*Ksz/12)/Dsz)*(d10*t4+d11*t5+d12*t6)
	s[6] = -(6*float64(E)*float64(Iz)/(Le*Le*(1+Ksy))+T/10/Dsy)*((d7-d1)*t4+(d8-d2)*t5+(d9-d3)*t6)+((4+Ksy)*float64(E)*float64(Iz)/(Le*(1+Ksy))+T*L*(2/15+Ksy/6+Ksy*Ksy/12)/Dsy)*(d4*t7+d5*t8+d6*t9)+((2-Ksy)*float64(E)*float64(Iz)/(Le*(1+Ksy))-T*L*(1/30+Ksy/6+Ksy*Ksy/12)/Dsy)*(d10*t7+d11*t8+d12*t9)
	s[7] = -s[1]
	s[8] = -s[2]
	s[9] = -s[3]
	s[10] = -s[4]
	s[11] = (6*float64(E)*float64(Iy)/(Le*Le*(1+Ksz))+T/10/Dsz)*((d7-d1)*t7+(d8-d2)*t8+(d9-d3)*t9)+((4+Ksz)*float64(E)*float64(Iy)/(Le*(1+Ksz))+T*L*(2/15+Ksz/6+Ksz*Ksz/12)/Dsz)*(d10*t4+d11*t5+d12*t6)+((2-Ksz)*float64(E)*float64(Iy)/(Le*(1+Ksz))-T*L*(1/30+Ksz/6+Ksz*Ksz/12)/Dsz)*(d4*t4+d5*t5+d6*t6)
	s[12] = -(6*float64(E)*float64(Iz)/(Le*Le*(1+Ksy))+T/10/Dsy)*((d7-d1)*t4+(d8-d2)*t5+(d9-d3)*t6)+((4+Ksy)*float64(E)*float64(Iz)/(Le*(1+Ksy))+T*L*(2/15+Ksy/6+Ksy*Ksy/12)/Dsy)*(d10*t7+d11*t8+d12*t9)+((2-Ksy)*float64(E)*float64(Iz)/(Le*(1+Ksy))-T*L*(1/30+Ksy/6+Ksy*Ksy/12)/Dsy)*(d4*t7+d5*t8+d6*t9)
	// add fixed end forces to internal element forces
	// 18oct2012, 14may1204, 15may2014
	// add temperature fixed-end-forces to variables f1-f12
	// add mechanical load fixed-end-forces to variables f1-f12
	// f1 ...  f12 are in the global element coordinate system
	f1 = f_t[1]+f_m[1]
	f2 = f_t[2]+f_m[2]
	f3 = f_t[3]+f_m[3]
	f4 = f_t[4]+f_m[4]
	f5 = f_t[5]+f_m[5]
	f6 = f_t[6]+f_m[6]
	f7 = f_t[7]+f_m[7]
	f8 = f_t[8]+f_m[8]
	f9 = f_t[9]+f_m[9]
	f10 = f_t[10]+f_m[10]
	f11 = f_t[11]+f_m[11]
	f12 = f_t[12]+f_m[12]
	// transform f1 ... f12 to local element coordinate system and
	// add local fixed end forces (-equivalent loads) to internal loads
	// {Q} = [T]{f}
	s[1] -= f1*t1+f2*t2+f3*t3
	s[2] -= f1*t4+f2*t5+f3*t6
	s[3] -= f1*t7+f2*t8+f3*t9
	s[4] -= f4*t1+f5*t2+f6*t3
	s[5] -= f4*t4+f5*t5+f6*t6
	s[6] -= f4*t7+f5*t8+f6*t9
	s[7] -= f7*t1+f8*t2+f9*t3
	s[8] -= f7*t4+f8*t5+f9*t6
	s[9] -= f7*t7+f8*t8+f9*t9
	s[10] -= f10*t1+f11*t2+f12*t3
	s[11] -= f10*t4+f11*t5+f12*t6
	s[12] -= f10*t7+f11*t8+f12*t9
}
// compute_reaction_forces - transpiled function from  GOPATH/History_frame3DD/src/frame3dd.c:658
func compute_reaction_forces(R []float64, F []float64, K [][]float64, D []float64, DoF int32, r []int32) {
	//
	//void add_feF(  // DISUSED CODE
	//              vec3 *xyz,
	//              double *L, int *N1, int *N2, float *p,
	//              double **Q,
	//int nE, int DoF,
	// int verbose
	//){
	// double  t1, t2, t3, t4, t5, t6, t7, t8, t9, // 3D coord Xformn
	// int                                         m, n1, n2, i1, i2; //, J, x;
	//
	// for (m=1; m <= nE; m++) { // loop over all frame elements
	//
	//  n1 = N1[m]; n2 = N2[m];
	//
	// * reaction calculations removed from Frame3DD on 2014-05-14 ...
	// * these calculations are now in solve_system()
	// *  // add fixed-end forces to reaction forces
	// *  for (i=1; i<=6; i++) {
	// *   i1 = 6*(n1-1) + i;
	// *   if (r[i1])
	// *    F[i1] -= ( f_t[m][i] + f_m[m][i] );
	// *  }
	// *  for (i=1; i<=6; i++) {
	// *   i2 = 6*(n2-1) + i;
	// *   if (r[i2])
	// *    F[i2] -= ( f_t[m][i+6] + f_m[m][i+6] );
	// *  }
	// *
	//
	//  coord_trans ( xyz, L[m], n1, n2,
	//   &t1, &t2, &t3, &t4, &t5, &t6, &t7, &t8, &t9, p[m] );
	//
	//  // n1 = 6*(n1-1); n2 = 6*(n2-1); // ??
	//
	//
	// }
	//}
	//
	//
	// * COMPUTE_REACTION_FORCES : R(r) = [K(r,q)]*{D(q)} + [K(r,r)]*{D(r)} - F(r)
	// * reaction forces satisfy equilibrium in the solved system
	// * only really needed for geometric-nonlinear problems
	// * 2012-10-12  , 2014-05-16
	//
	var i int32
	var j int32
	for i = 1; i <= DoF; i++ {
		R[i] = 0
		if r[i] != 0 {
			// coordinate "i" is a reaction coord.
			// negative of equiv loads at coord i
			R[i] = -F[i]
			{
				// reactions are relaxed through system deformations
				for j = 1; j <= DoF; j++ {
					R[i] += K[i][j]*D[j]
				}
			}
		}
	}
}
// assemble_M - transpiled function from  GOPATH/History_frame3DD/src/frame3dd.c:677
func assemble_M(M [][]float64, DoF int32, nN int32, nE int32, xyz []vec3, r []float32, L []float64, N1 []int32, N2 []int32, Ax []float32, Jx []float32, Iy []float32, Iz []float32, p []float32, d []float32, EMs []float32, NMs []float32, NMx []float32, NMy []float32, NMz []float32, lump int32, debug int32) {
	//
	// * ASSEMBLE_M  -  assemble global mass matrix from element mass & inertia  24nov98
	//
	// element mass matrix in global coord
	var m [][]float64// ind - transpiled function from  GOPATH/History_frame3DD/src/frame3dd.c:688
	// member-structure DoF index table
	var ind [][]int32// res - transpiled function from  GOPATH/History_frame3DD/src/frame3dd.c:688
	var res int32// i - transpiled function from  GOPATH/History_frame3DD/src/frame3dd.c:688
	var i int32// j - transpiled function from  GOPATH/History_frame3DD/src/frame3dd.c:688
	var j int32// ii - transpiled function from  GOPATH/History_frame3DD/src/frame3dd.c:688
	var ii int32// jj - transpiled function from  GOPATH/History_frame3DD/src/frame3dd.c:688
	var jj int32// l - transpiled function from  GOPATH/History_frame3DD/src/frame3dd.c:688
	var l int32// ll - transpiled function from  GOPATH/History_frame3DD/src/frame3dd.c:688
	var ll int32// mass_fn - transpiled function from  GOPATH/History_frame3DD/src/frame3dd.c:692
	var mass_fn []byte = make([]byte, 128)
	for i = 1; i <= DoF; i++ {
		for j = 1; j <= DoF; j++ {
			M[i][j] = 0
		}
	}
	m = dmatrix(1, 12, 1, 12)
	ind = imatrix(1, 12, 1, nE)
	for i = 1; i <= nE; i++ {
		ind[1][i] = 6*N1[i]-5
		ind[7][i] = 6*N2[i]-5
		ind[2][i] = ind[1][i]+1
		ind[8][i] = ind[7][i]+1
		ind[3][i] = ind[1][i]+2
		ind[9][i] = ind[7][i]+2
		ind[4][i] = ind[1][i]+3
		ind[10][i] = ind[7][i]+3
		ind[5][i] = ind[1][i]+4
		ind[11][i] = ind[7][i]+4
		ind[6][i] = ind[1][i]+5
		ind[12][i] = ind[7][i]+5
	}
	for i = 1; i <= nE; i++ {
		if lump != 0 {
			lumped_M(m, xyz, L[i], N1[i], N2[i], Ax[i], Jx[i], Iy[i], Iz[i], p[i], d[i], EMs[i])
		} else {
			consistent_M(m, xyz, r, L[i], N1[i], N2[i], Ax[i], Jx[i], Iy[i], Iz[i], p[i], d[i], EMs[i])
		}
		if debug != 0 {
			res = noarch.Sprintf(mass_fn, []byte("m_%03d\x00"), i)
			save_dmatrix(mass_fn, m, 1, 12, 1, 12, 0, []byte("w\x00"))
		}
		for l = 1; l <= 12; l++ {
			ii = ind[l][i]
			for ll = 1; ll <= 12; ll++ {
				jj = ind[ll][i]
				M[ii][jj] += m[l][ll]
			}
		}
	}
	{
		// add extra node mass
		for j = 1; j <= nN; j++ {
			i = 6*(j-1)
			M[i+1][i+1] += float64(NMs[j])
			M[i+2][i+2] += float64(NMs[j])
			M[i+3][i+3] += float64(NMs[j])
			M[i+4][i+4] += float64(NMx[j])
			M[i+5][i+5] += float64(NMy[j])
			M[i+6][i+6] += float64(NMz[j])
		}
	}
	for i = 1; i <= DoF; i++ {
		if M[i][i] <= 0 {
			noarch.Fprintf(noarch.Stderr, []byte("  error: Non pos-def mass matrix\n\x00"))
			noarch.Fprintf(noarch.Stderr, []byte("  M[%d][%d] = %f\n\x00\x00"), i, i, M[i][i])
		}
	}
	free_dmatrix(m, 1, 12, 1, 12)
	free_imatrix(ind, 1, 12, 1, nE)
}
// lumped_M - transpiled function from  GOPATH/History_frame3DD/src/frame3dd.c:754
func lumped_M(m [][]float64, xyz []vec3, L float64, n1 int32, n2 int32, Ax float32, J float32, Iy float32, Iz float32, p float32, d float32, EMs float32) {
	//
	// * LUMPED_M  -  space frame element lumped mass matrix in global coordnates 7apr94
	//
	// coord Xformn
	var t1 float64
	var t2 float64
	var t3 float64
	var t4 float64
	var t5 float64
	var t6 float64
	var t7 float64
	var t8 float64
	var t9 float64
	var t float64
	var ry float64
	var rz float64
	var po float64
	// translational, rotational & polar inertia
	var i int32
	var j int32
	coord_trans(xyz, L, n1, n2, c4goUnsafeConvert_float64(&t1), c4goUnsafeConvert_float64(&t2), c4goUnsafeConvert_float64(&t3), c4goUnsafeConvert_float64(&t4), c4goUnsafeConvert_float64(&t5), c4goUnsafeConvert_float64(&t6), c4goUnsafeConvert_float64(&t7), c4goUnsafeConvert_float64(&t8), c4goUnsafeConvert_float64(&t9), p)
	// rotatory inertia of extra mass is neglected
	t = (float64(d*Ax)*L+float64(EMs))/2
	ry = float64(d*Iy)*L/2
	rz = float64(d*Iz)*L/2
	// assumes simple cross-section
	po = float64(d)*L*float64(J)/2
	for i = 1; i <= 12; i++ {
		for j = 1; j <= 12; j++ {
			m[i][j] = 0
		}
	}
	m[9][9] = t
	m[8][8] = m[9][9]
	m[7][7] = m[8][8]
	m[3][3] = m[7][7]
	m[2][2] = m[3][3]
	m[1][1] = m[2][2]
	m[10][10] = po*t1*t1+ry*t4*t4+rz*t7*t7
	m[4][4] = m[10][10]
	m[11][11] = po*t2*t2+ry*t5*t5+rz*t8*t8
	m[5][5] = m[11][11]
	m[12][12] = po*t3*t3+ry*t6*t6+rz*t9*t9
	m[6][6] = m[12][12]
	m[11][10] = po*t1*t2+ry*t4*t5+rz*t7*t8
	m[10][11] = m[11][10]
	m[5][4] = m[10][11]
	m[4][5] = m[5][4]
	m[12][10] = po*t1*t3+ry*t4*t6+rz*t7*t9
	m[10][12] = m[12][10]
	m[6][4] = m[10][12]
	m[4][6] = m[6][4]
	m[12][11] = po*t2*t3+ry*t5*t6+rz*t8*t9
	m[11][12] = m[12][11]
	m[6][5] = m[11][12]
	m[5][6] = m[6][5]
}
// consistent_M - transpiled function from  GOPATH/History_frame3DD/src/frame3dd.c:791
func consistent_M(m [][]float64, xyz []vec3, r []float32, L float64, n1 int32, n2 int32, Ax float32, J float32, Iy float32, Iz float32, p float32, d float32, EMs float32) {
	//
	// * CONSISTENT_M  -  space frame consistent mass matrix in global coordnates 2oct97
	// *   does not include shear deformations
	//
	// coord Xformn
	var t1 float64
	var t2 float64
	var t3 float64
	var t4 float64
	var t5 float64
	var t6 float64
	var t7 float64
	var t8 float64
	var t9 float64
	var t float64
	var ry float64
	var rz float64
	var po float64
	// translational, rotational & polar inertia
	var i int32
	var j int32
	coord_trans(xyz, L, n1, n2, c4goUnsafeConvert_float64(&t1), c4goUnsafeConvert_float64(&t2), c4goUnsafeConvert_float64(&t3), c4goUnsafeConvert_float64(&t4), c4goUnsafeConvert_float64(&t5), c4goUnsafeConvert_float64(&t6), c4goUnsafeConvert_float64(&t7), c4goUnsafeConvert_float64(&t8), c4goUnsafeConvert_float64(&t9), p)
	t = float64(d*Ax)*L
	ry = float64(d*Iy)
	rz = float64(d*Iz)
	po = float64(d*J)*L
	for i = 1; i <= 12; i++ {
		for j = 1; j <= 12; j++ {
			m[i][j] = 0
		}
	}
	m[7][7] = t/3
	m[1][1] = m[7][7]
	m[8][8] = 13*t/35+6*rz/(5*L)
	m[2][2] = m[8][8]
	m[9][9] = 13*t/35+6*ry/(5*L)
	m[3][3] = m[9][9]
	m[10][10] = po/3
	m[4][4] = m[10][10]
	m[11][11] = t*L*L/105+2*L*ry/15
	m[5][5] = m[11][11]
	m[12][12] = t*L*L/105+2*L*rz/15
	m[6][6] = m[12][12]
	m[3][5] = -11*t*L/210-ry/10
	m[5][3] = m[3][5]
	m[2][6] = 11*t*L/210+rz/10
	m[6][2] = m[2][6]
	m[1][7] = t/6
	m[7][1] = m[1][7]
	m[6][8] = 13*t*L/420-rz/10
	m[8][6] = m[6][8]
	m[5][9] = -13*t*L/420+ry/10
	m[9][5] = m[5][9]
	m[4][10] = po/6
	m[10][4] = m[4][10]
	m[3][11] = 13*t*L/420-ry/10
	m[11][3] = m[3][11]
	m[2][12] = -13*t*L/420+rz/10
	m[12][2] = m[2][12]
	m[9][11] = 11*t*L/210+ry/10
	m[11][9] = m[9][11]
	m[8][12] = -11*t*L/210-rz/10
	m[12][8] = m[8][12]
	m[2][8] = 9*t/70-6*rz/(5*L)
	m[8][2] = m[2][8]
	m[3][9] = 9*t/70-6*ry/(5*L)
	m[9][3] = m[3][9]
	m[5][11] = -L*L*t/140-ry*L/30
	m[11][5] = m[5][11]
	m[6][12] = -L*L*t/140-rz*L/30
	m[12][6] = m[6][12]
	{
		// rotatory inertia of extra beam mass is neglected
		for i = 1; i <= 3; i++ {
			m[i][i] += 0.5*float64(EMs)
		}
	}
	for i = 7; i <= 9; i++ {
		m[i][i] += 0.5*float64(EMs)
	}
	// globalize
	atma(t1, t2, t3, t4, t5, t6, t7, t8, t9, m, r[n1], r[n2])
	{
		// check and enforce symmetry of consistent element mass matrix
		for i = 1; i <= 12; i++ {
			for j = i+1; j <= 12; j++ {
				if m[i][j] != m[j][i] {
					if math.Abs(m[i][j]/m[j][i]-1) > 1e-06 && (math.Abs(m[i][j]/m[i][i]) > 1e-06 || math.Abs(m[j][i]/m[i][i]) > 1e-06) {
						noarch.Fprintf(noarch.Stderr, []byte("consistent_M: element mass matrix not symetric ...\n\x00"))
						noarch.Fprintf(noarch.Stderr, []byte(" ... m[%d][%d] = %15.6e \n\x00"), i, j, m[i][j])
						noarch.Fprintf(noarch.Stderr, []byte(" ... m[%d][%d] = %15.6e   \x00"), j, i, m[j][i])
						noarch.Fprintf(noarch.Stderr, []byte(" ... relative error = %e \n\x00"), math.Abs(m[i][j]/m[j][i]-1))
						noarch.Fprintf(noarch.Stderr, []byte(" ... element matrix saved in file 'mc'\n\x00"))
						save_dmatrix([]byte("mc\x00"), m, 1, 12, 1, 12, 0, []byte("w\x00"))
					}
					m[j][i] = 0.5*(m[i][j]+m[j][i])
					m[i][j] = m[j][i]
				}
			}
		}
	}
}
// static_condensation - transpiled function from  GOPATH/History_frame3DD/src/frame3dd.c:879
func static_condensation(A [][]float64, N int32, c []int32, n int32, Ac [][]float64, verbose int32) {
	//
	// * STATIC_CONDENSATION - of stiffness matrix from NxN to nxn    30aug01
	//
	var Arr [][]float64
	var Arc [][]float64
	var i int32
	var j int32
	var k int32
	var ri int32
	var rj int32
	var ci int32
	var cj int32
	var ok int32
	var r []int32
	r = ivector(1, N-n)
	Arr = dmatrix(1, N-n, 1, N-n)
	Arc = dmatrix(1, N-n, 1, n)
	k = 1
	for i = 1; i <= N; i++ {
		ok = 1
		for j = 1; j <= n; j++ {
			if c[j] == i {
				ok = 0
				break
			}
		}
		if ok != 0 {
			r[func() int32 {
				defer func() {
					k ++
				}()
				return k
			}()] = i
		}
	}
	for i = 1; i <= N-n; i++ {
		{
			// use only upper triangle of A
			for j = i; j <= N-n; j++ {
				ri = r[i]
				rj = r[j]
				if ri <= rj {
					Arr[i][j] = A[ri][rj]
					Arr[j][i] = Arr[i][j]
				}
			}
		}
	}
	for i = 1; i <= N-n; i++ {
		{
			// use only upper triangle of A
			for j = 1; j <= n; j++ {
				ri = r[i]
				cj = c[j]
				if ri < cj {
					Arc[i][j] = A[ri][cj]
				} else {
					Arc[i][j] = A[cj][ri]
				}
			}
		}
	}
	xtinvAy(Arc, Arr, Arc, N-n, n, Ac, verbose)
	for i = 1; i <= n; i++ {
		{
			// use only upper triangle of A
			for j = i; j <= n; j++ {
				ci = c[i]
				cj = c[j]
				if ci <= cj {
					Ac[i][j] = A[ci][cj]-Ac[i][j]
					Ac[j][i] = Ac[i][j]
				}
			}
		}
	}
	free_ivector(r, 1, N-n)
	free_dmatrix(Arr, 1, N-n, 1, N-n)
	free_dmatrix(Arc, 1, N-n, 1, n)
}
// paz_condensation - transpiled function from  GOPATH/History_frame3DD/src/frame3dd.c:939
func paz_condensation(M [][]float64, K [][]float64, N int32, c []int32, n int32, Mc [][]float64, Kc [][]float64, w2 float64, verbose int32) {
	//
	// * PAZ_CONDENSATION -   Paz condensation of mass and stiffness matrices 6jun07
	// *          Paz M. Dynamic condensation. AIAA J 1984;22(5):724-727.
	//
	var Drr [][]float64
	var Drc [][]float64
	var invDrrDrc [][]float64
	var T [][]float64
	var i int32
	var j int32
	var k int32
	var ri int32
	var rj int32
	var cj int32
	var ok int32
	var r []int32
	_ = 4
	func() {
		if len(M) != 0 {
		} else {
			__assert_fail([]byte("M!=NULL\x00"), []byte("/mnt/hdd1/go/History_frame3DD/src/frame3dd.c\x00"), 949, []byte("void paz_condensation(double **, double **, int, int *, int, double **, double **, double, int)\x00"))
		}
	}()
	r = ivector(1, N-n)
	Drr = dmatrix(1, N-n, 1, N-n)
	Drc = dmatrix(1, N-n, 1, n)
	// inv(Drr) * Drc
	invDrrDrc = dmatrix(1, N-n, 1, n)
	// coordinate transformation matrix
	T = dmatrix(1, N, 1, n)
	// eigen-value ... omega^2
	w2 = 4*3.141592653589793*3.141592653589793*w2*w2
	// find "remaining" (r) degrees of freedom, not "condensed" (c)
	k = 1
	for i = 1; i <= N; i++ {
		ok = 1
		for j = 1; j <= n; j++ {
			if c[j] == i {
				ok = 0
				break
			}
		}
		if ok != 0 {
			r[func() int32 {
				defer func() {
					k ++
				}()
				return k
			}()] = i
		}
	}
	for i = 1; i <= N-n; i++ {
		{
			// use only upper triangle of K,M
			for j = 1; j <= N-n; j++ {
				ri = r[i]
				rj = r[j]
				if ri <= rj {
					Drr[i][j] = K[ri][rj]-w2*M[ri][rj]
					Drr[j][i] = Drr[i][j]
				} else {
					Drr[i][j] = K[rj][ri]-w2*M[rj][ri]
					Drr[j][i] = Drr[i][j]
				}
			}
		}
	}
	for i = 1; i <= N-n; i++ {
		{
			// use only upper triangle of K,M
			for j = 1; j <= n; j++ {
				ri = r[i]
				cj = c[j]
				if ri < cj {
					Drc[i][j] = K[ri][cj]-w2*M[ri][cj]
				} else {
					Drc[i][j] = K[cj][ri]-w2*M[cj][ri]
				}
			}
		}
	}
	// inv(Drr) * Drc
	invAB(Drr, Drc, N-n, n, invDrrDrc, c4goUnsafeConvert_int32(&ok), verbose)
	{
		// coordinate transformation matrix
		for i = 1; i <= n; i++ {
			for j = 1; j <= n; j++ {
				T[c[i]][j] = 0
			}
			T[c[i]][i] = 1
		}
	}
	for i = 1; i <= N-n; i++ {
		for j = 1; j <= n; j++ {
			T[r[i]][j] = -invDrrDrc[i][j]
		}
	}
	// Kc = T' * K * T
	xtAx(K, T, Kc, N, n)
	// Mc = T' * M * T
	xtAx(M, T, Mc, N, n)
	free_ivector(r, 1, N-n)
	free_dmatrix(Drr, 1, N-n, 1, N-n)
	free_dmatrix(Drc, 1, N-n, 1, n)
	free_dmatrix(invDrrDrc, 1, N-n, 1, N-n)
	free_dmatrix(T, 1, N-n, 1, n)
}
// modal_condensation - transpiled function from  GOPATH/History_frame3DD/src/frame3dd.c:1019
func modal_condensation(M [][]float64, K [][]float64, N int32, R []int32, p []int32, n int32, Mc [][]float64, Kc [][]float64, V [][]float64, f []float64, m []int32, verbose int32) {
	//
	// * MODAL_CONDENSATION -
	// *      dynamic condensation of mass and stiffness matrices    8oct01
	// *   matches the response at a set of frequencies and modes
	// * WARNING: Kc and Mc may be ill-conditioned, and xyzsibly non-positive def.
	//
	var P [][]float64
	var invP [][]float64
	var traceM float64
	var traceMc float64
	var Aij float64
	// temporary storage for matrix mult.
	var i int32
	var j int32
	var k int32
	P = dmatrix(1, n, 1, n)
	invP = dmatrix(1, n, 1, n)
	{
		// first n modal vectors at primary DoF's
		for i = 1; i <= n; i++ {
			for j = 1; j <= n; j++ {
				P[i][j] = V[p[i]][m[j]]
			}
		}
	}
	pseudo_inv(P, invP, n, n, 1e-09, verbose)
	for i = 1; i <= N; i++ {
		if noarch.Not(R[i]) {
			traceM += M[i][i]
		}
	}
	{
		// compute inv(P)' * I * inv(P)
		for i = 1; i <= n; i++ {
			for j = 1; j <= n; j++ {
				Aij = 0
				for k = 1; k <= n; k++ {
					Aij += invP[k][i]*invP[k][j]
				}
				Mc[i][j] = Aij
			}
		}
	}
	for i = 1; i <= n; i++ {
		traceMc += Mc[i][i]
	}
	{
		// compute inv(P)' * W^2 * inv(P)
		for i = 1; i <= n; i++ {
			for j = 1; j <= n; j++ {
				Aij = 0
				for k = 1; k <= n; k++ {
					Aij += invP[k][i]*4*3.141592653589793*3.141592653589793*f[m[k]]*f[m[k]]*invP[k][j]
				}
				Kc[i][j] = Aij
			}
		}
	}
	for i = 1; i <= n; i++ {
		for j = 1; j <= n; j++ {
			Mc[i][j] *= traceM/traceMc
		}
	}
	for i = 1; i <= n; i++ {
		for j = 1; j <= n; j++ {
			Kc[i][j] *= traceM/traceMc
		}
	}
	free_dmatrix(P, 1, n, 1, n)
	free_dmatrix(invP, 1, n, 1, n)
}
// deallocate - transpiled function from  GOPATH/History_frame3DD/src/frame3dd.c:1076
func deallocate(nN int32, nE int32, nL int32, nF []int32, nU []int32, nW []int32, nP []int32, nT []int32, DoF int32, nM int32, xyz []vec3, rj []float32, L []float64, Le []float64, N1 []int32, N2 []int32, q []int32, r []int32, Ax []float32, Asy []float32, Asz []float32, J []float32, Iy []float32, Iz []float32, E []float32, G []float32, p []float32, U [][][]float32, W [][][]float32, P [][][]float32, T [][][]float32, Dp [][]float32, F_mech [][]float64, F_temp [][]float64, eqF_mech [][][]float64, eqF_temp [][][]float64, F []float64, dF []float64, K [][]float64, Q [][]float64, D []float64, dD []float64, R []float64, dR []float64, d []float32, EMs []float32, NMs []float32, NMx []float32, NMy []float32, NMz []float32, M [][]float64, f []float64, V [][]float64, c []int32, m []int32, pkNx [][]float64, pkVy [][]float64, pkVz [][]float64, pkTx [][]float64, pkMy [][]float64, pkMz [][]float64, pkDx [][]float64, pkDy [][]float64, pkDz [][]float64, pkRx [][]float64, pkSy [][]float64, pkSz [][]float64) {
	//
	// * DEALLOCATE  -  release allocated memory     9sep08
	//
	_ = xyz
	free_vector(rj, 1, nN)
	free_dvector(L, 1, nE)
	free_dvector(Le, 1, nE)
	// printf("..B..element connectivity\n"); /* debug */
	free_ivector(N1, 1, nE)
	free_ivector(N2, 1, nE)
	free_ivector(q, 1, DoF)
	free_ivector(r, 1, DoF)
	// printf("..C..section properties \n"); /* debug */
	free_vector(Ax, 1, nE)
	free_vector(Asy, 1, nE)
	free_vector(Asz, 1, nE)
	free_vector(J, 1, nE)
	free_vector(Iy, 1, nE)
	free_vector(Iz, 1, nE)
	free_vector(E, 1, nE)
	free_vector(G, 1, nE)
	free_vector(p, 1, nE)
	// printf("..D.. U W P T Dp\n"); /* debug */
	free_D3matrix(U, 1, nL, 1, nE, 1, 4)
	free_D3matrix(W, 1, nL, 1, 10*nE, 1, 13)
	free_D3matrix(P, 1, nL, 1, 10*nE, 1, 5)
	free_D3matrix(T, 1, nL, 1, nE, 1, 8)
	free_matrix(Dp, 1, nL, 1, DoF)
	// printf("..E..F_mech & F_temp\n"); /* debug */
	free_dmatrix(F_mech, 1, nL, 1, DoF)
	free_dmatrix(F_temp, 1, nL, 1, DoF)
	// printf("..F.. eqF_mech & eqF_temp\n"); /* debug */
	free_D3dmatrix(eqF_mech, 1, nL, 1, nE, 1, 12)
	free_D3dmatrix(eqF_temp, 1, nL, 1, nE, 1, 12)
	// printf("..G.. F & dF\n"); /* debug */
	free_dvector(F, 1, DoF)
	free_dvector(dF, 1, DoF)
	// printf("..H.. K & Q\n"); /* debug */
	free_dmatrix(K, 1, DoF, 1, DoF)
	free_dmatrix(Q, 1, nE, 1, 12)
	// printf("..I.. D  dD R dR \n"); /* debug */
	free_dvector(D, 1, DoF)
	free_dvector(dD, 1, DoF)
	free_dvector(R, 1, DoF)
	free_dvector(dR, 1, DoF)
	// printf("..J.. extra mass\n"); /* debug */
	free_vector(d, 1, nE)
	free_vector(EMs, 1, nE)
	free_vector(NMs, 1, nN)
	free_vector(NMx, 1, nN)
	free_vector(NMy, 1, nN)
	free_vector(NMz, 1, nN)
	// printf("..K.. peak stats\n"); /* debug */
	free_ivector(c, 1, DoF)
	free_ivector(m, 1, DoF)
	free_dmatrix(pkNx, 1, nL, 1, nE)
	free_dmatrix(pkVy, 1, nL, 1, nE)
	free_dmatrix(pkVz, 1, nL, 1, nE)
	free_dmatrix(pkTx, 1, nL, 1, nE)
	free_dmatrix(pkMy, 1, nL, 1, nE)
	free_dmatrix(pkMz, 1, nL, 1, nE)
	free_dmatrix(pkDx, 1, nL, 1, nE)
	free_dmatrix(pkDy, 1, nL, 1, nE)
	free_dmatrix(pkDz, 1, nL, 1, nE)
	free_dmatrix(pkRx, 1, nL, 1, nE)
	free_dmatrix(pkSy, 1, nL, 1, nE)
	free_dmatrix(pkSz, 1, nL, 1, nE)
	if nM > 0 {
		// printf("..L.. M f V\n"); /* debug */
		free_dmatrix(M, 1, DoF, 1, DoF)
		free_dvector(f, 1, nM)
		free_dmatrix(V, 1, DoF, 1, DoF)
	}
}
// parse_options - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:58
func parse_options(argc int32, argv [][]byte, IN_file []byte, OUT_file []byte, shear_flag []int32, geom_flag []int32, anlyz_flag []int32, exagg_flag []float64, D3_flag []int32, lump_flag []int32, modal_flag []int32, tol_flag []float64, shift_flag []float64, pan_flag []float32, write_matrix []int32, axial_sign []int32, condense_flag []int32, verbose []int32, debug []int32) {
	//
	// This file is part of FRAME3DD:
	// Static and dynamic structural analysis of 2D and 3D frames and trusses with
	// elastic and geometric stiffness.
	// ---------------------------------------------------------------------------
	// http://frame3dd.sourceforge.net/
	// ---------------------------------------------------------------------------
	// Copyright (C) 1992-2015  Henri P. Gavin
	//
	// FRAME3DD is free software: you can redistribute it and/or modify
	// it under the terms of the GNU General Public License as published by
	// the Free Software Foundation, either version 3 of the License, or
	// (at your option) any later version.
	//
	// FRAME3DD is distributed in the hope that it will be useful,
	// but WITHOUT ANY WARRANTY; without even the implied warranty of
	// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	// GNU General Public License for more details.
	//
	// You should have received a copy of the GNU General Public License
	// along with FRAME3DD.  If not, see <http://www.gnu.org/licenses/>.
	//
	//
	// @file
	// Input/output routines for FRAME.
	//
	// @note The file format for FRAME is defined in doc/user_manual.html.
	//
	// #define MASSDATA_DEBUG
	// forward decls
	//< pointer to the file from which to read
	//< pointer to the string to which to write
	//< the longest anticipated line length
	//
	// * PARSE_OPTIONS -  parse command line options
	// * command line options over-ride values in the input data file
	// * 04 Mar 2009, 22 Sep 2009
	//
	var option byte
	var errMsg []byte = make([]byte, 512)
	// *scanf return value
	var sfrv int32
	modal_flag[0] = -1
	lump_flag[0] = modal_flag[0]
	anlyz_flag[0] = lump_flag[0]
	geom_flag[0] = anlyz_flag[0]
	// default values
	shear_flag[0] = geom_flag[0]
	shift_flag[0] = -1
	tol_flag[0] = shift_flag[0]
	exagg_flag[0] = tol_flag[0]
	D3_flag[0] = 0
	pan_flag[0] = float32(-1)
	condense_flag[0] = -1
	write_matrix[0] = 0
	axial_sign[0] = 1
	debug[0] = 0
	verbose[0] = 1
	noarch.Strcpy(IN_file, []byte("\x00\x00"))
	noarch.Strcpy(OUT_file, []byte("\x00\x00"))
	switch argc {
	case 1:
		// set up file names for the the input data and the output data
		noarch.Fprintf(noarch.Stderr, []byte("\n Frame3DD version: %s\n\x00"), []byte("20140514+\x00"))
		noarch.Fprintf(noarch.Stderr, []byte(" Analysis of 2D and 3D structural frames with elastic and geometric stiffness.\n\x00"))
		//frame3dd.sourceforge.net\n\n");
		noarch.Fprintf(noarch.Stderr, []byte(" http://frame3dd.sourceforge.net\n\n\x00"))
		noarch.Fprintf(noarch.Stderr, []byte(" Please enter the  input data file name: \x00"))
		sfrv = noarch.Scanf([]byte("%s\x00"), IN_file)
		if sfrv != 1 {
			sferr([]byte("IN_file\x00"))
		}
		noarch.Fprintf(noarch.Stderr, []byte(" Please enter the output data file name: \x00"))
		sfrv = noarch.Scanf([]byte("%s\x00"), OUT_file)
		if sfrv != 1 {
			sferr([]byte("OUT_file\x00"))
		}
		return
	case 3:
		if int32(argv[1][0]) != int32('-') {
			noarch.Strcpy(IN_file, argv[1])
			noarch.Strcpy(OUT_file, argv[2])
			return
		}
	}
	for int32((func() byte {
		option = byte(getopt(argc, argv, []byte("i:o:acdhqvwxzs:e:f:g:l:m:p:r:t:\x00")))
		return option
	}())) != -1 {
		switch int32(option) {
		case 'i':
			// remaining unused flags ... b j k n u y
			// input data file name
			noarch.Strcpy(IN_file, optarg)
		case 'o':
			// output data file name
			noarch.Strcpy(OUT_file, optarg)
		case 'h':
			// help
			display_help()
			unix.Exit(0)
			fallthrough
		case 'v':
			// version
			display_version()
			unix.Exit(0)
			fallthrough
		case 'a':
			// about
			display_version_about()
			unix.Exit(0)
			fallthrough
		case 'q':
			// quiet
			verbose[0] = 0
		case 'c':
			// data check only
			anlyz_flag[0] = 0
		case 'd':
			// debug
			debug[0] = 1
		case 'w':
			// write stiffness and mass
			write_matrix[0] = 1
		case 'x':
			// write sign of axial forces
			axial_sign[0] = 0
		case 's':
			if noarch.Strcmp(optarg, []byte("Off\x00")) == 0 {
				// shear deformation
				shear_flag[0] = 0
			} else if noarch.Strcmp(optarg, []byte("On\x00")) == 0 {
				shear_flag[0] = 1
			} else {
				errorMsg([]byte("\n frame3dd command-line error: argument to -s option should be either On or Off\n\x00"))
				unix.Exit(3)
			}
		case 'g':
			if noarch.Strcmp(optarg, []byte("Off\x00")) == 0 {
				// geometric stiffness
				geom_flag[0] = 0
			} else if noarch.Strcmp(optarg, []byte("On\x00")) == 0 {
				geom_flag[0] = 1
			} else {
				errorMsg([]byte("\n frame3dd command-line error: argument to -g option should be either On or Off\n\x00"))
				unix.Exit(4)
			}
		case 'e':
			// static mesh exagg. factor
			exagg_flag[0] = noarch.Atof(optarg)
		case 'z':
			// force 3D plotting
			D3_flag[0] = 1
		case 'l':
			if noarch.Strcmp(optarg, []byte("Off\x00")) == 0 {
				// lumped or consistent mass
				lump_flag[0] = 0
			} else if noarch.Strcmp(optarg, []byte("On\x00")) == 0 {
				lump_flag[0] = 1
			} else {
				errorMsg([]byte("\n frame3dd command-line error: argument to -l option should be either On or Off\n\x00"))
				unix.Exit(5)
			}
		case 'm':
			if noarch.Strcmp(optarg, []byte("J\x00")) == 0 {
				// modal analysis method
				modal_flag[0] = 1
			} else if noarch.Strcmp(optarg, []byte("S\x00")) == 0 {
				modal_flag[0] = 2
			} else {
				errorMsg([]byte("\n frame3dd command-line error: argument to -m option should be either J or S\n\x00"))
				unix.Exit(6)
			}
		case 't':
			// modal analysis tolerence
			tol_flag[0] = noarch.Atof(optarg)
			if tol_flag[0] == 0 {
				errorMsg([]byte("\n frame3dd command-line error: argument to -t option should be a number.\n\x00"))
				unix.Exit(7)
			}
		case 'f':
			// modal analysis freq. shift
			shift_flag[0] = noarch.Atof(optarg)
			if shift_flag[0] == 0 {
				errorMsg([]byte("\n frame3dd command-line error: argument to -f option should be a number.\n\x00"))
				unix.Exit(8)
			}
		case 'p':
			// pan rate
			pan_flag[0] = float32(noarch.Atof(optarg))
			if float64(pan_flag[0]) < 0 {
				errorMsg([]byte("\n frame3dd command-line error: argument to -p option should be a positive number.\n\x00"))
				unix.Exit(9)
			}
		case 'r':
			// matrix condensation method
			condense_flag[0] = noarch.Atoi(optarg)
			if condense_flag[0] < 0 || condense_flag[0] > 3 {
				errorMsg([]byte("\n frame3dd command-line error: argument to -r option should be 0, 1, or 2.\n\x00"))
				unix.Exit(10)
			}
		case '?':
			noarch.Sprintf(errMsg, []byte("  Missing argument or Unknown option: -%c\n\n\x00"), int32(option))
			errorMsg(errMsg)
			display_help()
			unix.Exit(2)
		}
	}
	if noarch.Strcmp(IN_file, []byte("\x00\x00")) == 0 {
		noarch.Fprintf(noarch.Stderr, []byte(" Please enter the  input data file name: \x00"))
		sfrv = noarch.Scanf([]byte("%s\x00"), IN_file)
		if sfrv != 1 {
			sferr([]byte("IN_file\x00"))
		}
		noarch.Fprintf(noarch.Stderr, []byte(" Please enter the output data file name: \x00"))
		sfrv = noarch.Scanf([]byte("%s\x00"), OUT_file)
		if sfrv != 1 {
			sferr([]byte("OUT_file\x00"))
		}
	}
	if noarch.Strcmp(IN_file, []byte("\x00\x00")) != 0 && noarch.Strcmp(OUT_file, []byte("\x00\x00")) == 0 {
		noarch.Strcpy(OUT_file, IN_file)
		noarch.Strcat(OUT_file, []byte(".out\x00"))
	}
}
// display_help - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:255
func display_help() {
	//
	// * DISPLAY_HELP -  display help information to stderr
	// * 04 Mar 2009, 22 Sep 2009
	//
	textColor('g', 'x', 'x', 'x')
	noarch.Fprintf(noarch.Stderr, []byte("\n Frame3DD version: %s\n\x00"), []byte("20140514+\x00"))
	noarch.Fprintf(noarch.Stderr, []byte(" Analysis of 2D and 3D structural frames with elastic and geometric stiffness.\n\x00"))
	//frame3dd.sourceforge.net\n\n");
	noarch.Fprintf(noarch.Stderr, []byte(" http://frame3dd.sourceforge.net\n\n\x00"))
	// fprintf(stderr,"  Usage: frame3dd -i<input> -o<output> [-hvcqz] [-s<On|Off>] [-g<On|Off>] [-e<value>] [-l<On|Off>] [-f<value>] [-m J|S] [-t<value>] [-p<value>] \n");
	//
	noarch.Fprintf(noarch.Stderr, []byte("  Frame3DD may be run with interactive prompting for file names by typing ...\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("       frame3dd \n\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("  Frame3DD may be run without command-line options by typing ...\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("       frame3dd <InFile> <OutFile> \n\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("  Frame3DD may be run with command-line options by typing ...\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("       frame3dd -i <InFile> -o <OutFile> [OPTIONS] \n\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte(" ... where [OPTIONS] over-rides values in the input data file and includes\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("     one or more of the following:\n\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte(" -------------------------------------------------------------------------\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("  -i  <InFile>  the  input data file name --- described in the manual\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("  -o <OutFile>  the output data file name\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("  -h            print this help message and exit\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("  -v            display program version, website, brief help info and exit\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("  -a            display program version, website and exit\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("  -c            data check only - the output data reviews the input data\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("  -w            write stiffness and mass matrices to files named Ks Kd Md\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("  -x            suppress writing of 't' or 'c' for sign of axial forces\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("  -q            suppress screen output except for warning messages\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("  -s  On|Off    On: include shear deformation or Off: neglect ...\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("  -g  On|Off    On: include geometric stiffness or Off: neglect ...\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("  -e <value>    static deformation exaggeration factor for Gnuplot output\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("  -z            force X-Y-Z plotting\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("  -l  On|Off    On: lumped mass matrix or Off: consistent mass matrix\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("  -f <value>    modal frequency shift for unrestrained structures\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("  -m   J|S      modal analysis method: J=Jacobi-Subspace or S=Stodola\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("  -t <value>    convergence tolerance for modal analysis\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("  -p <value>    pan rate for mode shape animation\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("  -r <value>    matrix condensation method: 0, 1, 2, or 3 \n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte(" -------------------------------------------------------------------------\n\x00"))
	color(0)
}
// display_usage - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:304
func display_usage() {
	//
	// * DISPLAY_USAGE -  display usage information to stderr
	// * 04 Mar 2009
	//
	noarch.Fprintf(noarch.Stderr, []byte("\n Frame3DD version: %s\n\x00"), []byte("20140514+\x00"))
	noarch.Fprintf(noarch.Stderr, []byte(" Analysis of 2D and 3D structural frames with elastic and geometric stiffness.\n\x00"))
	//frame3dd.sourceforge.net\n\n");
	noarch.Fprintf(noarch.Stderr, []byte(" http://frame3dd.sourceforge.net\n\n\x00"))
	// fprintf(stderr,"  Usage: frame3dd -i<input> -o<output> [-hvcqz] [-s<On|Off>] [-g<On|Off>] [-e<value>] [-l<On|Off>] [-f<value>] [-m J|S] [-t<value>] [-p<value>] \n");
	//
	noarch.Fprintf(noarch.Stderr, []byte("  Usage: frame3dd -i <input> -o <output> [OPTIONS] \n\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("  Type ...   frame3dd -h   ... for additional help information.\n\n\x00"))
}
// display_version - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:321
func display_version() {
	//
	// * DISPLAY_VERSION_HELP -  display version, website, and brief help info. to stderr
	// * 04 Mar 2009
	//
	noarch.Fprintf(noarch.Stderr, []byte("\n Frame3DD version: %s\n\x00"), []byte("20140514+\x00"))
	noarch.Fprintf(noarch.Stderr, []byte(" Analysis of 2D and 3D structural frames with elastic and geometric stiffness.\n\x00"))
	//frame3dd.sourceforge.net\n\n");
	noarch.Fprintf(noarch.Stderr, []byte(" http://frame3dd.sourceforge.net\n\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("  Usage: frame3dd -i <input> -o <output> [OPTIONS] \n\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("  Type ...   frame3dd -h   ... for additional help information.\n\n\x00"))
}
// display_version_about - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:339
func display_version_about() {
	//
	// * DISPLAY_VERSION_ABOUT-  display version and website to stderr for
	// * running as a background process
	// * 22 Sep 2009
	// * Contributed by Barry Sanford, barry.sanford@trimjoist.com
	//
	noarch.Fprintf(noarch.Stderr, []byte(" Frame3DD version: %s\n\x00"), []byte("20140514+\x00"))
	noarch.Fprintf(noarch.Stderr, []byte(" Analysis of 2D and 3D structural frames with elastic and geometric stiffness\n\x00"))
	//frame3dd.sourceforge.net\n");
	noarch.Fprintf(noarch.Stderr, []byte(" http://frame3dd.sourceforge.net\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte(" GPL Copyright (C) 1992-2015, Henri P. Gavin \n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte(" Frame3DD is distributed in the hope that it will be useful\x00"))
	noarch.Fprintf(noarch.Stderr, []byte(" but with no warranty.\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte(" For details see the GNU Public Licence:\x00"))
	//www.fsf.org/copyleft/gpl.html\n");
	noarch.Fprintf(noarch.Stderr, []byte(" http://www.fsf.org/copyleft/gpl.html\n\x00"))
}
// read_node_data - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:356
func read_node_data(fp *noarch.File, nN int32, xyz []vec3, r []float32) {
	//
	// * READ_NODE_DATA  -  read node location data
	// * 04 Jan 2009
	//
	var i int32
	var j int32
	var sfrv int32
	// *scanf return value
	var errMsg []byte = make([]byte, 512)
	{
		// read node coordinates
		for i = 1; i <= nN; i++ {
			sfrv = noarch.Fscanf(fp, []byte("%d\x00"), c4goUnsafeConvert_int32(&j))
			if sfrv != 1 {
				sferr([]byte("node number in node data\x00"))
			}
			if j <= 0 || j > nN {
				noarch.Sprintf(errMsg, []byte("\nERROR: in node coordinate data, node number out of range\n(node number %d is <= 0 or > %d)\n\x00"), j, nN)
				errorMsg(errMsg)
				unix.Exit(41)
			}
			sfrv = noarch.Fscanf(fp, []byte("%f %f %f %f\x00\x00\x00\x00"), (*[1000000]float64)(unsafe.Pointer(&xyz[j].x))[:], (*[1000000]float64)(unsafe.Pointer(&xyz[j].y))[:], (*[1000000]float64)(unsafe.Pointer(&xyz[j].z))[:], r[j:])
			if sfrv != 4 {
				sferr([]byte("node coordinates in node data\x00"))
			}
			// fprintf(stderr,"\nj = %d, pos = (%lf, %lf, %lf), r = %f", j, xyz[j].x, xyz[j].y, xyz[j].z, r[j]);
			r[j] = float32(math.Abs(float64(r[j])))
		}
	}
}
// read_frame_element_data - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:383
func read_frame_element_data(fp *noarch.File, nN int32, nE int32, xyz []vec3, r []float32, L []float64, Le []float64, N1 []int32, N2 []int32, Ax []float32, Asy []float32, Asz []float32, Jx []float32, Iy []float32, Iz []float32, E []float32, G []float32, p []float32, d []float32) {
	//
	// * READ_FRAME_ELEMENT_DATA  -  read frame element property data
	// * 04 Jan 2009
	//
	var n1 int32
	var n2 int32
	var i int32
	var n int32
	var b int32
	// vector of elements per node
	var epn []int32
	var epn0 int32
	// *scanf return value
	var sfrv int32
	var errMsg []byte = make([]byte, 512)
	epn = ivector(1, nN)
	for n = 1; n <= nN; n++ {
		epn[n] = 0
	}
	{
		// read frame element properties
		for i = 1; i <= nE; i++ {
			sfrv = noarch.Fscanf(fp, []byte("%d\x00"), c4goUnsafeConvert_int32(&b))
			if sfrv != 1 {
				sferr([]byte("frame element number in element data\x00"))
			}
			if b <= 0 || b > nE {
				noarch.Sprintf(errMsg, []byte("\n  error in frame element property data: Element number out of range  \n Frame element number: %d  \n\x00"), b)
				errorMsg(errMsg)
				unix.Exit(51)
			}
			sfrv = noarch.Fscanf(fp, []byte("%d %d\x00"), N1[b:], N2[b:])
			epn[N1[b]] ++
			epn[N2[b]] ++
			if sfrv != 2 {
				sferr([]byte("node numbers in frame element data\x00"))
			}
			if N1[b] <= 0 || N1[b] > nN || N2[b] <= 0 || N2[b] > nN {
				noarch.Sprintf(errMsg, []byte("\n  error in frame element property data: node number out of range  \n Frame element number: %d \n\x00"), b)
				errorMsg(errMsg)
				unix.Exit(52)
			}
			sfrv = noarch.Fscanf(fp, []byte("%f %f %f\x00"), Ax[b:], Asy[b:], Asz[b:])
			if sfrv != 3 {
				sferr([]byte("section areas in frame element data\x00"))
			}
			sfrv = noarch.Fscanf(fp, []byte("%f %f %f\x00"), Jx[b:], Iy[b:], Iz[b:])
			if sfrv != 3 {
				sferr([]byte("section inertias in frame element data\x00"))
			}
			sfrv = noarch.Fscanf(fp, []byte("%f %f\x00"), E[b:], G[b:])
			if sfrv != 2 {
				sferr([]byte("material moduli in frame element data\x00"))
			}
			sfrv = noarch.Fscanf(fp, []byte("%f\x00"), p[b:])
			if sfrv != 1 {
				sferr([]byte("roll angle in frame element data\x00"))
			}
			// convert from degrees to radians
			p[b] = float32(float64(p[b])*3.141592653589793/180)
			sfrv = noarch.Fscanf(fp, []byte("%f\x00"), d[b:])
			if sfrv != 1 {
				sferr([]byte("mass density in frame element data\x00"))
			}
			if Ax[b] < 0 || Asy[b] < 0 || Asz[b] < 0 || Jx[b] < 0 || Iy[b] < 0 || Iz[b] < 0 {
				noarch.Sprintf(errMsg, []byte("\n  error in frame element property data: section property < 0 \n  Frame element number: %d  \n\x00"), b)
				errorMsg(errMsg)
				unix.Exit(53)
			}
			if Ax[b] == 0 {
				noarch.Sprintf(errMsg, []byte("\n  error in frame element property data: cross section area is zero   \n  Frame element number: %d  \n\x00"), b)
				errorMsg(errMsg)
				unix.Exit(54)
			}
			if (Asy[b] == 0 || Asz[b] == 0) && G[b] == 0 {
				noarch.Sprintf(errMsg, []byte("\n  error in frame element property data: a shear area and shear modulus are zero   \n  Frame element number: %d  \n\x00"), b)
				errorMsg(errMsg)
				unix.Exit(55)
			}
			if Jx[b] == 0 {
				noarch.Sprintf(errMsg, []byte("\n  error in frame element property data: torsional moment of inertia is zero   \n  Frame element number: %d  \n\x00"), b)
				errorMsg(errMsg)
				unix.Exit(56)
			}
			if Iy[b] == 0 || Iz[b] == 0 {
				noarch.Sprintf(errMsg, []byte("\n  error: cross section bending moment of inertia is zero   \n  Frame element number : %d  \n\x00"), b)
				errorMsg(errMsg)
				unix.Exit(57)
			}
			if E[b] <= 0 || G[b] <= 0 {
				noarch.Sprintf(errMsg, []byte("\n  error : material elastic modulus E or G is not positive   \n  Frame element number: %d  \n\x00"), b)
				errorMsg(errMsg)
				unix.Exit(58)
			}
			if d[b] <= 0 {
				noarch.Sprintf(errMsg, []byte("\n  error : mass density d is not positive   \n  Frame element number: %d  \n\x00"), b)
				errorMsg(errMsg)
				unix.Exit(59)
			}
		}
	}
	{
		// calculate frame element lengths
		for b = 1; b <= nE; b++ {
			n1 = N1[b]
			n2 = N2[b]
			L[b] = (xyz[n2].x-xyz[n1].x)*(xyz[n2].x-xyz[n1].x)+(xyz[n2].y-xyz[n1].y)*(xyz[n2].y-xyz[n1].y)+(xyz[n2].z-xyz[n1].z)*(xyz[n2].z-xyz[n1].z)
			L[b] = math.Sqrt(L[b])
			Le[b] = L[b]-float64(r[n1])-float64(r[n2])
			if n1 == n2 || L[b] == 0 {
				noarch.Sprintf(errMsg, []byte(" Frame elements must start and stop at different nodes\n  frame element %d  N1= %d N2= %d L= %e\n   Perhaps frame element number %d has not been specified.\n  or perhaps the Input Data file is missing expected data.\n\x00"), b, n1, n2, L[b], i)
				errorMsg(errMsg)
				unix.Exit(60)
			}
			if Le[b] <= 0 {
				noarch.Sprintf(errMsg, []byte(" Node  radii are too large.\n  frame element %d  N1= %d N2= %d L= %e \n  r1= %e r2= %e Le= %e \n\x00"), b, n1, n2, L[b], float64(r[n1]), float64(r[n2]), Le[b])
				errorMsg(errMsg)
				unix.Exit(61)
			}
		}
	}
	for n = 1; n <= nN; n++ {
		if epn[n] == 0 {
			noarch.Sprintf(errMsg, []byte("node or frame element property data:\n     node number %3d is unconnected. \n\x00"), n)
			sferr(errMsg)
			epn0 ++
		}
	}
	free_ivector(epn, 1, nN)
	if epn0 > 0 {
		unix.Exit(42)
	}
}
// read_run_data - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:517
func read_run_data(fp *noarch.File, OUT_file []byte, shear []int32, shear_flag int32, geom []int32, geom_flag int32, meshpath []byte, plotpath []byte, infcpath []byte, exagg_static []float64, exagg_flag float64, scale []float32, dx []float32, anlyz []int32, anlyz_flag int32, debug int32) {
	//
	// * READ_RUN_DATA  -  read information for analysis
	// * 29 Dec 2008
	//
	// output data file name
	var full_len int32
	var len_ int32
	var i int32
	var base_file []byte = []byte("EMPTY_BASE\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00")
	var mesh_file []byte = []byte("EMPTY_MESH\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00")
	// *scanf return value
	var sfrv int32
	noarch.Strcpy(base_file, OUT_file)
	for int32(base_file[func() int32 {
		defer func() {
			len_ ++
		}()
		return len_
	}()]) != int32('\x00') {
	}
	// the length of the base_file
	full_len = len_
	for int32(base_file[func() int32 {
		defer func() {
			len_ --
		}()
		return len_
	}()]) != int32('.') && len_ > 0 {
	}
	if len_ == 0 {
		// find the last '.' in base_file
		len_ = full_len
	}
	// end base_file at the last '.'
	base_file[func() int32 {
		len_ ++
		return len_
	}()] = '\x00'
	noarch.Strcpy(plotpath, base_file)
	noarch.Strcat(plotpath, []byte(".plt\x00"))
	noarch.Strcpy(infcpath, base_file)
	noarch.Strcat(infcpath, []byte(".if\x00"))
	for int32(base_file[len_]) != int32('/') && int32(base_file[len_]) != int32('\\') && len_ > 0 {
		// find the last '/' or '\' in base_file
		len_ --
	}
	i = 0
	for int32(base_file[len_]) != int32('\x00') {
		mesh_file[func() int32 {
			defer func() {
				i ++
			}()
			return i
		}()] = base_file[func() int32 {
			defer func() {
				len_ ++
			}()
			return len_
		}()]
	}
	mesh_file[i] = '\x00'
	noarch.Strcat(mesh_file, []byte("-msh\x00"))
	output_path(mesh_file, meshpath, 512, nil)
	if debug != 0 {
		noarch.Fprintf(noarch.Stderr, []byte("OUT_FILE  = %s \n\x00"), OUT_file)
		noarch.Fprintf(noarch.Stderr, []byte("BASE_FILE = %s \n\x00"), base_file)
		noarch.Fprintf(noarch.Stderr, []byte("PLOTPATH  = %s \n\x00"), plotpath)
		noarch.Fprintf(noarch.Stderr, []byte("MESH_FILE = %s \n\x00"), mesh_file)
		noarch.Fprintf(noarch.Stderr, []byte("MESHPATH  = %s \n\x00"), meshpath)
	}
	sfrv = noarch.Fscanf(fp, []byte("%d %d %f %f %f\x00\x00"), shear, geom, exagg_static, scale, dx)
	if sfrv != 5 {
		sferr([]byte("shear, geom, exagg_static, scale, or dx variables\x00"))
	}
	if shear[0] != 0 && shear[0] != 1 {
		errorMsg([]byte(" Rember to specify shear deformations with a 0 or a 1 \n after the frame element property info.\n\x00"))
		unix.Exit(71)
	}
	if geom[0] != 0 && geom[0] != 1 {
		errorMsg([]byte(" Rember to specify geometric stiffness with a 0 or a 1 \n after the frame element property info.\n\x00"))
		unix.Exit(72)
	}
	if exagg_static[0] < 0 {
		errorMsg([]byte(" Remember to specify an exageration factor greater than zero.\n\x00"))
		unix.Exit(73)
	}
	if float64(dx[0]) <= 0 && dx[0] != float32(-1) {
		errorMsg([]byte(" Remember to specify a frame element increment greater than zero.\n\x00"))
		unix.Exit(74)
	}
	if shear_flag != -1 {
		// over-ride values from input data file with command-line options
		shear[0] = shear_flag
	}
	if geom_flag != -1 {
		geom[0] = geom_flag
	}
	if exagg_flag != -1 {
		exagg_static[0] = exagg_flag
	}
	if float64(anlyz_flag) != -1 {
		anlyz[0] = anlyz_flag
	}
}
// frame3dd_getline - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:610
func frame3dd_getline(fp *noarch.File, s []byte, lim int32) int32 {
	//
	// * FRAME3DD_GETLINE -  get line into a character string. from K&R        03feb94
	//
	var c int32
	var i int32
	for func() int32 {
		lim --
		return lim
	}() > 0 && (func() int32 {
		c = noarch.Fgetc(fp)
		return c
	}()) != -1 && c != int32('\n') {
		s[func() int32 {
			defer func() {
				i ++
			}()
			return i
		}()] = byte(c)
	}
	//      if (c == '\n')  s[i++] = c;
	s[i] = '\x00'
	return i
}
// sep - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:630
// platform-dependent path sperator character ...
var sep byte = '/'
// temp_dir - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:638
func temp_dir() []byte {
	//
	// * TEMP_DIR
	// * return platform-specific temp file location --
	// * John Pye, Feb 2009
	//
	// Linux, Unix, OS X
	var tmp []byte = []byte("/tmp\x00")
	return tmp
}
// output_path - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:663
func output_path(fname []byte, fullpath []byte, len_ int32, default_outdir []byte) {
	//
	// * OUTPUT_PATH
	// * return path for output files using either current directory, or FRAME3DD_OUTDIR
	// * if specified. --
	// * John Pye, Feb 2009.
	//
	var res int32
	_ = 4
	func() {
		if len(fname) != 0 {
		} else {
			__assert_fail([]byte("fname!=NULL\x00"), []byte("/mnt/hdd1/go/History_frame3DD/src/frame3dd_io.c\x00"), 665, []byte("void output_path(const char *, char *, const int, const char *)\x00"))
		}
	}()
	//                           deprecated code, January 15 2010 ...
	//   if ( fname[0]==sep ) { in Win32 absolute path starts with C:\ not \ ??
	//                          // absolute output path specified
	////                        res = snprintf(fullpath,len,"%s",fname);
	//                          res = sprintf(fullpath,"%s",fname);
	//   } else {
	//
	//    fprintf(stderr,"Generating output path for file '%s'\n",fname);
	var outdir []byte
	outdir = noarch.Getenv([]byte("FRAME3DD_OUTDIR\x00"))
	if len(outdir) == 0 {
		if len(default_outdir) == 0 {
			outdir = temp_dir()
		} else {
			outdir = default_outdir
		}
	}
	//  res = snprintf(fullpath,len,"%s%c%s",outdir,sep,fname);
	res = noarch.Sprintf(fullpath, []byte("%s%c%s\x00"), outdir, int32(sep), fname)
	if res > len_ {
		//   closing bracket for deprecated code "if"
		// }
		//
		errorMsg([]byte("ERROR: unable to construct output filename: overflow.\n\x00"))
		unix.Exit(16)
	}
}
// parse_input - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:704
func parse_input(fp *noarch.File, tpath []byte) {
	// printf("Output file path generated: %s\n",fullpath); /* debug */
	//
	// * PARSE_INPUT
	// * strip comments from the input file, and write a stripped input file
	// * 07 May 2003
	//
	// stripped input file pointer
	var fpc *noarch.File
	var line []byte = make([]byte, 256)
	var errMsg []byte = make([]byte, 512)
	if (func() *noarch.File {
		fpc = noarch.Fopen(tpath, []byte("w\x00"))
		return fpc
	}()) == nil {
		noarch.Sprintf(errMsg, []byte("\n  error: cannot open parsed input data file: '%s' \n\x00"), tpath)
		errorMsg(errMsg)
		unix.Exit(12)
	}
	for {
		getline_no_comment(fp, line, 256)
		noarch.Fprintf(fpc, []byte("%s \n\x00"), line)
		if !(int32(line[0]) != int32('_') && int32(line[0]) != -1+256) {
			break
		}
	}
	noarch.Fclose(fpc)
}
// getline_no_comment - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:734
func getline_no_comment(fp *noarch.File, s []byte, lim int32) {
	//
	// * GETLINE_NO_COMMENT
	// * get a line into a character string. from K&R
	// * get the line only up to one of the following characters:  \n  %  #  ?
	// * ignore all comma (,) characters
	// * ignore all double quote (") characters
	// * ignore all semi-colon (;) characters
	// * 09 Feb 2009
	//
	//< pointer to the file from which to read
	//< pointer to the string to which to write
	//< the longest anticipated line length
	var c int32
	var i int32
	for func() int32 {
		lim --
		return lim
	}() > 0 && (func() int32 {
		c = noarch.Fgetc(fp)
		return c
	}()) != -1 && c != int32('\n') && c != int32('%') && c != int32('#') && c != int32('?') {
		if c != int32(',') && c != int32('"') && c != int32(';') {
			s[func() int32 {
				defer func() {
					i ++
				}()
				return i
			}()] = byte(c)
		} else {
			s[func() int32 {
				defer func() {
					i ++
				}()
				return i
			}()] = ' '
		}
	}
	//      if (c == '\n')  s[i++] = c;
	s[i] = '\x00'
	if c != int32('\n') {
		for func() int32 {
			lim --
			return lim
		}() > 0 && (func() int32 {
			c = noarch.Fgetc(fp)
			return c
		}()) != -1 && c != int32('\n') {
		}
	}
	if c == -1 {
		// read the rest of the line, otherwise do nothing
		s[0] = byte(-1+256)
	}
}
// read_reaction_data - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:764
func read_reaction_data(fp *noarch.File, DoF int32, nN int32, nR []int32, q []int32, r []int32, sumR []int32, verbose int32) {
	//
	// * READ_REACTION_DATA - Read fixed node displacement boundary conditions
	// * 29 Dec 2009
	//
	var i int32
	var j int32
	var l int32
	// *scanf return value
	var sfrv int32
	var errMsg []byte = make([]byte, 512)
	for i = 1; i <= DoF; i++ {
		r[i] = 0
	}
	// read restrained degrees of freedom
	sfrv = noarch.Fscanf(fp, []byte("%d\x00"), nR)
	if sfrv != 1 {
		sferr([]byte("number of reactions in reaction data\x00"))
	}
	if verbose != 0 {
		noarch.Fprintf(noarch.Stdout, []byte(" number of nodes with reactions \x00"))
		dots(noarch.Stdout, 21)
		noarch.Fprintf(noarch.Stdout, []byte(" nR =%4d \x00"), nR[0])
	}
	if nR[0] < 0 || nR[0] > DoF/6 {
		noarch.Fprintf(noarch.Stderr, []byte(" number of nodes with reactions \x00"))
		dots(noarch.Stderr, 21)
		noarch.Fprintf(noarch.Stderr, []byte(" nR = %3d \x00"), nR[0])
		noarch.Sprintf(errMsg, []byte("\n  error: valid ranges for nR is 0 ... %d \n\x00"), DoF/6)
		errorMsg(errMsg)
		unix.Exit(80)
	}
	for i = 1; i <= nR[0]; i++ {
		sfrv = noarch.Fscanf(fp, []byte("%d\x00"), c4goUnsafeConvert_int32(&j))
		if sfrv != 1 {
			sferr([]byte("node number in reaction data\x00"))
		}
		for l = 5; l >= 0; l-- {
			sfrv = noarch.Fscanf(fp, []byte("%d\x00"), r[6*j-l:])
			if sfrv != 1 {
				sferr([]byte("reaction value in reaction data\x00"))
			}
			if j > nN {
				noarch.Sprintf(errMsg, []byte("\n  error in reaction data: node number %d is greater than the number of nodes, %d \n\x00"), j, nN)
				errorMsg(errMsg)
				unix.Exit(81)
			}
			if r[6*j-l] != 0 && r[6*j-l] != 1 {
				noarch.Sprintf(errMsg, []byte("\n  error in reaction data: Reaction data must be 0 or 1\n   Data for node %d, DoF %d is %d\n\x00"), j, 6-l, r[6*j-l])
				errorMsg(errMsg)
				unix.Exit(82)
			}
		}
		sumR[0] = 0
		for l = 5; l >= 0; l-- {
			sumR[0] += r[6*j-l]
		}
		if sumR[0] == 0 {
			noarch.Sprintf(errMsg, []byte("\n  error: node %3d has no reactions\n   Remove node %3d from the list of reactions\n   and set nR to %3d \n\x00"), j, j, nR[0]-1)
			errorMsg(errMsg)
			unix.Exit(83)
		}
	}
	sumR[0] = 0
	for i = 1; i <= DoF; i++ {
		sumR[0] += r[i]
	}
	if sumR[0] < 4 {
		noarch.Sprintf(errMsg, []byte("\n  Warning:  un-restrained structure   %d imposed reactions.\n  At least 4 reactions are required to support static loads.\n\x00"), sumR[0])
		errorMsg(errMsg)
	}
	if sumR[0] >= DoF {
		// exit(84);
		noarch.Sprintf(errMsg, []byte("\n  error in reaction data:  Fully restrained structure\n   %d imposed reactions >= %d degrees of freedom\n\x00"), sumR[0], DoF)
		errorMsg(errMsg)
		unix.Exit(85)
	}
	for i = 1; i <= DoF; i++ {
		if r[i] != 0 {
			q[i] = 0
		} else {
			q[i] = 1
		}
	}
}
// read_and_assemble_loads - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:844
func read_and_assemble_loads(fp *noarch.File, nN int32, nE int32, nL int32, DoF int32, xyz []vec3, L []float64, Le []float64, J1 []int32, J2 []int32, Ax []float32, Asy []float32, Asz []float32, Iy []float32, Iz []float32, E []float32, G []float32, p []float32, d []float32, gX []float32, gY []float32, gZ []float32, r []int32, shear int32, nF []int32, nU []int32, nW []int32, nP []int32, nT []int32, nD []int32, Q [][]float64, F_temp [][]float64, F_mech [][]float64, Fo []float64, U [][][]float32, W [][][]float32, P [][][]float32, T [][][]float32, Dp [][]float32, eqF_mech [][][]float64, eqF_temp [][][]float64, verbose int32) {
	//
	// * READ_AND_ASSEMBLE_LOADS
	// * Read load information data, assemble load vectors in global coordinates
	// * Returns vector of equivalent loadal forces F_temp and F_mech and
	// * a matrix of equivalent element end forces eqF_temp and eqF_mech from
	// * distributed internal and temperature loadings.
	// * eqF_temp and eqF_mech are computed for the global coordinate system
	// * 2008-09-09, 2015-05-15
	//
	// equivalent mech loads, global coord
	// equivalent temp loads, global coord
	// section dimensions in local coords
	var hy float32
	var hz float32
	var x1 float32
	var x2 float32
	var w1 float32
	var w2 float32
	var Ln float64
	var R1o float64
	var R2o float64
	var f01 float64
	var f02 float64
	// equivalent element end forces from distributed and thermal loads
	var Nx1 float64
	var Vy1 float64
	var Vz1 float64
	var Mx1 float64
	var My1 float64
	var Mz1 float64
	var Nx2 float64
	var Vy2 float64
	var Vz2 float64
	var Mx2 float64
	var My2 float64
	var Mz2 float64
	// shear deformatn coefficients
	var Ksy float64
	var Ksz float64
	var a float64
	var b float64
	var t1 float64
	var t2 float64
	var t3 float64
	var t4 float64
	var t5 float64
	var t6 float64
	var t7 float64
	var t8 float64
	var t9 float64
	// point load locations
	// 3D coord Xfrm coeffs
	var i int32
	var j int32
	var l int32
	var lc int32
	var n int32
	var n1 int32
	var n2 int32
	// *scanf return value
	var sfrv int32
	var errMsg []byte = make([]byte, 512)
	{
		// initialize load data vectors and matrices to zero
		for j = 1; j <= DoF; j++ {
			Fo[j] = 0
		}
	}
	for j = 1; j <= DoF; j++ {
		for lc = 1; lc <= nL; lc++ {
			F_mech[lc][j] = 0
			F_temp[lc][j] = F_mech[lc][j]
		}
	}
	for i = 1; i <= 12; i++ {
		for n = 1; n <= nE; n++ {
			for lc = 1; lc <= nL; lc++ {
				eqF_temp[lc][n][i] = 0
				eqF_mech[lc][n][i] = eqF_temp[lc][n][i]
			}
		}
	}
	for i = 1; i <= DoF; i++ {
		for lc = 1; lc <= nL; lc++ {
			Dp[lc][i] = float32(0)
		}
	}
	for i = 1; i <= nE; i++ {
		for j = 1; j <= 12; j++ {
			Q[i][j] = 0
		}
	}
	{
		// begin load-case loop
		for lc = 1; lc <= nL; lc++ {
			if verbose != 0 {
				//  display the load case number
				textColor('y', 'g', 'b', 'x')
				noarch.Fprintf(noarch.Stdout, []byte(" load case %d of %d: \x00"), lc, nL)
				noarch.Fprintf(noarch.Stdout, []byte("                                            \x00"))
				noarch.Fflush(noarch.Stdout)
				color(0)
				noarch.Fprintf(noarch.Stdout, []byte("\n\x00"))
			}
			// gravity loads applied uniformly to all frame elements -------
			sfrv = noarch.Fscanf(fp, []byte("%f %f %f\x00"), gX[lc:], gY[lc:], gZ[lc:])
			if sfrv != 3 {
				sferr([]byte("gX gY gZ values in load data\x00"))
			}
			for n = 1; n <= nE; n++ {
				n1 = J1[n]
				n2 = J2[n]
				coord_trans(xyz, L[n], n1, n2, c4goUnsafeConvert_float64(&t1), c4goUnsafeConvert_float64(&t2), c4goUnsafeConvert_float64(&t3), c4goUnsafeConvert_float64(&t4), c4goUnsafeConvert_float64(&t5), c4goUnsafeConvert_float64(&t6), c4goUnsafeConvert_float64(&t7), c4goUnsafeConvert_float64(&t8), c4goUnsafeConvert_float64(&t9), p[n])
				eqF_mech[lc][n][1] = float64(d[n]*Ax[n])*L[n]*float64(gX[lc])/2
				eqF_mech[lc][n][2] = float64(d[n]*Ax[n])*L[n]*float64(gY[lc])/2
				eqF_mech[lc][n][3] = float64(d[n]*Ax[n])*L[n]*float64(gZ[lc])/2
				eqF_mech[lc][n][4] = float64(d[n]*Ax[n])*L[n]*L[n]/12*((-t4*t8+t5*t7)*float64(gY[lc])+(-t4*t9+t6*t7)*float64(gZ[lc]))
				eqF_mech[lc][n][5] = float64(d[n]*Ax[n])*L[n]*L[n]/12*((-t5*t7+t4*t8)*float64(gX[lc])+(-t5*t9+t6*t8)*float64(gZ[lc]))
				eqF_mech[lc][n][6] = float64(d[n]*Ax[n])*L[n]*L[n]/12*((-t6*t7+t4*t9)*float64(gX[lc])+(-t6*t8+t5*t9)*float64(gY[lc]))
				eqF_mech[lc][n][7] = float64(d[n]*Ax[n])*L[n]*float64(gX[lc])/2
				eqF_mech[lc][n][8] = float64(d[n]*Ax[n])*L[n]*float64(gY[lc])/2
				eqF_mech[lc][n][9] = float64(d[n]*Ax[n])*L[n]*float64(gZ[lc])/2
				eqF_mech[lc][n][10] = float64(d[n]*Ax[n])*L[n]*L[n]/12*((t4*t8-t5*t7)*float64(gY[lc])+(t4*t9-t6*t7)*float64(gZ[lc]))
				eqF_mech[lc][n][11] = float64(d[n]*Ax[n])*L[n]*L[n]/12*((t5*t7-t4*t8)*float64(gX[lc])+(t5*t9-t6*t8)*float64(gZ[lc]))
				eqF_mech[lc][n][12] = float64(d[n]*Ax[n])*L[n]*L[n]/12*((t6*t7-t4*t9)*float64(gX[lc])+(t6*t8-t5*t9)*float64(gY[lc]))
			}
			// debugging ... check eqF data
			//  printf("n=%d ", n);
			//  for (l=1;l<=12;l++) {
			//   if (eqF_mech[lc][n][l] != 0)
			//      printf(" eqF %d = %9.2e ", l, eqF_mech[lc][n][l] );
			//  }
			//  printf("\n");
			//
			// end gravity loads
			// node point loads --------------------------------------------
			sfrv = noarch.Fscanf(fp, []byte("%d\x00"), nF[lc:])
			if sfrv != 1 {
				sferr([]byte("nF value in load data\x00"))
			}
			if verbose != 0 {
				noarch.Fprintf(noarch.Stdout, []byte("  number of loaded nodes \x00"))
				dots(noarch.Stdout, 28)
				noarch.Fprintf(noarch.Stdout, []byte(" nF = %3d\n\x00"), nF[lc])
			}
			{
				// ! global structural coordinates !
				for i = 1; i <= nF[lc]; i++ {
					sfrv = noarch.Fscanf(fp, []byte("%d\x00"), c4goUnsafeConvert_int32(&j))
					if sfrv != 1 {
						sferr([]byte("node value in point load data\x00"))
					}
					if j < 1 || j > nN {
						noarch.Sprintf(errMsg, []byte("\n  error in node load data: node number out of range ... Node : %d\n   Perhaps you did not specify %d node loads \n  or perhaps the Input Data file is missing expected data.\n\x00"), j, nF[lc])
						errorMsg(errMsg)
						unix.Exit(121)
					}
					for l = 5; l >= 0; l-- {
						sfrv = noarch.Fscanf(fp, []byte("%f\x00\x00"), F_mech[lc][6*j-l:])
						if sfrv != 1 {
							sferr([]byte("force value in point load data\x00"))
						}
					}
					if F_mech[lc][6*j-5] == 0 && F_mech[lc][6*j-4] == 0 && F_mech[lc][6*j-3] == 0 && F_mech[lc][6*j-2] == 0 && F_mech[lc][6*j-1] == 0 && F_mech[lc][6*j] == 0 {
						noarch.Fprintf(noarch.Stderr, []byte("\n   Warning: All node loads applied at node %d  are zero\n\x00"), j)
					}
				}
			}
			// end node point loads
			// uniformly distributed loads ---------------------------------
			sfrv = noarch.Fscanf(fp, []byte("%d\x00"), nU[lc:])
			if sfrv != 1 {
				sferr([]byte("nU value in uniform load data\x00"))
			}
			if verbose != 0 {
				noarch.Fprintf(noarch.Stdout, []byte("  number of uniformly distributed loads \x00"))
				dots(noarch.Stdout, 13)
				noarch.Fprintf(noarch.Stdout, []byte(" nU = %3d\n\x00"), nU[lc])
			}
			if nU[lc] < 0 || nU[lc] > nE {
				noarch.Fprintf(noarch.Stderr, []byte("  number of uniformly distributed loads \x00"))
				dots(noarch.Stderr, 13)
				noarch.Fprintf(noarch.Stderr, []byte(" nU = %3d\n\x00"), nU[lc])
				noarch.Sprintf(errMsg, []byte("\n  error: valid ranges for nU is 0 ... %d \n\x00"), nE)
				errorMsg(errMsg)
				unix.Exit(131)
			}
			{
				// ! local element coordinates !
				for i = 1; i <= nU[lc]; i++ {
					sfrv = noarch.Fscanf(fp, []byte("%d\x00"), c4goUnsafeConvert_int32(&n))
					if sfrv != 1 {
						sferr([]byte("frame element number in uniform load data\x00"))
					}
					if n < 1 || n > nE {
						noarch.Sprintf(errMsg, []byte("\n  error in uniform distributed loads: element number %d is out of range\n\x00"), n)
						errorMsg(errMsg)
						unix.Exit(132)
					}
					U[lc][i][1] = float32(float64(n))
					for l = 2; l <= 4; l++ {
						sfrv = noarch.Fscanf(fp, []byte("%f\x00"), U[lc][i][l:])
						if sfrv != 1 {
							sferr([]byte("load value in uniform load data\x00"))
						}
					}
					if U[lc][i][2] == 0 && U[lc][i][3] == 0 && U[lc][i][4] == 0 {
						noarch.Fprintf(noarch.Stderr, []byte("\n   Warning: All distributed loads applied to frame element %d  are zero\n\x00"), n)
					}
					Nx2 = float64(U[lc][i][2])*Le[n]/2
					Nx1 = Nx2
					Vy2 = float64(U[lc][i][3])*Le[n]/2
					Vy1 = Vy2
					Vz2 = float64(U[lc][i][4])*Le[n]/2
					Vz1 = Vz2
					Mx2 = 0
					Mx1 = Mx2
					My1 = float64(-U[lc][i][4])*Le[n]*Le[n]/12
					My2 = -My1
					Mz1 = float64(U[lc][i][3])*Le[n]*Le[n]/12
					Mz2 = -Mz1
					// debugging ... check end force values
					//   * printf("n=%d Vy=%9.2e Vz=%9.2e My=%9.2e Mz=%9.2e\n",
					//   *    n, Vy1,Vz1, My1,Mz1 );
					//
					n1 = J1[n]
					n2 = J2[n]
					coord_trans(xyz, L[n], n1, n2, c4goUnsafeConvert_float64(&t1), c4goUnsafeConvert_float64(&t2), c4goUnsafeConvert_float64(&t3), c4goUnsafeConvert_float64(&t4), c4goUnsafeConvert_float64(&t5), c4goUnsafeConvert_float64(&t6), c4goUnsafeConvert_float64(&t7), c4goUnsafeConvert_float64(&t8), c4goUnsafeConvert_float64(&t9), p[n])
					// debugging ... check coordinate transform coefficients
					//  printf("t1=%5.2f t2=%5.2f t3=%5.2f \n", t1, t2, t3 );
					//  printf("t4=%5.2f t5=%5.2f t6=%5.2f \n", t4, t5, t6 );
					//  printf("t7=%5.2f t8=%5.2f t9=%5.2f \n", t7, t8, t9 );
					//
					// {F} = [T]'{Q}
					eqF_mech[lc][n][1] += Nx1*t1+Vy1*t4+Vz1*t7
					eqF_mech[lc][n][2] += Nx1*t2+Vy1*t5+Vz1*t8
					eqF_mech[lc][n][3] += Nx1*t3+Vy1*t6+Vz1*t9
					eqF_mech[lc][n][4] += Mx1*t1+My1*t4+Mz1*t7
					eqF_mech[lc][n][5] += Mx1*t2+My1*t5+Mz1*t8
					eqF_mech[lc][n][6] += Mx1*t3+My1*t6+Mz1*t9
					eqF_mech[lc][n][7] += Nx2*t1+Vy2*t4+Vz2*t7
					eqF_mech[lc][n][8] += Nx2*t2+Vy2*t5+Vz2*t8
					eqF_mech[lc][n][9] += Nx2*t3+Vy2*t6+Vz2*t9
					eqF_mech[lc][n][10] += Mx2*t1+My2*t4+Mz2*t7
					eqF_mech[lc][n][11] += Mx2*t2+My2*t5+Mz2*t8
					eqF_mech[lc][n][12] += Mx2*t3+My2*t6+Mz2*t9
				}
			}
			// debugging ... check eqF values
			//  printf("n=%d ", n);
			//  for (l=1;l<=12;l++) {
			//   if (eqF_mech[lc][n][l] != 0)
			//      printf(" eqF %d = %9.2e ", l, eqF_mech[lc][n][l] );
			//  }
			//  printf("\n");
			//
			// end uniformly distributed loads
			// trapezoidally distributed loads -----------------------------
			sfrv = noarch.Fscanf(fp, []byte("%d\x00"), nW[lc:])
			if sfrv != 1 {
				sferr([]byte("nW value in load data\x00"))
			}
			if verbose != 0 {
				noarch.Fprintf(noarch.Stdout, []byte("  number of trapezoidally distributed loads \x00"))
				dots(noarch.Stdout, 9)
				noarch.Fprintf(noarch.Stdout, []byte(" nW = %3d\n\x00"), nW[lc])
			}
			if nW[lc] < 0 || nW[lc] > 10*nE {
				noarch.Sprintf(errMsg, []byte("\n  error: valid ranges for nW is 0 ... %d \n\x00"), 10*nE)
				errorMsg(errMsg)
				unix.Exit(140)
			}
			{
				// ! local element coordinates !
				for i = 1; i <= nW[lc]; i++ {
					sfrv = noarch.Fscanf(fp, []byte("%d\x00"), c4goUnsafeConvert_int32(&n))
					if sfrv != 1 {
						sferr([]byte("frame element number in trapezoidal load data\x00"))
					}
					if n < 1 || n > nE {
						noarch.Sprintf(errMsg, []byte("\n  error in trapezoidally-distributed loads: element number %d is out of range\n\x00"), n)
						errorMsg(errMsg)
						unix.Exit(141)
					}
					W[lc][i][1] = float32(float64(n))
					for l = 2; l <= 13; l++ {
						sfrv = noarch.Fscanf(fp, []byte("%f\x00"), W[lc][i][l:])
						if sfrv != 1 {
							sferr([]byte("value in trapezoidal load data\x00"))
						}
					}
					Ln = L[n]
					if W[lc][i][4] == 0 && W[lc][i][5] == 0 && W[lc][i][8] == 0 && W[lc][i][9] == 0 && W[lc][i][12] == 0 && W[lc][i][13] == 0 {
						// error checking
						noarch.Fprintf(noarch.Stderr, []byte("\n   Warning: All trapezoidal loads applied to frame element %d  are zero\n\x00"), n)
						noarch.Fprintf(noarch.Stderr, []byte("     load case: %d , element %d , load %d\n \x00"), lc, n, i)
					}
					if W[lc][i][2] < 0 {
						noarch.Sprintf(errMsg, []byte("\n   error in x-axis trapezoidal loads, load case: %d , element %d , load %d\n  starting location = %f < 0\n\x00"), lc, n, i, float64(W[lc][i][2]))
						errorMsg(errMsg)
						unix.Exit(142)
					}
					if W[lc][i][2] > W[lc][i][3] {
						noarch.Sprintf(errMsg, []byte("\n   error in x-axis trapezoidal loads, load case: %d , element %d , load %d\n  starting location = %f > ending location = %f \n\x00"), lc, n, i, float64(W[lc][i][2]), float64(W[lc][i][3]))
						errorMsg(errMsg)
						unix.Exit(143)
					}
					if float64(W[lc][i][3]) > Ln {
						noarch.Sprintf(errMsg, []byte("\n   error in x-axis trapezoidal loads, load case: %d , element %d , load %d\n ending location = %f > L (%f) \n\x00"), lc, n, i, float64(W[lc][i][3]), Ln)
						errorMsg(errMsg)
						unix.Exit(144)
					}
					if W[lc][i][6] < 0 {
						noarch.Sprintf(errMsg, []byte("\n   error in y-axis trapezoidal loads, load case: %d , element %d , load %d\n starting location = %f < 0\n\x00"), lc, n, i, float64(W[lc][i][6]))
						errorMsg(errMsg)
						unix.Exit(142)
					}
					if W[lc][i][6] > W[lc][i][7] {
						noarch.Sprintf(errMsg, []byte("\n   error in y-axis trapezoidal loads, load case: %d , element %d , load %d\n starting location = %f > ending location = %f \n\x00"), lc, n, i, float64(W[lc][i][6]), float64(W[lc][i][7]))
						errorMsg(errMsg)
						unix.Exit(143)
					}
					if float64(W[lc][i][7]) > Ln {
						noarch.Sprintf(errMsg, []byte("\n   error in y-axis trapezoidal loads, load case: %d , element %d , load %d\n ending location = %f > L (%f) \n\x00"), lc, n, i, float64(W[lc][i][7]), Ln)
						errorMsg(errMsg)
						unix.Exit(144)
					}
					if W[lc][i][10] < 0 {
						noarch.Sprintf(errMsg, []byte("\n   error in z-axis trapezoidal loads, load case: %d , element %d , load %d\n starting location = %f < 0\n\x00"), lc, n, i, float64(W[lc][i][10]))
						errorMsg(errMsg)
						unix.Exit(142)
					}
					if W[lc][i][10] > W[lc][i][11] {
						noarch.Sprintf(errMsg, []byte("\n   error in z-axis trapezoidal loads, load case: %d , element %d , load %d\n starting location = %f > ending location = %f \n\x00"), lc, n, i, float64(W[lc][i][10]), float64(W[lc][i][11]))
						errorMsg(errMsg)
						unix.Exit(143)
					}
					if float64(W[lc][i][11]) > Ln {
						noarch.Sprintf(errMsg, []byte("\n   error in z-axis trapezoidal loads, load case: %d , element %d , load %d\n ending location = %f > L (%f) \n\x00"), lc, n, i, float64(W[lc][i][11]), Ln)
						errorMsg(errMsg)
						unix.Exit(144)
					}
					if shear != 0 {
						Ksy = 12*float64(E[n])*float64(Iz[n])/(float64(G[n]*Asy[n])*Le[n]*Le[n])
						Ksz = 12*float64(E[n])*float64(Iy[n])/(float64(G[n]*Asz[n])*Le[n]*Le[n])
					} else {
						Ksz = 0
						Ksy = Ksz
					}
					// x-axis trapezoidal loads (along the frame element length)
					x1 = W[lc][i][2]
					x2 = W[lc][i][3]
					w1 = W[lc][i][4]
					w2 = W[lc][i][5]
					Nx1 = (3*float64(w1+w2)*Ln*float64(x2-x1)-(2*float64(w2)+float64(w1))*float64(x2)*float64(x2)+float64((w2-w1)*x2*x1)+(2*float64(w1)+float64(w2))*float64(x1)*float64(x1))/(6*Ln)
					Nx2 = (-(2*float64(w1)+float64(w2))*float64(x1)*float64(x1)+(2*float64(w2)+float64(w1))*float64(x2)*float64(x2)-float64((w2-w1)*x1*x2))/(6*Ln)
					// y-axis trapezoidal loads (across the frame element length)
					x1 = W[lc][i][6]
					x2 = W[lc][i][7]
					w1 = W[lc][i][8]
					w2 = W[lc][i][9]
					R1o = ((2*float64(w1)+float64(w2))*float64(x1)*float64(x1)-(float64(w1)+2*float64(w2))*float64(x2)*float64(x2)+3*float64(w1+w2)*Ln*float64(x2-x1)-float64((w1-w2)*x1*x2))/(6*Ln)
					R2o = ((float64(w1)+2*float64(w2))*float64(x2)*float64(x2)+float64((w1-w2)*x1*x2)-(2*float64(w1)+float64(w2))*float64(x1)*float64(x1))/(6*Ln)
					f01 = (3*(float64(w2)+4*float64(w1))*float64(x1)*float64(x1)*float64(x1)*float64(x1)-3*(float64(w1)+4*float64(w2))*float64(x2)*float64(x2)*float64(x2)*float64(x2)-15*(float64(w2)+3*float64(w1))*Ln*float64(x1)*float64(x1)*float64(x1)+15*(float64(w1)+3*float64(w2))*Ln*float64(x2)*float64(x2)*float64(x2)-3*float64(w1-w2)*float64(x1)*float64(x2)*float64(x1*x1+x2*x2)+20*(float64(w2)+2*float64(w1))*Ln*Ln*float64(x1)*float64(x1)-20*(float64(w1)+2*float64(w2))*Ln*Ln*float64(x2)*float64(x2)+15*float64(w1-w2)*Ln*float64(x1)*float64(x2)*float64(x1+x2)-3*float64(w1-w2)*float64(x1)*float64(x1)*float64(x2)*float64(x2)-20*float64(w1-w2)*Ln*Ln*float64(x1)*float64(x2))/360
					f02 = (3*(float64(w2)+4*float64(w1))*float64(x1)*float64(x1)*float64(x1)*float64(x1)-3*(float64(w1)+4*float64(w2))*float64(x2)*float64(x2)*float64(x2)*float64(x2)-3*float64(w1-w2)*float64(x1)*float64(x2)*float64(x1*x1+x2*x2)-10*(float64(w2)+2*float64(w1))*Ln*Ln*float64(x1)*float64(x1)+10*(float64(w1)+2*float64(w2))*Ln*Ln*float64(x2)*float64(x2)-3*float64(w1-w2)*float64(x1)*float64(x1)*float64(x2)*float64(x2)+10*float64(w1-w2)*Ln*Ln*float64(x1)*float64(x2))/360
					Mz1 = -(4*f01+2*f02+Ksy*(f01-f02))/(Ln*Ln*(1+Ksy))
					Mz2 = -(2*f01+4*f02-Ksy*(f01-f02))/(Ln*Ln*(1+Ksy))
					Vy1 = R1o+Mz1/Ln+Mz2/Ln
					Vy2 = R2o-Mz1/Ln-Mz2/Ln
					// z-axis trapezoidal loads (across the frame element length)
					x1 = W[lc][i][10]
					x2 = W[lc][i][11]
					w1 = W[lc][i][12]
					w2 = W[lc][i][13]
					R1o = ((2*float64(w1)+float64(w2))*float64(x1)*float64(x1)-(float64(w1)+2*float64(w2))*float64(x2)*float64(x2)+3*float64(w1+w2)*Ln*float64(x2-x1)-float64((w1-w2)*x1*x2))/(6*Ln)
					R2o = ((float64(w1)+2*float64(w2))*float64(x2)*float64(x2)+float64((w1-w2)*x1*x2)-(2*float64(w1)+float64(w2))*float64(x1)*float64(x1))/(6*Ln)
					f01 = (3*(float64(w2)+4*float64(w1))*float64(x1)*float64(x1)*float64(x1)*float64(x1)-3*(float64(w1)+4*float64(w2))*float64(x2)*float64(x2)*float64(x2)*float64(x2)-15*(float64(w2)+3*float64(w1))*Ln*float64(x1)*float64(x1)*float64(x1)+15*(float64(w1)+3*float64(w2))*Ln*float64(x2)*float64(x2)*float64(x2)-3*float64(w1-w2)*float64(x1)*float64(x2)*float64(x1*x1+x2*x2)+20*(float64(w2)+2*float64(w1))*Ln*Ln*float64(x1)*float64(x1)-20*(float64(w1)+2*float64(w2))*Ln*Ln*float64(x2)*float64(x2)+15*float64(w1-w2)*Ln*float64(x1)*float64(x2)*float64(x1+x2)-3*float64(w1-w2)*float64(x1)*float64(x1)*float64(x2)*float64(x2)-20*float64(w1-w2)*Ln*Ln*float64(x1)*float64(x2))/360
					f02 = (3*(float64(w2)+4*float64(w1))*float64(x1)*float64(x1)*float64(x1)*float64(x1)-3*(float64(w1)+4*float64(w2))*float64(x2)*float64(x2)*float64(x2)*float64(x2)-3*float64(w1-w2)*float64(x1)*float64(x2)*float64(x1*x1+x2*x2)-10*(float64(w2)+2*float64(w1))*Ln*Ln*float64(x1)*float64(x1)+10*(float64(w1)+2*float64(w2))*Ln*Ln*float64(x2)*float64(x2)-3*float64(w1-w2)*float64(x1)*float64(x1)*float64(x2)*float64(x2)+10*float64(w1-w2)*Ln*Ln*float64(x1)*float64(x2))/360
					My1 = (4*f01+2*f02+Ksz*(f01-f02))/(Ln*Ln*(1+Ksz))
					My2 = (2*f01+4*f02-Ksz*(f01-f02))/(Ln*Ln*(1+Ksz))
					Vz1 = R1o-My1/Ln-My2/Ln
					Vz2 = R2o+My1/Ln+My2/Ln
					// debugging ... check internal force values
					//  printf("n=%d\n Nx1=%9.3f\n Nx2=%9.3f\n Vy1=%9.3f\n Vy2=%9.3f\n Vz1=%9.3f\n Vz2=%9.3f\n My1=%9.3f\n My2=%9.3f\n Mz1=%9.3f\n Mz2=%9.3f\n",
					//    n, Nx1,Nx2,Vy1,Vy2,Vz1,Vz2, My1,My2,Mz1,Mz2 );
					//
					n1 = J1[n]
					n2 = J2[n]
					coord_trans(xyz, Ln, n1, n2, c4goUnsafeConvert_float64(&t1), c4goUnsafeConvert_float64(&t2), c4goUnsafeConvert_float64(&t3), c4goUnsafeConvert_float64(&t4), c4goUnsafeConvert_float64(&t5), c4goUnsafeConvert_float64(&t6), c4goUnsafeConvert_float64(&t7), c4goUnsafeConvert_float64(&t8), c4goUnsafeConvert_float64(&t9), p[n])
					// debugging ... check coordinate transformation coefficients
					//  printf("t1=%5.2f t2=%5.2f t3=%5.2f \n", t1, t2, t3 );
					//  printf("t4=%5.2f t5=%5.2f t6=%5.2f \n", t4, t5, t6 );
					//  printf("t7=%5.2f t8=%5.2f t9=%5.2f \n", t7, t8, t9 );
					//
					// {F} = [T]'{Q}
					eqF_mech[lc][n][1] += Nx1*t1+Vy1*t4+Vz1*t7
					eqF_mech[lc][n][2] += Nx1*t2+Vy1*t5+Vz1*t8
					eqF_mech[lc][n][3] += Nx1*t3+Vy1*t6+Vz1*t9
					eqF_mech[lc][n][4] += Mx1*t1+My1*t4+Mz1*t7
					eqF_mech[lc][n][5] += Mx1*t2+My1*t5+Mz1*t8
					eqF_mech[lc][n][6] += Mx1*t3+My1*t6+Mz1*t9
					eqF_mech[lc][n][7] += Nx2*t1+Vy2*t4+Vz2*t7
					eqF_mech[lc][n][8] += Nx2*t2+Vy2*t5+Vz2*t8
					eqF_mech[lc][n][9] += Nx2*t3+Vy2*t6+Vz2*t9
					eqF_mech[lc][n][10] += Mx2*t1+My2*t4+Mz2*t7
					eqF_mech[lc][n][11] += Mx2*t2+My2*t5+Mz2*t8
					eqF_mech[lc][n][12] += Mx2*t3+My2*t6+Mz2*t9
				}
			}
			// debugging ... check eqF data
			//  for (l=1;l<=13;l++) printf(" %9.2e ", W[lc][i][l] );
			//  printf("\n");
			//  printf("n=%d ", n);
			//  for (l=1;l<=12;l++) {
			//   if (eqF_mech[lc][n][l] != 0)
			//      printf(" eqF %d = %9.3f ", l, eqF_mech[lc][n][l] );
			//  }
			//  printf("\n");
			//
			// end trapezoidally distributed loads
			// internal element point loads --------------------------------
			sfrv = noarch.Fscanf(fp, []byte("%d\x00"), nP[lc:])
			if sfrv != 1 {
				sferr([]byte("nP value load data\x00"))
			}
			if verbose != 0 {
				noarch.Fprintf(noarch.Stdout, []byte("  number of concentrated frame element point loads \x00"))
				dots(noarch.Stdout, 2)
				noarch.Fprintf(noarch.Stdout, []byte(" nP = %3d\n\x00"), nP[lc])
			}
			if nP[lc] < 0 || nP[lc] > 10*nE {
				noarch.Fprintf(noarch.Stderr, []byte("  number of concentrated frame element point loads \x00"))
				dots(noarch.Stderr, 3)
				noarch.Fprintf(noarch.Stderr, []byte(" nP = %3d\n\x00"), nP[lc])
				noarch.Sprintf(errMsg, []byte("\n  error: valid ranges for nP is 0 ... %d \n\x00"), 10*nE)
				errorMsg(errMsg)
				unix.Exit(150)
			}
			{
				// ! local element coordinates !
				for i = 1; i <= nP[lc]; i++ {
					sfrv = noarch.Fscanf(fp, []byte("%d\x00"), c4goUnsafeConvert_int32(&n))
					if sfrv != 1 {
						sferr([]byte("frame element number value point load data\x00"))
					}
					if n < 1 || n > nE {
						noarch.Sprintf(errMsg, []byte("\n   error in internal point loads: frame element number %d is out of range\n\x00"), n)
						errorMsg(errMsg)
						unix.Exit(151)
					}
					P[lc][i][1] = float32(float64(n))
					for l = 2; l <= 5; l++ {
						sfrv = noarch.Fscanf(fp, []byte("%f\x00"), P[lc][i][l:])
						if sfrv != 1 {
							sferr([]byte("value in point load data\x00"))
						}
					}
					a = float64(P[lc][i][5])
					b = L[n]-a
					if a < 0 || L[n] < a || b < 0 || L[n] < b {
						noarch.Sprintf(errMsg, []byte("\n  error in point load data: Point load coord. out of range\n   Frame element number: %d  L: %f  load coord.: %f\n\x00\x00\x00"), n, L[n], float64(P[lc][i][5]))
						errorMsg(errMsg)
						unix.Exit(152)
					}
					if shear != 0 {
						Ksy = 12*float64(E[n])*float64(Iz[n])/(float64(G[n]*Asy[n])*Le[n]*Le[n])
						Ksz = 12*float64(E[n])*float64(Iy[n])/(float64(G[n]*Asz[n])*Le[n]*Le[n])
					} else {
						Ksz = 0
						Ksy = Ksz
					}
					Ln = L[n]
					Nx1 = float64(P[lc][i][2])*a/Ln
					Nx2 = float64(P[lc][i][2])*b/Ln
					Vy1 = 1/(1+Ksz)*float64(P[lc][i][3])*b*b*(3*a+b)/(Ln*Ln*Ln)+Ksz/(1+Ksz)*float64(P[lc][i][3])*b/Ln
					Vy2 = 1/(1+Ksz)*float64(P[lc][i][3])*a*a*(3*b+a)/(Ln*Ln*Ln)+Ksz/(1+Ksz)*float64(P[lc][i][3])*a/Ln
					Vz1 = 1/(1+Ksy)*float64(P[lc][i][4])*b*b*(3*a+b)/(Ln*Ln*Ln)+Ksy/(1+Ksy)*float64(P[lc][i][4])*b/Ln
					Vz2 = 1/(1+Ksy)*float64(P[lc][i][4])*a*a*(3*b+a)/(Ln*Ln*Ln)+Ksy/(1+Ksy)*float64(P[lc][i][4])*a/Ln
					Mx2 = 0
					Mx1 = Mx2
					My1 = -(1/(1+Ksy))*float64(P[lc][i][4])*a*b*b/(Ln*Ln)-Ksy/(1+Ksy)*float64(P[lc][i][4])*a*b/(2*Ln)
					My2 = 1/(1+Ksy)*float64(P[lc][i][4])*a*a*b/(Ln*Ln)+Ksy/(1+Ksy)*float64(P[lc][i][4])*a*b/(2*Ln)
					Mz1 = 1/(1+Ksz)*float64(P[lc][i][3])*a*b*b/(Ln*Ln)+Ksz/(1+Ksz)*float64(P[lc][i][3])*a*b/(2*Ln)
					Mz2 = -(1/(1+Ksz))*float64(P[lc][i][3])*a*a*b/(Ln*Ln)-Ksz/(1+Ksz)*float64(P[lc][i][3])*a*b/(2*Ln)
					n1 = J1[n]
					n2 = J2[n]
					coord_trans(xyz, Ln, n1, n2, c4goUnsafeConvert_float64(&t1), c4goUnsafeConvert_float64(&t2), c4goUnsafeConvert_float64(&t3), c4goUnsafeConvert_float64(&t4), c4goUnsafeConvert_float64(&t5), c4goUnsafeConvert_float64(&t6), c4goUnsafeConvert_float64(&t7), c4goUnsafeConvert_float64(&t8), c4goUnsafeConvert_float64(&t9), p[n])
					// {F} = [T]'{Q}
					eqF_mech[lc][n][1] += Nx1*t1+Vy1*t4+Vz1*t7
					eqF_mech[lc][n][2] += Nx1*t2+Vy1*t5+Vz1*t8
					eqF_mech[lc][n][3] += Nx1*t3+Vy1*t6+Vz1*t9
					eqF_mech[lc][n][4] += Mx1*t1+My1*t4+Mz1*t7
					eqF_mech[lc][n][5] += Mx1*t2+My1*t5+Mz1*t8
					eqF_mech[lc][n][6] += Mx1*t3+My1*t6+Mz1*t9
					eqF_mech[lc][n][7] += Nx2*t1+Vy2*t4+Vz2*t7
					eqF_mech[lc][n][8] += Nx2*t2+Vy2*t5+Vz2*t8
					eqF_mech[lc][n][9] += Nx2*t3+Vy2*t6+Vz2*t9
					eqF_mech[lc][n][10] += Mx2*t1+My2*t4+Mz2*t7
					eqF_mech[lc][n][11] += Mx2*t2+My2*t5+Mz2*t8
					eqF_mech[lc][n][12] += Mx2*t3+My2*t6+Mz2*t9
				}
			}
			// end element point loads
			// thermal loads -----------------------------------------------
			sfrv = noarch.Fscanf(fp, []byte("%d\x00"), nT[lc:])
			if sfrv != 1 {
				sferr([]byte("nT value in load data\x00"))
			}
			if verbose != 0 {
				noarch.Fprintf(noarch.Stdout, []byte("  number of temperature changes \x00"))
				dots(noarch.Stdout, 21)
				noarch.Fprintf(noarch.Stdout, []byte(" nT = %3d\n\x00"), nT[lc])
			}
			if nT[lc] < 0 || nT[lc] > nE {
				noarch.Fprintf(noarch.Stderr, []byte("  number of temperature changes \x00"))
				dots(noarch.Stderr, 21)
				noarch.Fprintf(noarch.Stderr, []byte(" nT = %3d\n\x00"), nT[lc])
				noarch.Sprintf(errMsg, []byte("\n  error: valid ranges for nT is 0 ... %d \n\x00"), nE)
				errorMsg(errMsg)
				unix.Exit(160)
			}
			{
				// ! local element coordinates !
				for i = 1; i <= nT[lc]; i++ {
					sfrv = noarch.Fscanf(fp, []byte("%d\x00"), c4goUnsafeConvert_int32(&n))
					if sfrv != 1 {
						sferr([]byte("frame element number in temperature load data\x00"))
					}
					if n < 1 || n > nE {
						noarch.Sprintf(errMsg, []byte("\n  error in temperature loads: frame element number %d is out of range\n\x00"), n)
						errorMsg(errMsg)
						unix.Exit(161)
					}
					T[lc][i][1] = float32(float64(n))
					for l = 2; l <= 8; l++ {
						sfrv = noarch.Fscanf(fp, []byte("%f\x00"), T[lc][i][l:])
						if sfrv != 1 {
							sferr([]byte("value in temperature load data\x00"))
						}
					}
					a = float64(T[lc][i][2])
					hy = T[lc][i][3]
					hz = T[lc][i][4]
					if hy < 0 || hz < 0 {
						noarch.Sprintf(errMsg, []byte("\n  error in thermal load data: section dimension < 0\n   Frame element number: %d  hy: %f  hz: %f\n\x00"), n, float64(hy), float64(hz))
						errorMsg(errMsg)
						unix.Exit(162)
					}
					Nx2 = a*(1/4)*float64(T[lc][i][5]+T[lc][i][6]+T[lc][i][7]+T[lc][i][8])*float64(E[n])*float64(Ax[n])
					Nx1 = -Nx2
					Vz2 = 0
					Vz1 = Vz2
					Vy2 = Vz1
					Vy1 = Vy2
					Mx2 = 0
					Mx1 = Mx2
					My1 = a/float64(hz)*float64(T[lc][i][8]-T[lc][i][7])*float64(E[n])*float64(Iy[n])
					My2 = -My1
					Mz1 = a/float64(hy)*float64(T[lc][i][5]-T[lc][i][6])*float64(E[n])*float64(Iz[n])
					Mz2 = -Mz1
					n1 = J1[n]
					n2 = J2[n]
					coord_trans(xyz, L[n], n1, n2, c4goUnsafeConvert_float64(&t1), c4goUnsafeConvert_float64(&t2), c4goUnsafeConvert_float64(&t3), c4goUnsafeConvert_float64(&t4), c4goUnsafeConvert_float64(&t5), c4goUnsafeConvert_float64(&t6), c4goUnsafeConvert_float64(&t7), c4goUnsafeConvert_float64(&t8), c4goUnsafeConvert_float64(&t9), p[n])
					// {F} = [T]'{Q}
					eqF_temp[lc][n][1] += Nx1*t1+Vy1*t4+Vz1*t7
					eqF_temp[lc][n][2] += Nx1*t2+Vy1*t5+Vz1*t8
					eqF_temp[lc][n][3] += Nx1*t3+Vy1*t6+Vz1*t9
					eqF_temp[lc][n][4] += Mx1*t1+My1*t4+Mz1*t7
					eqF_temp[lc][n][5] += Mx1*t2+My1*t5+Mz1*t8
					eqF_temp[lc][n][6] += Mx1*t3+My1*t6+Mz1*t9
					eqF_temp[lc][n][7] += Nx2*t1+Vy2*t4+Vz2*t7
					eqF_temp[lc][n][8] += Nx2*t2+Vy2*t5+Vz2*t8
					eqF_temp[lc][n][9] += Nx2*t3+Vy2*t6+Vz2*t9
					eqF_temp[lc][n][10] += Mx2*t1+My2*t4+Mz2*t7
					eqF_temp[lc][n][11] += Mx2*t2+My2*t5+Mz2*t8
					eqF_temp[lc][n][12] += Mx2*t3+My2*t6+Mz2*t9
				}
			}
			{
				// end thermal loads
				// debugging ...  check eqF's prior to asembly
				//   for (n=1; n<=nE; n++) {
				//                           printf("n=%d ", n);
				//                           for (l=1;l<=12;l++) {
				//                            if (eqF_mech[lc][n][l] != 0)
				//                               printf(" eqF %d = %9.2e ", l, eqF_mech[lc][n][l] );
				//                           }
				//                           printf("\n");
				//   }
				//
				// assemble all element equivalent loads into
				// separate load vectors for mechanical and thermal loading
				for n = 1; n <= nE; n++ {
					n1 = J1[n]
					n2 = J2[n]
					for i = 1; i <= 6; i++ {
						F_mech[lc][6*n1-6+i] += eqF_mech[lc][n][i]
					}
					for i = 7; i <= 12; i++ {
						F_mech[lc][6*n2-12+i] += eqF_mech[lc][n][i]
					}
					for i = 1; i <= 6; i++ {
						F_temp[lc][6*n1-6+i] += eqF_temp[lc][n][i]
					}
					for i = 7; i <= 12; i++ {
						F_temp[lc][6*n2-12+i] += eqF_temp[lc][n][i]
					}
				}
			}
			// prescribed displacements ------------------------------------
			sfrv = noarch.Fscanf(fp, []byte("%d\x00"), nD[lc:])
			if sfrv != 1 {
				sferr([]byte("nD value in load data\x00"))
			}
			if verbose != 0 {
				noarch.Fprintf(noarch.Stdout, []byte("  number of prescribed displacements \x00"))
				dots(noarch.Stdout, 16)
				noarch.Fprintf(noarch.Stdout, []byte(" nD = %3d\n\x00"), nD[lc])
			}
			for i = 1; i <= nD[lc]; i++ {
				sfrv = noarch.Fscanf(fp, []byte("%d\x00"), c4goUnsafeConvert_int32(&j))
				if sfrv != 1 {
					sferr([]byte("node number value in prescribed displacement data\x00"))
				}
				for l = 5; l >= 0; l-- {
					sfrv = noarch.Fscanf(fp, []byte("%f\x00"), Dp[lc][6*j-l:])
					if sfrv != 1 {
						sferr([]byte("prescribed displacement value\x00"))
					}
					if r[6*j-l] == 0 && float64(Dp[lc][6*j-l]) != 0 {
						noarch.Sprintf(errMsg, []byte(" Initial displacements can be prescribed only at restrained coordinates\n  node: %d  dof: %d  r: %d\n\x00"), j, 6-l, r[6*j-l])
						errorMsg(errMsg)
						unix.Exit(171)
					}
				}
			}
		}
	}
	// end load-case loop
}
// read_mass_data - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:1463
func read_mass_data(fp *noarch.File, OUT_file []byte, nN int32, nE int32, nI []int32, nX []int32, d []float32, EMs []float32, NMs []float32, NMx []float32, NMy []float32, NMz []float32, L []float64, Ax []float32, total_mass []float64, struct_mass []float64, nM []int32, Mmethod []int32, modal_flag int32, lump []int32, lump_flag int32, tol []float64, tol_flag float64, shift []float64, shift_flag float64, exagg_modal []float64, modepath []byte, anim []int32, pan []float32, pan_flag float32, verbose int32, debug int32) {
	//
	// * READ_MASS_DATA  -  read element densities and extra inertial mass data 16aug01
	//
	// double ms = 0.0;
	var i int32
	var j int32
	var jnt int32
	var m int32
	var b int32
	var nA int32
	var full_len int32
	var len_ int32
	// *scanf return value
	var sfrv int32
	var base_file []byte = []byte("EMPTY_BASE\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00")
	var mode_file []byte = []byte("EMPTY_MODE\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00")
	var errMsg []byte = make([]byte, 512)
	struct_mass[0] = 0
	total_mass[0] = struct_mass[0]
	sfrv = noarch.Fscanf(fp, []byte("%d\x00"), nM)
	if sfrv != 1 {
		sferr([]byte("nM value in mass data\x00"))
	}
	if verbose != 0 {
		noarch.Fprintf(noarch.Stdout, []byte(" number of dynamic modes \x00"))
		dots(noarch.Stdout, 28)
		noarch.Fprintf(noarch.Stdout, []byte(" nM = %3d\n\x00"), nM[0])
	}
	if nM[0] < 1 || sfrv != 1 {
		nM[0] = 0
		return
	}
	sfrv = noarch.Fscanf(fp, []byte("%d\x00"), Mmethod)
	if sfrv != 1 {
		sferr([]byte("Mmethod value in mass data\x00"))
	}
	if modal_flag != -1 {
		Mmethod[0] = modal_flag
	}
	if verbose != 0 {
		noarch.Fprintf(noarch.Stdout, []byte(" modal analysis method \x00"))
		dots(noarch.Stdout, 30)
		noarch.Fprintf(noarch.Stdout, []byte(" %3d \x00"), Mmethod[0])
		if Mmethod[0] == 1 {
			noarch.Fprintf(noarch.Stdout, []byte(" (Subspace-Jacobi)\n\x00"))
		}
		if Mmethod[0] == 2 {
			noarch.Fprintf(noarch.Stdout, []byte(" (Stodola)\n\x00"))
		}
	}
	sfrv = noarch.Fscanf(fp, []byte("%d\x00"), lump)
	if sfrv != 1 {
		sferr([]byte("lump value in mass data\x00"))
	}
	sfrv = noarch.Fscanf(fp, []byte("%f\x00\x00"), tol)
	if sfrv != 1 {
		sferr([]byte("tol value in mass data\x00"))
	}
	sfrv = noarch.Fscanf(fp, []byte("%f\x00\x00"), shift)
	if sfrv != 1 {
		sferr([]byte("shift value in mass data\x00"))
	}
	sfrv = noarch.Fscanf(fp, []byte("%f\x00\x00"), exagg_modal)
	if sfrv != 1 {
		sferr([]byte("exagg_modal value in mass data\x00"))
	}
	if lump_flag != -1 {
		lump[0] = lump_flag
	}
	if tol_flag != -1 {
		tol[0] = tol_flag
	}
	if shift_flag != -1 {
		shift[0] = shift_flag
	}
	// number of nodes with extra inertias
	sfrv = noarch.Fscanf(fp, []byte("%d\x00"), nI)
	if sfrv != 1 {
		sferr([]byte("nI value in mass data\x00"))
	}
	if verbose != 0 {
		noarch.Fprintf(noarch.Stdout, []byte(" number of nodes with extra lumped inertia \x00"))
		dots(noarch.Stdout, 10)
		noarch.Fprintf(noarch.Stdout, []byte(" nI = %3d\n\x00"), nI[0])
	}
	for j = 1; j <= nI[0]; j++ {
		sfrv = noarch.Fscanf(fp, []byte("%d\x00"), c4goUnsafeConvert_int32(&jnt))
		if sfrv != 1 {
			sferr([]byte("node value in extra node mass data\x00"))
		}
		if jnt < 1 || jnt > nN {
			noarch.Sprintf(errMsg, []byte("\n  error in node mass data: node number out of range    Node : %d  \n   Perhaps you did not specify %d extra masses \n   or perhaps the Input Data file is missing expected data.\n\x00"), jnt, nI[0])
			errorMsg(errMsg)
			unix.Exit(86)
		}
		sfrv = noarch.Fscanf(fp, []byte("%f %f %f %f\x00"), NMs[jnt:], NMx[jnt:], NMy[jnt:], NMz[jnt:])
		if sfrv != 4 {
			sferr([]byte("node inertia in extra mass data\x00"))
		}
		total_mass[0] += float64(NMs[jnt])
		if NMs[jnt] == 0 && NMx[jnt] == 0 && NMy[jnt] == 0 && NMz[jnt] == 0 {
			noarch.Fprintf(noarch.Stderr, []byte("\n  Warning: All extra node inertia at node %d  are zero\n\x00"), jnt)
		}
	}
	// number of frame elements with extra beam mass
	sfrv = noarch.Fscanf(fp, []byte("%d\x00"), nX)
	if sfrv != 1 {
		sferr([]byte("nX value in mass data\x00"))
	}
	if verbose != 0 {
		noarch.Fprintf(noarch.Stdout, []byte(" number of frame elements with extra mass \x00"))
		dots(noarch.Stdout, 11)
		noarch.Fprintf(noarch.Stdout, []byte(" nX = %3d\n\x00"), nX[0])
		if sfrv != 1 {
			sferr([]byte("element value in extra element mass data\x00"))
		}
	}
	for m = 1; m <= nX[0]; m++ {
		sfrv = noarch.Fscanf(fp, []byte("%d\x00"), c4goUnsafeConvert_int32(&b))
		if sfrv != 1 {
			sferr([]byte("element number in extra element mass data\x00"))
		}
		if b < 1 || b > nE {
			noarch.Sprintf(errMsg, []byte("\n  error in element mass data: element number out of range   Element: %d  \n   Perhaps you did not specify %d extra masses \n   or perhaps the Input Data file is missing expected data.\n\x00"), b, nX[0])
			errorMsg(errMsg)
			unix.Exit(87)
		}
		sfrv = noarch.Fscanf(fp, []byte("%f\x00"), EMs[b:])
		if sfrv != 1 {
			sferr([]byte("extra element mass value in mass data\x00"))
		}
	}
	{
		// calculate the total mass and the structural mass
		for b = 1; b <= nE; b++ {
			total_mass[0] += float64(d[b]*Ax[b])*L[b]+float64(EMs[b])
			struct_mass[0] += float64(d[b]*Ax[b])*L[b]
		}
	}
	{
		// check inertia data
		for m = 1; m <= nE; m++ {
			if float64(d[m]) < 0 || float64(EMs[m]) < 0 || float64(d[m]+EMs[m]) <= 0 {
				noarch.Sprintf(errMsg, []byte("\n  error: Non-positive mass or density\n  d[%d]= %f  EMs[%d]= %f\n\x00"), m, float64(d[m]), m, float64(EMs[m]))
				errorMsg(errMsg)
				unix.Exit(88)
			}
		}
	}
	if verbose != 0 {
		// for (m=1;m<=nE;m++) ms += EMs[m]; // consistent mass doesn't agree
		// if ( ms > 0.0 )     *lump = 1;    // with concentrated masses, EMs
		noarch.Fprintf(noarch.Stdout, []byte(" structural mass \x00"))
		dots(noarch.Stdout, 36)
		noarch.Fprintf(noarch.Stdout, []byte("  %12.4e\n\x00"), struct_mass[0])
		noarch.Fprintf(noarch.Stdout, []byte(" total mass \x00"))
		dots(noarch.Stdout, 41)
		noarch.Fprintf(noarch.Stdout, []byte("  %12.4e\n\x00"), total_mass[0])
	}
	sfrv = noarch.Fscanf(fp, []byte("%d\x00"), c4goUnsafeConvert_int32(&nA))
	if sfrv != 1 {
		sferr([]byte("nA value in mode animation data\x00"))
	}
	if verbose != 0 {
		noarch.Fprintf(noarch.Stdout, []byte(" number of modes to be animated \x00"))
		dots(noarch.Stdout, 21)
		noarch.Fprintf(noarch.Stdout, []byte(" nA = %3d\n\x00"), nA)
	}
	if nA > 20 {
		noarch.Fprintf(noarch.Stderr, []byte(" nA = %d, only 100 or fewer modes may be animated\n\x00"), nA)
	}
	for m = 0; m < 20; m++ {
		anim[m] = 0
	}
	for m = 1; m <= nA; m++ {
		sfrv = noarch.Fscanf(fp, []byte("%d\x00"), anim[m:])
		if sfrv != 1 {
			sferr([]byte("mode number in mode animation data\x00"))
		}
	}
	sfrv = noarch.Fscanf(fp, []byte("%f\x00"), pan)
	if sfrv != 1 {
		sferr([]byte("pan value in mode animation data\x00"))
	}
	if float64(pan_flag) != -1 {
		pan[0] = pan_flag
	}
	if verbose != 0 {
		noarch.Fprintf(noarch.Stdout, []byte(" pan rate \x00"))
		dots(noarch.Stdout, 43)
		noarch.Fprintf(noarch.Stdout, []byte(" %8.3f\n\x00"), float64(pan[0]))
	}
	noarch.Strcpy(base_file, OUT_file)
	for int32(base_file[func() int32 {
		defer func() {
			len_ ++
		}()
		return len_
	}()]) != int32('\x00') {
	}
	// the length of the base_file
	full_len = len_
	for int32(base_file[func() int32 {
		defer func() {
			len_ --
		}()
		return len_
	}()]) != int32('.') && len_ > 0 {
	}
	if len_ == 0 {
		// find the last '.' in base_file
		len_ = full_len
	}
	// end base_file at the last '.'
	base_file[func() int32 {
		len_ ++
		return len_
	}()] = '\x00'
	for int32(base_file[len_]) != int32('/') && int32(base_file[len_]) != int32('\\') && len_ > 0 {
		// find the last '/' or '\' in base_file
		len_ --
	}
	i = 0
	for int32(base_file[len_]) != int32('\x00') {
		mode_file[func() int32 {
			defer func() {
				i ++
			}()
			return i
		}()] = base_file[func() int32 {
			defer func() {
				len_ ++
			}()
			return len_
		}()]
	}
	mode_file[i] = '\x00'
	noarch.Strcat(mode_file, []byte("-m\x00"))
	output_path(mode_file, modepath, 512, nil)
}
// read_condensation_data - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:1666
func read_condensation_data(fp *noarch.File, nN int32, nM int32, nC []int32, Cdof []int32, Cmethod []int32, condense_flag int32, c []int32, m []int32, verbose int32) {
	//
	// * READ_CONDENSE   -  read matrix condensation information          30aug01
	//
	var i int32
	var j int32
	var k int32
	var cm [][]int32
	// *scanf return value
	var sfrv int32
	var errMsg []byte = make([]byte, 512)
	Cdof[0] = 0
	nC[0] = Cdof[0]
	Cmethod[0] = nC[0]
	if (func() int32 {
		sfrv = noarch.Fscanf(fp, []byte("%d\x00"), Cmethod)
		return sfrv
	}()) != 1 {
		Cdof[0] = 0
		nC[0] = Cdof[0]
		Cmethod[0] = nC[0]
		if verbose != 0 {
			noarch.Fprintf(noarch.Stdout, []byte(" missing matrix condensation data \n\x00"))
		}
		return
	}
	if condense_flag != -1 {
		Cmethod[0] = condense_flag
	}
	if Cmethod[0] <= 0 {
		if verbose != 0 {
			noarch.Fprintf(noarch.Stdout, []byte(" Cmethod = %d : no matrix condensation \n\x00"), Cmethod[0])
		}
		Cdof[0] = 0
		nC[0] = Cdof[0]
		Cmethod[0] = nC[0]
		return
	}
	if Cmethod[0] > 3 {
		// default
		Cmethod[0] = 1
	}
	if verbose != 0 {
		noarch.Fprintf(noarch.Stdout, []byte(" condensation method \x00"))
		dots(noarch.Stdout, 32)
		noarch.Fprintf(noarch.Stdout, []byte(" %d \x00"), Cmethod[0])
		if Cmethod[0] == 1 {
			noarch.Fprintf(noarch.Stdout, []byte(" (static only) \n\x00"))
		}
		if Cmethod[0] == 2 {
			noarch.Fprintf(noarch.Stdout, []byte(" (Guyan) \n\x00"))
		}
		if Cmethod[0] == 3 {
			noarch.Fprintf(noarch.Stdout, []byte(" (dynamic) \n\x00"))
		}
	}
	if (func() int32 {
		sfrv = noarch.Fscanf(fp, []byte("%d\x00"), nC)
		return sfrv
	}()) != 1 {
		Cdof[0] = 0
		nC[0] = Cdof[0]
		Cmethod[0] = nC[0]
		if verbose != 0 {
			noarch.Fprintf(noarch.Stdout, []byte(" missing matrix condensation data \n\x00"))
		}
		return
	}
	if verbose != 0 {
		noarch.Fprintf(noarch.Stdout, []byte(" number of nodes with condensed DoF's \x00"))
		dots(noarch.Stdout, 15)
		noarch.Fprintf(noarch.Stdout, []byte(" nC = %3d\n\x00"), nC[0])
	}
	if nC[0] > nN {
		noarch.Sprintf(errMsg, []byte("\n  error in matrix condensation data: \n error: nC > nN ... nC=%d; nN=%d;\n The number of nodes with condensed DoF's may not exceed the total number of nodes.\n\x00"), nC[0], nN)
		errorMsg(errMsg)
		unix.Exit(90)
	}
	cm = imatrix(1, nC[0], 1, 7)
	for i = 1; i <= nC[0]; i++ {
		sfrv = noarch.Fscanf(fp, []byte("%d %d %d %d %d %d %d\x00"), cm[i][1:], cm[i][2:], cm[i][3:], cm[i][4:], cm[i][5:], cm[i][6:], cm[i][7:])
		if sfrv != 7 {
			sferr([]byte("DoF numbers in condensation data\x00"))
		}
		if cm[i][1] < 1 || cm[i][1] > nN {
			// error check
			noarch.Sprintf(errMsg, []byte("\n  error in matrix condensation data: \n  condensed node number out of range\n  cj[%d] = %d  ... nN = %d  \n\x00"), i, cm[i][1], nN)
			errorMsg(errMsg)
			unix.Exit(91)
		}
	}
	for i = 1; i <= nC[0]; i++ {
		for j = 2; j <= 7; j++ {
			if cm[i][j] != 0 {
				Cdof[0] ++
			}
		}
	}
	k = 1
	for i = 1; i <= nC[0]; i++ {
		for j = 2; j <= 7; j++ {
			if cm[i][j] != 0 {
				c[k] = 6*(cm[i][1]-1)+j-1
				k ++
			}
		}
	}
	for i = 1; i <= Cdof[0]; i++ {
		sfrv = noarch.Fscanf(fp, []byte("%d\x00"), m[i:])
		if sfrv != 1 && Cmethod[0] == 3 {
			sferr([]byte("mode number in condensation data\x00"))
			noarch.Sprintf(errMsg, []byte("condensed mode %d = %d\x00"), i, m[i])
			errorMsg(errMsg)
		}
		if (m[i] < 0 || m[i] > nM) && Cmethod[0] == 3 {
			noarch.Sprintf(errMsg, []byte("\n  error in matrix condensation data: \n  m[%d] = %d \n The condensed mode number must be between   1 and %d (modes).\n\x00"), i, m[i], nM)
			errorMsg(errMsg)
			unix.Exit(92)
		}
	}
	free_imatrix(cm, 1, nC[0], 1, 7)
}
// write_input_data - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:1771
func write_input_data(fp *noarch.File, title []byte, nN int32, nE int32, nL int32, nD []int32, nR int32, nF []int32, nU []int32, nW []int32, nP []int32, nT []int32, xyz []vec3, r []float32, J1 []int32, J2 []int32, Ax []float32, Asy []float32, Asz []float32, Jx []float32, Iy []float32, Iz []float32, E []float32, G []float32, p []float32, d []float32, gX []float32, gY []float32, gZ []float32, Ft [][]float64, Fm [][]float64, Dp [][]float32, R []int32, U [][][]float32, W [][][]float32, P [][][]float32, T [][][]float32, shear int32, anlyz int32, geom int32) {
	//
	// * WRITE_INPUT_DATA  -  save input data     07nov02
	//
	var i int32
	var j int32
	var n int32
	var lc int32
	// modern time variable type
	var now noarch.TimeT
	_ = noarch.Time((*[1000000]noarch.TimeT)(unsafe.Pointer(&now))[:])
	for i = 1; i <= 80; i++ {
		noarch.Fprintf(fp, []byte("_\x00"))
	}
	noarch.Fprintf(fp, []byte("\nFrame3DD version: %s \x00"), []byte("20140514+\x00"))
	//frame3dd.sf.net/\n");
	noarch.Fprintf(fp, []byte("              http://frame3dd.sf.net/\n\x00"))
	noarch.Fprintf(fp, []byte("GPL Copyright (C) 1992-2015, Henri P. Gavin \n\x00"))
	noarch.Fprintf(fp, []byte("Frame3DD is distributed in the hope that it will be useful\x00"))
	noarch.Fprintf(fp, []byte(" but with no warranty.\n\x00"))
	noarch.Fprintf(fp, []byte("For details see the GNU Public Licence:\x00"))
	//www.fsf.org/copyleft/gpl.html\n");
	noarch.Fprintf(fp, []byte(" http://www.fsf.org/copyleft/gpl.html\n\x00"))
	for i = 1; i <= 80; i++ {
		noarch.Fprintf(fp, []byte("_\x00"))
	}
	noarch.Fprintf(fp, []byte("\n\n\x00"))
	noarch.Fprintf(fp, []byte("%s\n\x00"), title)
	noarch.Fprintf(fp, []byte("%s\x00"), noarch.Ctime((*[1000000]noarch.TimeT)(unsafe.Pointer(&now))[:]))
	for i = 1; i <= 80; i++ {
		noarch.Fprintf(fp, []byte("_\x00"))
	}
	noarch.Fprintf(fp, []byte("\n\x00"))
	noarch.Fprintf(fp, []byte("In 2D problems the Y-axis is vertical.  \x00"))
	noarch.Fprintf(fp, []byte("In 3D problems the Z-axis is vertical.\n\x00"))
	for i = 1; i <= 80; i++ {
		noarch.Fprintf(fp, []byte("_\x00"))
	}
	noarch.Fprintf(fp, []byte("\n\x00"))
	noarch.Fprintf(fp, []byte("%5d NODES          \x00"), nN)
	noarch.Fprintf(fp, []byte("%5d FIXED NODES    \x00"), nR)
	noarch.Fprintf(fp, []byte("%5d FRAME ELEMENTS \x00"), nE)
	noarch.Fprintf(fp, []byte("%3d LOAD CASES   \n\x00"), nL)
	for i = 1; i <= 80; i++ {
		noarch.Fprintf(fp, []byte("_\x00"))
	}
	noarch.Fprintf(fp, []byte("\n\x00"))
	noarch.Fprintf(fp, []byte("N O D E   D A T A       \x00"))
	noarch.Fprintf(fp, []byte("                                    R E S T R A I N T S\n\x00"))
	noarch.Fprintf(fp, []byte("  Node       X              Y              Z\x00"))
	noarch.Fprintf(fp, []byte("         radius  Fx Fy Fz Mx My Mz\n\x00"))
	for i = 1; i <= nN; i++ {
		j = 6*(i-1)
		noarch.Fprintf(fp, []byte("%5d %14.6f %14.6f %14.6f %8.3f  %2d %2d %2d %2d %2d %2d\n\x00"), i, xyz[i].x, xyz[i].y, xyz[i].z, float64(r[i]), R[j+1], R[j+2], R[j+3], R[j+4], R[j+5], R[j+6])
	}
	noarch.Fprintf(fp, []byte("F R A M E   E L E M E N T   D A T A\t\t\t\t\t(local)\n\x00"))
	noarch.Fprintf(fp, []byte("  Elmnt  J1    J2     Ax   Asy   Asz    \x00"))
	noarch.Fprintf(fp, []byte("Jxx     Iyy     Izz       E       G roll  density\n\x00"))
	for i = 1; i <= nE; i++ {
		noarch.Fprintf(fp, []byte("%5d %5d %5d %6.1f %5.1f %5.1f\x00"), i, J1[i], J2[i], float64(Ax[i]), float64(Asy[i]), float64(Asz[i]))
		noarch.Fprintf(fp, []byte(" %6.1f %7.1f %7.1f %8.1f %7.1f %3.0f %8.2e\n\x00"), float64(Jx[i]), float64(Iy[i]), float64(Iz[i]), float64(E[i]), float64(G[i]), float64(p[i])*180/3.141592653589793, float64(d[i]))
	}
	if shear != 0 {
		noarch.Fprintf(fp, []byte("  Include shear deformations.\n\x00"))
	} else {
		noarch.Fprintf(fp, []byte("  Neglect shear deformations.\n\x00"))
	}
	if geom != 0 {
		noarch.Fprintf(fp, []byte("  Include geometric stiffness.\n\x00"))
	} else {
		noarch.Fprintf(fp, []byte("  Neglect geometric stiffness.\n\x00"))
	}
	{
		// start load case loop
		for lc = 1; lc <= nL; lc++ {
			noarch.Fprintf(fp, []byte("\nL O A D   C A S E   %d   O F   %d  ... \n\n\x00"), lc, nL)
			noarch.Fprintf(fp, []byte("   Gravity X = \x00"))
			if gX[lc] == 0 {
				noarch.Fprintf(fp, []byte(" 0.0 \x00"))
			} else {
				noarch.Fprintf(fp, []byte(" %.3f \x00"), float64(gX[lc]))
			}
			noarch.Fprintf(fp, []byte("   Gravity Y = \x00"))
			if gY[lc] == 0 {
				noarch.Fprintf(fp, []byte(" 0.0 \x00"))
			} else {
				noarch.Fprintf(fp, []byte(" %.3f \x00"), float64(gY[lc]))
			}
			noarch.Fprintf(fp, []byte("   Gravity Z = \x00"))
			if gZ[lc] == 0 {
				noarch.Fprintf(fp, []byte(" 0.0 \x00"))
			} else {
				noarch.Fprintf(fp, []byte(" %.3f \x00"), float64(gZ[lc]))
			}
			noarch.Fprintf(fp, []byte("\n\x00"))
			noarch.Fprintf(fp, []byte(" %3d concentrated loads\n\x00"), nF[lc])
			noarch.Fprintf(fp, []byte(" %3d uniformly distributed loads\n\x00"), nU[lc])
			noarch.Fprintf(fp, []byte(" %3d trapezoidally distributed loads\n\x00"), nW[lc])
			noarch.Fprintf(fp, []byte(" %3d concentrated point loads\n\x00"), nP[lc])
			noarch.Fprintf(fp, []byte(" %3d temperature loads\n\x00"), nT[lc])
			noarch.Fprintf(fp, []byte(" %3d prescribed displacements\n\x00"), nD[lc])
			if nF[lc] > 0 || nU[lc] > 0 || nW[lc] > 0 || nP[lc] > 0 || nT[lc] > 0 {
				noarch.Fprintf(fp, []byte(" N O D A L   L O A D S\x00"))
				noarch.Fprintf(fp, []byte("  +  E Q U I V A L E N T   N O D A L   L O A D S  (global)\n\x00"))
				noarch.Fprintf(fp, []byte("  Node        Fx          Fy          Fz\x00"))
				noarch.Fprintf(fp, []byte("          Mxx         Myy         Mzz\n\x00"))
				for j = 1; j <= nN; j++ {
					i = 6*(j-1)
					if Fm[lc][i+1] != 0 || Fm[lc][i+2] != 0 || Fm[lc][i+3] != 0 || Fm[lc][i+4] != 0 || Fm[lc][i+5] != 0 || Fm[lc][i+6] != 0 {
						noarch.Fprintf(fp, []byte(" %5d\x00"), j)
						for i = 5; i >= 0; i-- {
							noarch.Fprintf(fp, []byte(" %11.3f\x00"), Fm[lc][6*j-i])
						}
						noarch.Fprintf(fp, []byte("\n\x00"))
					}
				}
			}
			if nU[lc] > 0 {
				noarch.Fprintf(fp, []byte(" U N I F O R M   L O A D S\x00"))
				noarch.Fprintf(fp, []byte("\t\t\t\t\t\t(local)\n\x00"))
				noarch.Fprintf(fp, []byte("  Elmnt       Ux               Uy               Uz\n\x00"))
				for n = 1; n <= nU[lc]; n++ {
					noarch.Fprintf(fp, []byte(" %5d\x00"), int32(U[lc][n][1]))
					for i = 2; i <= 4; i++ {
						noarch.Fprintf(fp, []byte(" %16.8f\x00"), float64(U[lc][n][i]))
					}
					noarch.Fprintf(fp, []byte("\n\x00"))
				}
			}
			if nW[lc] > 0 {
				noarch.Fprintf(fp, []byte(" T R A P E Z O I D A L   L O A D S\x00"))
				noarch.Fprintf(fp, []byte("\t\t\t\t\t(local)\n\x00"))
				noarch.Fprintf(fp, []byte("  Elmnt       x1               x2               W1               W2\n\x00"))
				for n = 1; n <= nW[lc]; n++ {
					noarch.Fprintf(fp, []byte(" %5d\x00"), int32(W[lc][n][1]))
					for i = 2; i <= 5; i++ {
						noarch.Fprintf(fp, []byte(" %16.8f\x00"), float64(W[lc][n][i]))
					}
					noarch.Fprintf(fp, []byte("  (x)\n\x00"))
					noarch.Fprintf(fp, []byte(" %5d\x00"), int32(W[lc][n][1]))
					for i = 6; i <= 9; i++ {
						noarch.Fprintf(fp, []byte(" %16.8f\x00"), float64(W[lc][n][i]))
					}
					noarch.Fprintf(fp, []byte("  (y)\n\x00"))
					noarch.Fprintf(fp, []byte(" %5d\x00"), int32(W[lc][n][1]))
					for i = 10; i <= 13; i++ {
						noarch.Fprintf(fp, []byte(" %16.8f\x00"), float64(W[lc][n][i]))
					}
					noarch.Fprintf(fp, []byte("  (z)\n\x00"))
				}
			}
			if nP[lc] > 0 {
				noarch.Fprintf(fp, []byte(" C O N C E N T R A T E D   P O I N T   L O A D S\x00"))
				noarch.Fprintf(fp, []byte("\t\t\t\t(local)\n\x00"))
				noarch.Fprintf(fp, []byte("  Elmnt       Px          Py          Pz          x\n\x00"))
				for n = 1; n <= nP[lc]; n++ {
					noarch.Fprintf(fp, []byte(" %5d\x00"), int32(P[lc][n][1]))
					for i = 2; i <= 5; i++ {
						noarch.Fprintf(fp, []byte(" %11.3f\x00"), float64(P[lc][n][i]))
					}
					noarch.Fprintf(fp, []byte("\n\x00"))
				}
			}
			if nT[lc] > 0 {
				noarch.Fprintf(fp, []byte(" T E M P E R A T U R E   C H A N G E S\x00"))
				noarch.Fprintf(fp, []byte("\t\t\t\t\t(local)\n\x00"))
				noarch.Fprintf(fp, []byte("  Elmnt     coef      hy        hz\x00"))
				noarch.Fprintf(fp, []byte("        Ty+       Ty-       Tz+       Tz-\n\x00"))
				for n = 1; n <= nT[lc]; n++ {
					noarch.Fprintf(fp, []byte(" %5d\x00"), int32(T[lc][n][1]))
					noarch.Fprintf(fp, []byte(" %9.2e\x00"), float64(T[lc][n][2]))
					for i = 3; i <= 8; i++ {
						noarch.Fprintf(fp, []byte(" %9.3f\x00"), float64(T[lc][n][i]))
					}
					noarch.Fprintf(fp, []byte("\n\x00"))
				}
			}
			if nD[lc] > 0 {
				noarch.Fprintf(fp, []byte("\n P R E S C R I B E D   D I S P L A C E M E N T S\x00"))
				noarch.Fprintf(fp, []byte("                        (global)\n\x00"))
				noarch.Fprintf(fp, []byte("  Node        Dx          Dy          Dz\x00"))
				noarch.Fprintf(fp, []byte("          Dxx         Dyy         Dzz\n\x00"))
				for j = 1; j <= nN; j++ {
					i = 6*(j-1)
					if float64(Dp[lc][i+1]) != 0 || float64(Dp[lc][i+2]) != 0 || float64(Dp[lc][i+3]) != 0 || float64(Dp[lc][i+4]) != 0 || float64(Dp[lc][i+5]) != 0 || float64(Dp[lc][i+6]) != 0 {
						noarch.Fprintf(fp, []byte(" %5d\x00"), j)
						for i = 5; i >= 0; i-- {
							noarch.Fprintf(fp, []byte(" %11.3f\x00"), float64(Dp[lc][6*j-i]))
						}
						noarch.Fprintf(fp, []byte("\n\x00"))
					}
				}
			}
		}
	}
	if anlyz != 0 {
		// end load case loop
		noarch.Fprintf(fp, []byte("\nE L A S T I C   S T I F F N E S S   A N A L Y S I S\x00"))
		noarch.Fprintf(fp, []byte("   via  L D L'  decomposition\n\n\x00"))
	} else {
		noarch.Fprintf(fp, []byte("D A T A   C H E C K   O N L Y\n\x00"))
	}
	noarch.Fflush(fp)
}
// write_static_results - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:1962
func write_static_results(fp *noarch.File, nN int32, nE int32, nL int32, lc int32, DoF int32, J1 []int32, J2 []int32, F []float64, D []float64, R []float64, r []int32, Q [][]float64, err float64, ok int32, axial_sign int32) {
	//
	// * WRITE_STATIC_RESULTS -  save node displacements and frame element end forces
	// * 09 Sep 2008 , 2015-05-15
	//
	var disp float64
	var i int32
	var j int32
	var n int32
	if ok < 0 {
		noarch.Fprintf(fp, []byte("  * The Stiffness Matrix is not positive-definite *\n\x00"))
		noarch.Fprintf(fp, []byte("    Check that all six rigid-body translations are restrained\n\x00"))
		noarch.Fprintf(fp, []byte("    If geometric stiffness is included, reduce the loads.\n\x00"))
	}
	//  return;
	noarch.Fprintf(fp, []byte("\nL O A D   C A S E   %d   O F   %d  ... \n\n\x00"), lc, nL)
	noarch.Fprintf(fp, []byte("N O D E   D I S P L A C E M E N T S  \x00"))
	noarch.Fprintf(fp, []byte("\t\t\t\t\t(global)\n\x00"))
	noarch.Fprintf(fp, []byte("  Node    X-dsp       Y-dsp       Z-dsp\x00"))
	noarch.Fprintf(fp, []byte("       X-rot       Y-rot       Z-rot\n\x00"))
	for j = 1; j <= nN; j++ {
		disp = 0
		for i = 5; i >= 0; i-- {
			disp += math.Abs(D[6*j-i])
		}
		if disp > 0 {
			noarch.Fprintf(fp, []byte(" %5d\x00"), j)
			for i = 5; i >= 0; i-- {
				if math.Abs(D[6*j-i]) < 1e-08 {
					noarch.Fprintf(fp, []byte("    0.0     \x00"))
				} else {
					noarch.Fprintf(fp, []byte(" %11.6f\x00"), D[6*j-i])
				}
			}
			noarch.Fprintf(fp, []byte("\n\x00"))
		}
	}
	noarch.Fprintf(fp, []byte("F R A M E   E L E M E N T   E N D   F O R C E S\x00"))
	noarch.Fprintf(fp, []byte("\t\t\t\t(local)\n\x00"))
	noarch.Fprintf(fp, []byte("  Elmnt  Node       Nx          Vy         Vz\x00"))
	noarch.Fprintf(fp, []byte("        Txx        Myy        Mzz\n\x00"))
	for n = 1; n <= nE; n++ {
		noarch.Fprintf(fp, []byte(" %5d  %5d\x00"), n, J1[n])
		if math.Abs(Q[n][1]) < 0.0001 {
			noarch.Fprintf(fp, []byte("      0.0   \x00"))
		} else {
			noarch.Fprintf(fp, []byte(" %10.3f\x00"), Q[n][1])
		}
		if Q[n][1] >= 0.0001 && axial_sign != 0 {
			noarch.Fprintf(fp, []byte("c\x00"))
		}
		if Q[n][1] <= -0.0001 && axial_sign != 0 {
			noarch.Fprintf(fp, []byte("t\x00"))
		}
		if noarch.Not(axial_sign) {
			noarch.Fprintf(fp, []byte(" \x00"))
		}
		for i = 2; i <= 6; i++ {
			if math.Abs(Q[n][i]) < 0.0001 {
				noarch.Fprintf(fp, []byte("      0.0  \x00"))
			} else {
				noarch.Fprintf(fp, []byte(" %10.3f\x00"), Q[n][i])
			}
		}
		noarch.Fprintf(fp, []byte("\n\x00"))
		noarch.Fprintf(fp, []byte(" %5d  %5d\x00"), n, J2[n])
		if math.Abs(Q[n][7]) < 0.0001 {
			noarch.Fprintf(fp, []byte("      0.0   \x00"))
		} else {
			noarch.Fprintf(fp, []byte(" %10.3f\x00"), Q[n][7])
		}
		if Q[n][7] >= 0.0001 && axial_sign != 0 {
			noarch.Fprintf(fp, []byte("t\x00"))
		}
		if Q[n][7] <= -0.0001 && axial_sign != 0 {
			noarch.Fprintf(fp, []byte("c\x00"))
		}
		if noarch.Not(axial_sign) {
			noarch.Fprintf(fp, []byte(" \x00"))
		}
		for i = 8; i <= 12; i++ {
			if math.Abs(Q[n][i]) < 0.0001 {
				noarch.Fprintf(fp, []byte("      0.0  \x00"))
			} else {
				noarch.Fprintf(fp, []byte(" %10.3f\x00"), Q[n][i])
			}
		}
		noarch.Fprintf(fp, []byte("\n\x00"))
	}
	noarch.Fprintf(fp, []byte("R E A C T I O N S\t\t\t\t\t\t\t(global)\n\x00"))
	noarch.Fprintf(fp, []byte("  Node        Fx          Fy          Fz\x00"))
	noarch.Fprintf(fp, []byte("         Mxx         Myy         Mzz\n\x00"))
	for j = 1; j <= nN; j++ {
		i = 6*(j-1)
		if r[i+1] != 0 || r[i+2] != 0 || r[i+3] != 0 || r[i+4] != 0 || r[i+5] != 0 || r[i+6] != 0 {
			noarch.Fprintf(fp, []byte(" %5d\x00"), j)
			for i = 5; i >= 0; i-- {
				if r[6*j-i] != 0 {
					noarch.Fprintf(fp, []byte(" %11.3f\x00"), R[6*j-i])
				} else {
					noarch.Fprintf(fp, []byte("       0.0  \x00"))
				}
			}
			noarch.Fprintf(fp, []byte("\n\x00"))
		}
	}
	noarch.Fprintf(fp, []byte("R M S    R E L A T I V E    E Q U I L I B R I U M    E R R O R: %9.3e\n\x00"), err)
	noarch.Fflush(fp)
}
// CSV_filename - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:2056
func CSV_filename(CSV_file []byte, wa []byte, OUT_file []byte, lc int32) {
	//
	// * CSV_filename - return the file name for the .CSV file and
	// * whether the file should be written or appended (wa)
	// * 1 Nov 2015
	//
	var i int32
	var j int32
	i = 0
	j = 0
	for i < 128 {
		CSV_file[j] = OUT_file[i]
		if int32(CSV_file[j]) == int32('+') || int32(CSV_file[j]) == int32('-') || int32(CSV_file[j]) == int32('*') || int32(CSV_file[j]) == int32('^') || int32(CSV_file[j]) == int32('.') || int32(CSV_file[j]) == int32('\x00') {
			CSV_file[j] = '_'
			break
		}
		i ++
		j ++
	}
	CSV_file[func() int32 {
		j ++
		return j
	}()] = '\x00'
	noarch.Strcat(CSV_file, []byte("out.CSV\x00"))
	wa[0] = 'a'
	if lc == 1 {
		wa[0] = 'w'
	}
	wa[1] = '\x00'
}
// write_static_csv - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:2091
func write_static_csv(OUT_file []byte, title []byte, nN int32, nE int32, nL int32, lc int32, DoF int32, J1 []int32, J2 []int32, F []float64, D []float64, R []float64, r []int32, Q [][]float64, err float64, ok int32) {
	// fprintf(stderr," 1. CSV_file = %s  wa = %s \n", CSV_file, wa );
	//
	// * WRITE_STATIC_CSV -  save node displacements and frame element end forces
	// * 31 Dec 2008
	//
	var fpcsv *noarch.File
	var i int32
	var j int32
	var n int32
	var wa []byte = make([]byte, 4)
	var CSV_file []byte = make([]byte, 128)
	// modern time variable type
	var now noarch.TimeT
	var errMsg []byte = make([]byte, 512)
	_ = noarch.Time((*[1000000]noarch.TimeT)(unsafe.Pointer(&now))[:])
	CSV_filename(CSV_file, wa, OUT_file, lc)
	if (func() *noarch.File {
		fpcsv = noarch.Fopen(CSV_file, wa)
		return fpcsv
	}()) == nil {
		noarch.Sprintf(errMsg, []byte("\n  error: cannot open CSV output data file: %s \n\x00"), CSV_file)
		errorMsg(errMsg)
		unix.Exit(17)
	}
	if lc == 1 {
		noarch.Fprintf(fpcsv, []byte("\" Frame3DD version: %s \x00"), []byte("20140514+\x00"))
		//frame3dd.sf.net/\"\n");
		noarch.Fprintf(fpcsv, []byte("              http://frame3dd.sf.net/\"\n\x00"))
		noarch.Fprintf(fpcsv, []byte("\"GPL Copyright (C) 1992-2015, Henri P. Gavin \"\n\x00"))
		noarch.Fprintf(fpcsv, []byte("\"Frame3DD is distributed in the hope that it will be useful\x00"))
		noarch.Fprintf(fpcsv, []byte(" but with no warranty.\"\n\x00"))
		noarch.Fprintf(fpcsv, []byte("\"For details see the GNU Public Licence:\x00"))
		//www.fsf.org/copyleft/gpl.html\"\n");
		noarch.Fprintf(fpcsv, []byte(" http://www.fsf.org/copyleft/gpl.html\"\n\x00"))
		noarch.Fprintf(fpcsv, []byte("\" %s \"\n\x00"), title)
		noarch.Fprintf(fpcsv, []byte("\" %s \"\n\x00"), noarch.Ctime((*[1000000]noarch.TimeT)(unsafe.Pointer(&now))[:]))
		noarch.Fprintf(fpcsv, []byte("\" .CSV formatted results of Frame3DD analysis \"\n\x00"))
		noarch.Fprintf(fpcsv, []byte("\n , Load Case , Displacements , End Forces , Reactions , Internal Forces \n\x00"))
		for i = 1; i <= nL; i++ {
			noarch.Fprintf(fpcsv, []byte(" First Row , %d , %d , %d , %d  , %d  \n\x00"), i, 15+(i-1)*(nN*2+nE*4+13)+2*nL, 17+(i-1)*(nN*2+nE*4+13)+2*nL+nN, 19+(i-1)*(nN*2+nE*4+13)+2*nL+nN+2*nE, 23+(i-1)*(nN*2+nE*4+13)+2*nL+2*nN+2*nE)
			noarch.Fprintf(fpcsv, []byte(" Last Row , %d , %d , %d , %d , %d \n\x00"), i, 15+(i-1)*(nN*2+nE*4+13)+2*nL+nN-1, 17+(i-1)*(nN*2+nE*4+13)+2*nL+nN+2*nE-1, 19+(i-1)*(nN*2+nE*4+13)+2*nL+2*nN+2*nE-1, 23+(i-1)*(nN*2+nE*4+13)+2*nL+2*nN+4*nE-1)
		}
	}
	if ok < 0 {
		noarch.Fprintf(fpcsv, []byte("\"  * The Stiffness Matrix is not positive-definite * \"\n\x00"))
		noarch.Fprintf(fpcsv, []byte("\" Check that all six rigid-body translations are restrained\"\n\x00"))
		noarch.Fprintf(fpcsv, []byte("\" If geometric stiffness is included, reduce the loads.\"\n\x00"))
	}
	//  return;
	noarch.Fprintf(fpcsv, []byte("\n\"L O A D   C A S E   %d   O F   %d  ... \"\n\n\x00"), lc, nL)
	noarch.Fprintf(fpcsv, []byte("\"N O D E   D I S P L A C E M E N T S\x00"))
	noarch.Fprintf(fpcsv, []byte("    (global)\"\n\x00"))
	noarch.Fprintf(fpcsv, []byte("Node  ,  X-dsp   ,   Y-dsp  ,    Z-dsp\x00"))
	noarch.Fprintf(fpcsv, []byte(" ,     X-rot  ,    Y-rot   ,   Z-rot\n\x00"))
	for j = 1; j <= nN; j++ {
		noarch.Fprintf(fpcsv, []byte(" %5d,\x00"), j)
		for i = 5; i >= 0; i-- {
			if math.Abs(D[6*j-i]) < 1e-08 {
				noarch.Fprintf(fpcsv, []byte("    0.0,    \x00"))
			} else {
				noarch.Fprintf(fpcsv, []byte(" %12.5e,\x00"), D[6*j-i])
			}
		}
		noarch.Fprintf(fpcsv, []byte("\n\x00"))
	}
	noarch.Fprintf(fpcsv, []byte("\"F R A M E   E L E M E N T   E N D   F O R C E S\x00"))
	noarch.Fprintf(fpcsv, []byte("  (local)\"\n\x00"))
	noarch.Fprintf(fpcsv, []byte("Elmnt , Node  ,    Nx     ,    Vy   ,     Vz\x00"))
	noarch.Fprintf(fpcsv, []byte("   ,     Txx   ,    Myy  ,     Mzz\n\x00"))
	for n = 1; n <= nE; n++ {
		noarch.Fprintf(fpcsv, []byte(" %5d, %5d,\x00"), n, J1[n])
		if math.Abs(Q[n][1]) < 0.0001 {
			noarch.Fprintf(fpcsv, []byte("      0.0,  \x00"))
		} else {
			noarch.Fprintf(fpcsv, []byte(" %12.5e,\x00"), Q[n][1])
		}
		for i = 2; i <= 6; i++ {
			if math.Abs(Q[n][i]) < 0.0001 {
				noarch.Fprintf(fpcsv, []byte("      0.0, \x00"))
			} else {
				noarch.Fprintf(fpcsv, []byte(" %12.5e,\x00"), Q[n][i])
			}
		}
		noarch.Fprintf(fpcsv, []byte("\n\x00"))
		noarch.Fprintf(fpcsv, []byte(" %5d, %5d,\x00"), n, J2[n])
		if math.Abs(Q[n][7]) < 0.0001 {
			noarch.Fprintf(fpcsv, []byte("      0.0,  \x00"))
		} else {
			noarch.Fprintf(fpcsv, []byte(" %12.5e,\x00"), Q[n][7])
		}
		for i = 8; i <= 12; i++ {
			if math.Abs(Q[n][i]) < 0.0001 {
				noarch.Fprintf(fpcsv, []byte("      0.0, \x00"))
			} else {
				noarch.Fprintf(fpcsv, []byte(" %12.5e,\x00"), Q[n][i])
			}
		}
		noarch.Fprintf(fpcsv, []byte("\n\x00"))
	}
	noarch.Fprintf(fpcsv, []byte("\"R E A C T I O N S  (global)\"\n\x00"))
	noarch.Fprintf(fpcsv, []byte(" Node   ,    Fx      ,   Fy   ,      Fz\x00"))
	noarch.Fprintf(fpcsv, []byte("   ,     Mxx    ,    Myy    ,    Mzz\n\x00"))
	for j = 1; j <= nN; j++ {
		i = 6*(j-1)
		noarch.Fprintf(fpcsv, []byte(" %5d,\x00"), j)
		for i = 5; i >= 0; i-- {
			if r[6*j-i] != 0 {
				noarch.Fprintf(fpcsv, []byte(" %12.5e,\x00"), R[6*j-i])
			} else {
				noarch.Fprintf(fpcsv, []byte("       0.0, \x00"))
			}
		}
		noarch.Fprintf(fpcsv, []byte("\n\x00"))
	}
	noarch.Fprintf(fpcsv, []byte("\"R M S    R E L A T I V E    E Q U I L I B R I U M    E R R O R:\", %9.3e\n\x00"), err)
	noarch.Fclose(fpcsv)
}
// write_static_mfile - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:2246
func write_static_mfile(OUT_file []byte, title []byte, nN int32, nE int32, nL int32, lc int32, DoF int32, J1 []int32, J2 []int32, F []float64, D []float64, R []float64, r []int32, Q [][]float64, err float64, ok int32) {
	//
	// * WRITE_VALUE - write a value in %f or %e notation depending on numerical values
	// * and the number of available significant figures
	// * 12 Dec 2009
	//
	//
	//void write_value (
	//  FILE *fp,
	//  int sig_figs,
	//  float threshold,
	//  char *spaces,
	//  double x
	//){
	// int nZspaces;
	//
	// nZspaces = (int) strlen(*spaces);
	//
	// if ( fabs(x) < threshold ) fprintf ( fp, "0.0 \n");
	//
	//}
	//
	//
	// * WRITE_STATIC_MFILE -
	// * save node displacements and frame element end forces in an m-file
	// * this function interacts with frame_3dd.m, an m-file interface to frame3dd
	// * 09 Sep 2008
	//
	var fpm *noarch.File
	var i int32
	var j int32
	var n int32
	var wa []byte
	var M_file []byte = make([]byte, 128)
	// modern time variable type
	var now noarch.TimeT
	var errMsg []byte = make([]byte, 512)
	_ = noarch.Time((*[1000000]noarch.TimeT)(unsafe.Pointer(&now))[:])
	i = 0
	j = 0
	for i < 128 {
		M_file[j] = OUT_file[i]
		if int32(M_file[j]) == int32('+') || int32(M_file[j]) == int32('-') || int32(M_file[j]) == int32('*') || int32(M_file[j]) == int32('^') || int32(M_file[j]) == int32('.') || int32(M_file[j]) == int32('\x00') {
			M_file[j] = '_'
			break
		}
		i ++
		j ++
	}
	M_file[func() int32 {
		j ++
		return j
	}()] = '\x00'
	noarch.Strcat(M_file, []byte("out.m\x00"))
	wa = []byte("a\x00")
	if lc == 1 {
		wa = []byte("w\x00")
	}
	if (func() *noarch.File {
		fpm = noarch.Fopen(M_file, wa)
		return fpm
	}()) == nil {
		noarch.Sprintf(errMsg, []byte("\n  error: cannot open Matlab output data file: %s \n\x00"), M_file)
		errorMsg(errMsg)
		unix.Exit(18)
	}
	if lc == 1 {
		noarch.Fprintf(fpm, []byte("%% Frame3DD version: %s \x00"), []byte("20140514+\x00"))
		//frame3dd.sf.net/\n");
		noarch.Fprintf(fpm, []byte("              http://frame3dd.sf.net/\n\x00"))
		noarch.Fprintf(fpm, []byte("%%GPL Copyright (C) 1992-2015, Henri P. Gavin \n\x00"))
		noarch.Fprintf(fpm, []byte("%%Frame3DD is distributed in the hope that it will be useful\x00"))
		noarch.Fprintf(fpm, []byte(" but with no warranty.\n\x00"))
		noarch.Fprintf(fpm, []byte("%%For details see the GNU Public Licence:\x00"))
		//www.fsf.org/copyleft/gpl.html\n");
		noarch.Fprintf(fpm, []byte(" http://www.fsf.org/copyleft/gpl.html\n\x00"))
		noarch.Fprintf(fpm, []byte("%% %s\n\x00"), title)
		noarch.Fprintf(fpm, []byte("%% %s\x00"), noarch.Ctime((*[1000000]noarch.TimeT)(unsafe.Pointer(&now))[:]))
		noarch.Fprintf(fpm, []byte("%% m-file formatted results of frame3dd analysis\n\x00"))
		noarch.Fprintf(fpm, []byte("%% to be read by frame_3dd.m\n\x00"))
	}
	if ok < 0 {
		noarch.Fprintf(fpm, []byte("%%  The Stiffness Matrix is not positive-definite *\n\x00"))
		noarch.Fprintf(fpm, []byte("%%  Check that all six rigid-body translations are restrained\n\x00"))
		noarch.Fprintf(fpm, []byte("%%  If geometric stiffness is included, reduce the loads.\n\x00"))
	}
	//  return;
	noarch.Fprintf(fpm, []byte("\n%% L O A D   C A S E   %d   O F   %d  ... \n\n\x00"), lc, nL)
	noarch.Fprintf(fpm, []byte("%% N O D E   D I S P L A C E M E N T S  \x00"))
	noarch.Fprintf(fpm, []byte("\t\t(global)\n\x00"))
	noarch.Fprintf(fpm, []byte("%%\tX-dsp\t\tY-dsp\t\tZ-dsp\t\tX-rot\t\tY-rot\t\tZ-rot\n\x00"))
	noarch.Fprintf(fpm, []byte("D%d=[\x00"), lc)
	for j = 1; j <= nN; j++ {
		for i = 5; i >= 0; i-- {
			if math.Abs(D[6*j-i]) < 1e-08 {
				noarch.Fprintf(fpm, []byte("\t0.0\t\x00"))
			} else {
				noarch.Fprintf(fpm, []byte("\t%13.6e\x00"), D[6*j-i])
			}
		}
		if j < nN {
			noarch.Fprintf(fpm, []byte(" ; \n\x00"))
		} else {
			noarch.Fprintf(fpm, []byte(" ]'; \n\n\x00"))
		}
	}
	noarch.Fprintf(fpm, []byte("%% F R A M E   E L E M E N T   E N D   F O R C E S\x00"))
	noarch.Fprintf(fpm, []byte("\t\t(local)\n\x00"))
	noarch.Fprintf(fpm, []byte("%%\tNx_1\t\tVy_1\t\tVz_1\t\tTxx_1\t\tMyy_1\t\tMzz_1\t\x00"))
	noarch.Fprintf(fpm, []byte("  \tNx_2\t\tVy_2\t\tVz_2\t\tTxx_2\t\tMyy_2\t\tMzz_2\n\x00"))
	noarch.Fprintf(fpm, []byte("F%d=[\x00"), lc)
	for n = 1; n <= nE; n++ {
		if math.Abs(Q[n][1]) < 0.0001 {
			noarch.Fprintf(fpm, []byte("\t0.0\t\x00"))
		} else {
			noarch.Fprintf(fpm, []byte("\t%13.6e\x00"), Q[n][1])
		}
		for i = 2; i <= 6; i++ {
			if math.Abs(Q[n][i]) < 0.0001 {
				noarch.Fprintf(fpm, []byte("\t0.0\t\x00"))
			} else {
				noarch.Fprintf(fpm, []byte("\t%13.6e\x00"), Q[n][i])
			}
		}
		if math.Abs(Q[n][7]) < 0.0001 {
			noarch.Fprintf(fpm, []byte("\t0.0\t\x00"))
		} else {
			noarch.Fprintf(fpm, []byte("\t%13.6e\x00"), Q[n][7])
		}
		for i = 8; i <= 12; i++ {
			if math.Abs(Q[n][i]) < 0.0001 {
				noarch.Fprintf(fpm, []byte("\t0.0\t\x00"))
			} else {
				noarch.Fprintf(fpm, []byte("\t%13.6e\x00"), Q[n][i])
			}
		}
		if n < nE {
			noarch.Fprintf(fpm, []byte(" ; \n\x00"))
		} else {
			noarch.Fprintf(fpm, []byte(" ]'; \n\n\x00"))
		}
	}
	noarch.Fprintf(fpm, []byte("%% R E A C T I O N S\t\t\t\t(global)\n\x00"))
	noarch.Fprintf(fpm, []byte("%%\tFx\t\tFy\t\tFz\t\tMxx\t\tMyy\t\tMzz\n\x00"))
	noarch.Fprintf(fpm, []byte("R%d=[\x00"), lc)
	for j = 1; j <= nN; j++ {
		i = 6*(j-1)
		for i = 5; i >= 0; i-- {
			if noarch.Not(r[6*j-i]) || math.Abs(R[6*j-i]) < 0.0001 {
				noarch.Fprintf(fpm, []byte("\t0.0\t\x00"))
			} else {
				noarch.Fprintf(fpm, []byte("\t%13.6e\x00"), R[6*j-i])
			}
		}
		if j < nN {
			noarch.Fprintf(fpm, []byte(" ; \n\x00"))
		} else {
			noarch.Fprintf(fpm, []byte(" ]'; \n\n\x00"))
		}
	}
	noarch.Fprintf(fpm, []byte("%% R M S    R E L A T I V E    E Q U I L I B R I U M    E R R O R: %9.3e\n\x00"), err)
	noarch.Fprintf(fpm, []byte("\n\n  load Ks \n\n\x00"))
	noarch.Fclose(fpm)
}
// peak_internal_forces - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:2385
func peak_internal_forces(lc int32, nL int32, xyz []vec3, Q [][]float64, nN int32, nE int32, L []float64, N1 []int32, N2 []int32, Ax []float32, Asy []float32, Asz []float32, Jx []float32, Iy []float32, Iz []float32, E []float32, G []float32, p []float32, d []float32, gX float32, gY float32, gZ float32, nU int32, U [][]float32, nW int32, W [][]float32, nP int32, P [][]float32, D []float64, shear int32, dx float32, pkNx [][]float64, pkVy [][]float64, pkVz [][]float64, pkTx [][]float64, pkMy [][]float64, pkMz [][]float64, pkDx [][]float64, pkDy [][]float64, pkDz [][]float64, pkRx [][]float64, pkSy [][]float64, pkSz [][]float64) {
	//
	// * PEAK_INTERNAL_FORCES
	// * calculate frame element internal forces, Nx, Vy, Vz, Tx, My, Mz
	// * calculate frame element local displacements, Rx, Dx, Dy, Dz
	// * return the peak values of the internal forces, moments, slopes, and displacements
	// * 18jun13
	//
	// load case number
	// total number of load cases
	// node locations
	// x-axis increment along frame element
	// vectors of peak forces, moments, displacements and slopes
	// for each frame element, for load case "lc"
	// coord transformation
	var t1 float64
	var t2 float64
	var t3 float64
	var t4 float64
	var t5 float64
	var t6 float64
	var t7 float64
	var t8 float64
	var t9 float64
	var u1 float64
	var u2 float64
	var u3 float64
	var u4 float64
	var u5 float64
	var u6 float64
	var u7 float64
	var u8 float64
	var u9 float64
	var u10 float64
	var u11 float64
	var u12 float64
	// displ.
	// trapz load data, local x dir
	var xx1 float64
	var xx2 float64
	var wx1 float64
	var wx2 float64
	var xy1 float64
	var xy2 float64
	var wy1 float64
	var wy2 float64
	var xz1 float64
	var xz2 float64
	var wz1 float64
	var wz2 float64
	// trapz load data, local y dir
	// trapz load data, local z dir
	// distributed loads in local coords at x[i]
	var wx float64
	var wy float64
	var wz float64
	var wx_ float64
	var wy_ float64
	var wz_ float64
	var wxg float64
	var wyg float64
	var wzg float64
	var tx float64
	var tx_ float64
	// distributed loads in local coords at x[i-1]
	// gravity loads in local x, y, z coord's
	// distributed torque about local x coord
	// location of internal point loads
	var xp float64
	// distance along frame element
	var x float64
	var Nx_ float64
	var Nx float64
	var Vy_ float64
	var Vy float64
	var Vz_ float64
	var Vz float64
	var Tx_ float64
	var Tx float64
	var My_ float64
	var My float64
	var Mz_ float64
	var Mz float64
	var Sy_ float64
	var Sy float64
	var Sz_ float64
	var Sz float64
	var Dx float64
	var Dy float64
	var Dz float64
	var Rx float64
	// underscored "_" variables correspond to x=(i-1)*dx;
	// non-underscored variables correspond to x=i*dx;
	// axial force within frame el.
	// shear forces within frame el.
	// torsional moment within frame el.
	// bending moments within frame el.
	// transverse slopes of frame el.
	// frame el. displ. in local x,y,z, dir's
	// twist rotation about the local x-axis
	// frame element number
	var n int32
	var m int32
	var nx int32 = 1000
	var cU int32
	var cW int32
	var cP int32
	var i int32
	var n1 int32
	var n2 int32
	var i1 int32
	var i2 int32
	if float64(dx) == -1 {
		// number of sections alont x axis
		// counters for U, W, and P loads
		// counter along x axis from node N1 to node N2
		// starting and stopping node numbers
		// skip calculation of internal forces and displ
		return
	}
	{
		// initialize peak values to zero
		for m = 1; m <= nE; m++ {
			pkVz[lc][m] = 0
			pkVy[lc][m] = pkVz[lc][m]
			pkNx[lc][m] = pkVy[lc][m]
			pkMz[lc][m] = 0
			pkMy[lc][m] = pkMz[lc][m]
			pkTx[lc][m] = pkMy[lc][m]
			pkDz[lc][m] = 0
			pkDy[lc][m] = pkDz[lc][m]
			pkDx[lc][m] = pkDy[lc][m]
			pkSz[lc][m] = 0
			pkSy[lc][m] = pkSz[lc][m]
			pkRx[lc][m] = pkSy[lc][m]
		}
	}
	{
		// loop over all frame elements
		for m = 1; m <= nE; m++ {
			// node 1 and node 2 of elmnt m
			n1 = N1[m]
			n2 = N2[m]
			// x-axis increment, same for each element
			dx = float32(L[m]/float64(float32(nx)))
			// no need to allocate memory for interior force or displacement data
			// find interior axial force, shear forces, torsion and bending moments
			coord_trans(xyz, L[m], n1, n2, c4goUnsafeConvert_float64(&t1), c4goUnsafeConvert_float64(&t2), c4goUnsafeConvert_float64(&t3), c4goUnsafeConvert_float64(&t4), c4goUnsafeConvert_float64(&t5), c4goUnsafeConvert_float64(&t6), c4goUnsafeConvert_float64(&t7), c4goUnsafeConvert_float64(&t8), c4goUnsafeConvert_float64(&t9), p[m])
			// distributed gravity load in local x, y, z coordinates
			wxg = float64(d[m]*Ax[m])*(t1*float64(gX)+t2*float64(gY)+t3*float64(gZ))
			wyg = float64(d[m]*Ax[m])*(t4*float64(gX)+t5*float64(gY)+t6*float64(gZ))
			wzg = float64(d[m]*Ax[m])*(t7*float64(gX)+t8*float64(gY)+t9*float64(gZ))
			{
				// add uniformly-distributed loads to gravity load
				for n = 1; n <= nE && cU < nU; n++ {
					if int32(U[n][1]) == m {
						// load n on element m
						wxg += float64(U[n][2])
						wyg += float64(U[n][3])
						wzg += float64(U[n][4])
						cU ++
					}
				}
			}
			Nx = -Q[m][1]
			// interior forces for frame element "m" at (x=0)
			// positive Nx is tensile
			Nx_ = Nx
			Vy = -Q[m][2]
			// positive Vy in local y direction
			Vy_ = Vy
			Vz = -Q[m][3]
			// positive Vz in local z direction
			Vz_ = Vz
			Tx = -Q[m][4]
			// positive Tx r.h.r. about local x axis
			Tx_ = Tx
			My = Q[m][5]
			// positive My -> positive x-z curvature
			My_ = My
			Mz = -Q[m][6]
			// positive Mz -> positive x-y curvature
			Mz_ = Mz
			i1 = 6*(n1-1)
			i2 = 6*(n2-1)
			// compute end deflections in local coordinates
			u1 = t1*D[i1+1]+t2*D[i1+2]+t3*D[i1+3]
			u2 = t4*D[i1+1]+t5*D[i1+2]+t6*D[i1+3]
			u3 = t7*D[i1+1]+t8*D[i1+2]+t9*D[i1+3]
			u4 = t1*D[i1+4]+t2*D[i1+5]+t3*D[i1+6]
			u5 = t4*D[i1+4]+t5*D[i1+5]+t6*D[i1+6]
			u6 = t7*D[i1+4]+t8*D[i1+5]+t9*D[i1+6]
			u7 = t1*D[i2+1]+t2*D[i2+2]+t3*D[i2+3]
			u8 = t4*D[i2+1]+t5*D[i2+2]+t6*D[i2+3]
			u9 = t7*D[i2+1]+t8*D[i2+2]+t9*D[i2+3]
			u10 = t1*D[i2+4]+t2*D[i2+5]+t3*D[i2+6]
			u11 = t4*D[i2+4]+t5*D[i2+5]+t6*D[i2+6]
			u12 = t7*D[i2+4]+t8*D[i2+5]+t9*D[i2+6]
			// rotations and displacements for frame element "m" at (x=0)
			// displacement in  local x dir  at node N1
			Dx = u1
			// displacement in  local y dir  at node N1
			Dy = u2
			// displacement in  local z dir  at node N1
			Dz = u3
			// rotationin about local x axis at node N1
			Rx = u4
			Sy = u6
			// slope in  local y  direction  at node N1
			Sy_ = Sy
			Sz = -u5
			// slope in  local z  direction  at node N1
			Sz_ = Sz
			{
				// accumulate interior span loads, forces, moments, slopes, and displacements
				// all in a single loop
				for i = 1; i <= nx; i++ {
					// location from node N1 along the x-axis
					x = float64(float32(i)*dx)
					// start with gravitational plus uniform loads
					wx = wxg
					wy = wyg
					wz = wzg
					if i == 1 {
						wx_ = wxg
						wy_ = wyg
						wz_ = wzg
						tx_ = tx
					}
					{
						// add trapezoidally-distributed loads
						for n = 1; n <= 10*nE && cW < nW; n++ {
							if int32(W[n][1]) == m {
								if i == nx {
									// load n on element m
									cW ++
								}
								xx1 = float64(W[n][2])
								xx2 = float64(W[n][3])
								wx1 = float64(W[n][4])
								wx2 = float64(W[n][5])
								xy1 = float64(W[n][6])
								xy2 = float64(W[n][7])
								wy1 = float64(W[n][8])
								wy2 = float64(W[n][9])
								xz1 = float64(W[n][10])
								xz2 = float64(W[n][11])
								wz1 = float64(W[n][12])
								wz2 = float64(W[n][13])
								if x > xx1 && x <= xx2 {
									wx += wx1+(wx2-wx1)*(x-xx1)/(xx2-xx1)
								}
								if x > xy1 && x <= xy2 {
									wy += wy1+(wy2-wy1)*(x-xy1)/(xy2-xy1)
								}
								if x > xz1 && x <= xz2 {
									wz += wz1+(wz2-wz1)*(x-xz1)/(xz2-xz1)
								}
							}
						}
					}
					// trapezoidal integration of distributed loads
					// for axial forces, shear forces and torques
					Nx = Nx-0.5*(wx+wx_)*float64(dx)
					Vy = Vy-0.5*(wy+wy_)*float64(dx)
					Vz = Vz-0.5*(wz+wz_)*float64(dx)
					Tx = Tx-0.5*(tx+tx_)*float64(dx)
					// update distributed loads at x = (i-1)*dx
					wx_ = wx
					wy_ = wy
					wz_ = wz
					tx_ = tx
					{
						// add interior point loads
						for n = 1; n <= 10*nE && cP < nP; n++ {
							if int32(P[n][1]) == m {
								if i == nx {
									// load n on element m
									cP ++
								}
								xp = float64(P[n][5])
								if x <= xp && xp < x+float64(dx) {
									Nx -= float64(P[n][2])*0.5*(1-(xp-x)/float64(dx))
									Vy -= float64(P[n][3])*0.5*(1-(xp-x)/float64(dx))
									Vz -= float64(P[n][4])*0.5*(1-(xp-x)/float64(dx))
								}
								if x-float64(dx) <= xp && xp < x {
									Nx -= float64(P[n][2])*0.5*(1-(x-float64(dx)-xp)/float64(dx))
									Vy -= float64(P[n][3])*0.5*(1-(x-float64(dx)-xp)/float64(dx))
									Vz -= float64(P[n][4])*0.5*(1-(x-float64(dx)-xp)/float64(dx))
								}
							}
						}
					}
					// trapezoidal integration of shear force for bending momemnt
					My = My-0.5*(Vz_+Vz)*float64(dx)
					Mz = Mz-0.5*(Vy_+Vy)*float64(dx)
					// displacement along frame element "m"
					Dx = Dx+0.5*(Nx_+Nx)/float64(E[m]*Ax[m])*float64(dx)
					// torsional rotation along frame element "m"
					Rx = Rx+0.5*(Tx_+Tx)/float64(G[m]*Jx[m])*float64(dx)
					// transverse slope along frame element "m"
					Sy = Sy+0.5*(Mz_+Mz)/float64(E[m]*Iz[m])*float64(dx)
					Sz = Sz+0.5*(My_+My)/float64(E[m]*Iy[m])*float64(dx)
					if shear != 0 {
						Sy += Vy/float64(G[m]*Asy[m])
						Sz += Vz/float64(G[m]*Asz[m])
					}
					// displacement along frame element "m"
					Dy = Dy+0.5*(Sy_+Sy)*float64(dx)
					Dz = Dz+0.5*(Sz_+Sz)*float64(dx)
					// update forces, moments, and slopes at x = (i-1)*dx
					Nx_ = Nx
					Vy_ = Vy
					Vz_ = Vz
					Tx_ = Tx
					My_ = My
					Mz_ = Mz
					Sy_ = Sy
					Sz_ = Sz
					// update the peak forces, moments, slopes and displacements
					// and their locations along the frame element
					if math.Abs(Nx) > pkNx[lc][m] {
						pkNx[lc][m] = math.Abs(Nx)
					} else {
						pkNx[lc][m] = pkNx[lc][m]
					}
					if math.Abs(Vy) > pkVy[lc][m] {
						pkVy[lc][m] = math.Abs(Vy)
					} else {
						pkVy[lc][m] = pkVy[lc][m]
					}
					if math.Abs(Vz) > pkVz[lc][m] {
						pkVz[lc][m] = math.Abs(Vz)
					} else {
						pkVz[lc][m] = pkVz[lc][m]
					}
					if math.Abs(Tx) > pkTx[lc][m] {
						pkTx[lc][m] = math.Abs(Tx)
					} else {
						pkTx[lc][m] = pkTx[lc][m]
					}
					if math.Abs(My) > pkMy[lc][m] {
						pkMy[lc][m] = math.Abs(My)
					} else {
						pkMy[lc][m] = pkMy[lc][m]
					}
					if math.Abs(Mz) > pkMz[lc][m] {
						pkMz[lc][m] = math.Abs(Mz)
					} else {
						pkMz[lc][m] = pkMz[lc][m]
					}
					if math.Abs(Dx) > pkDx[lc][m] {
						pkDx[lc][m] = math.Abs(Dx)
					} else {
						pkDx[lc][m] = pkDx[lc][m]
					}
					if math.Abs(Dy) > pkDy[lc][m] {
						pkDy[lc][m] = math.Abs(Dy)
					} else {
						pkDy[lc][m] = pkDy[lc][m]
					}
					if math.Abs(Dz) > pkDz[lc][m] {
						pkDz[lc][m] = math.Abs(Dz)
					} else {
						pkDz[lc][m] = pkDz[lc][m]
					}
					if math.Abs(Rx) > pkRx[lc][m] {
						pkRx[lc][m] = math.Abs(Rx)
					} else {
						pkRx[lc][m] = pkRx[lc][m]
					}
					if math.Abs(Sy) > pkSy[lc][m] {
						pkSy[lc][m] = math.Abs(Sy)
					} else {
						pkSy[lc][m] = pkSy[lc][m]
					}
					if math.Abs(Sz) > pkSz[lc][m] {
						pkSz[lc][m] = math.Abs(Sz)
					} else {
						pkSz[lc][m] = pkSz[lc][m]
					}
				}
			}
		}
	}
	// end of loop along element "m"
	// at the end of this loop,
	// the variables Nx; Vy; Vz; Tx; My; Mz; Dx; Dy; Dz; Rx; Sy; Sz;
	// contain the forces, moments, displacements, and slopes
	// at node N2 of element "m"
	// comparing the internal forces and displacements at node N2
	// to the values conmputed via trapezoidal rule could give an estimate
	// of the accuracy of the trapezoidal rule, (how small "dx" needs to be)
	// linear correction for bias in trapezoidal integration
	// is not implemented, the peak values are affected by accumulation
	// of round-off error in trapezoidal rule integration.
	// round-off errors are larger in the peak displacements than in the peak forces
	// end of loop over all frame elements
	// DEBUG --- write output to terminal
	noarch.Fprintf(noarch.Stderr, []byte("P E A K   F R A M E   E L E M E N T   I N T E R N A L   F O R C E S\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("\t(local)\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("  Elmnt       Nx          Vy         Vz\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("        Txx        Myy        Mzz\n\x00"))
	for m = 1; m <= nE; m++ {
		noarch.Fprintf(noarch.Stderr, []byte(" %5d  %10.3f  %10.3f %10.3f %10.3f %10.3f %10.3f\n\x00"), m, pkNx[lc][m], pkVy[lc][m], pkVz[lc][m], pkTx[lc][m], pkMy[lc][m], pkMz[lc][m])
	}
	noarch.Fprintf(noarch.Stderr, []byte("\n P E A K   I N T E R N A L   D I S P L A C E M E N T S\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("\t\t\t(local)\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("  Elmnt  X-dsp       Y-dsp       Z-dsp       X-rot       Y-rot       Z-rot\n\x00"))
	for m = 1; m <= nE; m++ {
		noarch.Fprintf(noarch.Stderr, []byte(" %5d %10.6f  %10.6f  %10.6f  %10.6f  %10.6f  %10.6f\n\x00"), m, pkDx[lc][m], pkDy[lc][m], pkDz[lc][m], pkRx[lc][m], pkSy[lc][m], pkSz[lc][m])
	}
}
// write_internal_forces - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:2672
func write_internal_forces(OUT_file []byte, fp *noarch.File, infcpath []byte, lc int32, nL int32, title []byte, dx float32, xyz []vec3, Q [][]float64, nN int32, nE int32, L []float64, J1 []int32, J2 []int32, Ax []float32, Asy []float32, Asz []float32, Jx []float32, Iy []float32, Iz []float32, E []float32, G []float32, p []float32, d []float32, gX float32, gY float32, gZ float32, nU int32, U [][]float32, nW int32, W [][]float32, nP int32, P [][]float32, D []float64, shear int32, error_ float64) {
	//
	// * WRITE_INTERNAL_FORCES -
	// * calculate frame element internal forces, Nx, Vy, Vz, Tx, My, Mz
	// * calculate frame element local displacements, Rx, Dx, Dy, Dz
	// * write internal forces and local displacements to an output data file
	// * 4jan10, 7mar11, 21jan14
	//
	// coord transformation
	var t1 float64
	var t2 float64
	var t3 float64
	var t4 float64
	var t5 float64
	var t6 float64
	var t7 float64
	var t8 float64
	var t9 float64
	var u1 float64
	var u2 float64
	var u3 float64
	var u4 float64
	var u5 float64
	var u6 float64
	var u7 float64
	var u8 float64
	var u9 float64
	var u10 float64
	var u11 float64
	var u12 float64
	// displ.
	// trapz load data, local x dir
	var xx1 float64
	var xx2 float64
	var wx1 float64
	var wx2 float64
	var xy1 float64
	var xy2 float64
	var wy1 float64
	var wy2 float64
	var xz1 float64
	var xz2 float64
	var wz1 float64
	var wz2 float64
	// trapz load data, local y dir
	// trapz load data, local z dir
	// distributed loads in local coords at x[i]
	var wx float64
	var wy float64
	var wz float64
	var wx_ float64
	var wy_ float64
	var wz_ float64
	var wxg float64
	var wyg float64
	var wzg float64
	var tx float64
	var tx_ float64
	// distributed loads in local coords at x[i-1]
	// gravity loads in local x, y, z coord's
	// distributed torque about local x coord
	// location of internal point loads
	var xp float64
	// distance along frame element
	var x []float64
	var dx_ float64
	var dxnx float64
	var Nx []float64
	var Vy []float64
	var Vz []float64
	var Tx []float64
	var My []float64
	var Mz []float64
	var Sy []float64
	var Sz []float64
	var Dx []float64
	var Dy []float64
	var Dz []float64
	var Rx []float64
	// axial force within frame el.
	// shear forces within frame el.
	// torsional moment within frame el.
	// bending moments within frame el.
	// transverse slopes of frame el.
	// frame el. displ. in local x,y,z, dir's
	// twist rotation about the local x-axis
	//  maximum internal forces
	var maxNx float64
	var maxVy float64
	var maxVz float64
	var maxTx float64
	var maxMy float64
	var maxMz float64
	var maxDx float64
	var maxDy float64
	var maxDz float64
	var maxRx float64
	var maxSy float64
	var maxSz float64
	//  maximum internal moments
	//  maximum element displacements
	//  maximum element rotations
	//  minimum internal forces
	var minNx float64
	var minVy float64
	var minVz float64
	var minTx float64
	var minMy float64
	var minMz float64
	var minDx float64
	var minDy float64
	var minDz float64
	var minRx float64
	var minSy float64
	var minSz float64
	//  minimum internal moments
	//  minimum element displacements
	//  minimum element rotations
	// frame element number
	var n int32
	var m int32
	var cU int32
	var cW int32
	var cP int32
	var i int32
	var nx int32
	var n1 int32
	var n2 int32
	var i1 int32
	var i2 int32
	// counters for U, W, and P loads
	// number of sections alont x axis
	// starting and stopping node no's
	// file name    for internal force data
	var fnif []byte = make([]byte, 128)
	var CSV_file []byte = make([]byte, 128)
	var errMsg []byte = make([]byte, 512)
	// indicate 'write' or 'append' to file
	var wa []byte = make([]byte, 4)
	// file pointer for internal force data
	var fpif *noarch.File
	var fpcsv *noarch.File
	// file pointer to .CSV output data file
	// modern time variable type
	var now noarch.TimeT
	if float64(dx) == -1 {
		// skip calculation of internal forces and displ
		return
	}
	_ = noarch.Time((*[1000000]noarch.TimeT)(unsafe.Pointer(&now))[:])
	CSV_filename(CSV_file, wa, OUT_file, lc)
	if (func() *noarch.File {
		fpcsv = noarch.Fopen(CSV_file, []byte("a\x00"))
		return fpcsv
	}()) == nil {
		noarch.Sprintf(errMsg, []byte("\n  error: cannot open CSV output data file: %s \n\x00"), CSV_file)
		errorMsg(errMsg)
		unix.Exit(17)
	}
	// file name for internal force data for load case "lc"
	noarch.Sprintf(fnif, []byte("%s%02d\x00"), infcpath, lc)
	if (func() *noarch.File {
		fpif = noarch.Fopen(fnif, []byte("w\x00"))
		return fpif
	}()) == nil {
		// open the interior force data file
		noarch.Sprintf(errMsg, []byte("\n  error: cannot open interior force data file: %s \n\x00"), fnif)
		errorMsg(errMsg)
		unix.Exit(19)
	}
	//frame3dd.sf.net/");
	noarch.Fprintf(fpif, []byte("# FRAME3DD ANALYSIS RESULTS  http://frame3dd.sf.net/\x00"))
	noarch.Fprintf(fpif, []byte(" VERSION %s \n\x00"), []byte("20140514+\x00"))
	noarch.Fprintf(fpif, []byte("# %s\n\x00"), title)
	noarch.Fprintf(fpif, []byte("# %s\n\x00"), fnif)
	noarch.Fprintf(fpif, []byte("# %s\x00"), noarch.Ctime((*[1000000]noarch.TimeT)(unsafe.Pointer(&now))[:]))
	noarch.Fprintf(fpif, []byte("# L O A D  C A S E   %d  of   %d \n\x00"), lc, nL)
	noarch.Fprintf(fpif, []byte("# F R A M E   E L E M E N T   I N T E R N A L   F O R C E S (local)\n\x00"))
	noarch.Fprintf(fpif, []byte("# F R A M E   E L E M E N T   T R A N S V E R S E   D I S P L A C E M E N T S (local)\n\n\x00"))
	// write header information for each frame element to txt output data file
	noarch.Fprintf(fp, []byte("\nP E A K   F R A M E   E L E M E N T   I N T E R N A L   F O R C E S\x00"))
	noarch.Fprintf(fp, []byte("(local)\", \n\x00"))
	noarch.Fprintf(fp, []byte("  Elmnt   .         Nx          Vy         Vz\x00"))
	noarch.Fprintf(fp, []byte("        Txx        Myy        Mzz\n\x00"))
	// write header information for each frame element to CSV output data file
	noarch.Fprintf(fpcsv, []byte("\n\"P E A K   F R A M E   E L E M E N T   I N T E R N A L   F O R C E S \x00"))
	noarch.Fprintf(fpcsv, []byte("   (local)\",\n\x00"))
	noarch.Fprintf(fpcsv, []byte(" \"Elmnt\",  \".\", \"Nx\", \"Vy\", \"Vz\", \x00"))
	noarch.Fprintf(fpcsv, []byte(" \"Txx\", \"Myy\", \"Mzz\", \n\x00"))
	{
		//    fprintf(fp,"\n P E A K   I N T E R N A L   D I S P L A C E M E N T S");
		// *  fprintf(fp,"\t\t\t(local)\n");
		// *  fprintf(fp,"  Elmnt  X-dsp       Y-dsp       Z-dsp       X-rot       Y-rot       Z-rot\n");
		//
		// loop over all frame elements
		for m = 1; m <= nE; m++ {
			// node 1 and node 2 of elmnt m
			n1 = J1[m]
			n2 = J2[m]
			// number of x-axis increments
			nx = int32(math.Floor(L[m]/float64(dx)))
			if nx < 1 {
				// at least one x-axis increment
				nx = 1
			}
			// allocate memory for interior force data for frame element "m"
			x = dvector(0, nx)
			Nx = dvector(0, nx)
			Vy = dvector(0, nx)
			Vz = dvector(0, nx)
			Tx = dvector(0, nx)
			My = dvector(0, nx)
			Mz = dvector(0, nx)
			Sy = dvector(0, nx)
			Sz = dvector(0, nx)
			Rx = dvector(0, nx)
			Dx = dvector(0, nx)
			Dy = dvector(0, nx)
			Dz = dvector(0, nx)
			{
				// the local x-axis for frame element "m" starts at 0 and ends at L[m]
				for i = 0; i < nx; i++ {
					x[i] = float64(float32(i)*dx)
				}
			}
			x[nx] = L[m]
			// length of the last x-axis increment
			dxnx = x[nx]-x[nx-1]
			// write header information for each frame element
			noarch.Fprintf(fpif, []byte("#\tElmnt\tN1\tN2        \tX1        \tY1        \tZ1        \tX2        \tY2        \tZ2\tnx\n\x00"))
			noarch.Fprintf(fpif, []byte("# @\t%5d\t%5d\t%5d\t%14.6e\t%14.6e\t%14.6e\t%14.6e\t%14.6e\t%14.6e\t%5d\n\x00"), m, n1, n2, xyz[n1].x, xyz[n1].y, xyz[n1].z, xyz[n2].x, xyz[n2].y, xyz[n2].z, nx+1)
			// find interior axial force, shear forces, torsion and bending moments
			coord_trans(xyz, L[m], n1, n2, c4goUnsafeConvert_float64(&t1), c4goUnsafeConvert_float64(&t2), c4goUnsafeConvert_float64(&t3), c4goUnsafeConvert_float64(&t4), c4goUnsafeConvert_float64(&t5), c4goUnsafeConvert_float64(&t6), c4goUnsafeConvert_float64(&t7), c4goUnsafeConvert_float64(&t8), c4goUnsafeConvert_float64(&t9), p[m])
			// distributed gravity load in local x, y, z coordinates
			wxg = float64(d[m]*Ax[m])*(t1*float64(gX)+t2*float64(gY)+t3*float64(gZ))
			wyg = float64(d[m]*Ax[m])*(t4*float64(gX)+t5*float64(gY)+t6*float64(gZ))
			wzg = float64(d[m]*Ax[m])*(t7*float64(gX)+t8*float64(gY)+t9*float64(gZ))
			{
				// add uniformly-distributed loads to gravity load
				for n = 1; n <= nE && cU < nU; n++ {
					if int32(U[n][1]) == m {
						// load n on element m
						wxg += float64(U[n][2])
						wyg += float64(U[n][3])
						wzg += float64(U[n][4])
						cU ++
					}
				}
			}
			// interior forces for frame element "m" at (x=0)
			// positive Nx is tensile
			Nx[0] = -Q[m][1]
			// positive Vy in local y direction
			Vy[0] = -Q[m][2]
			// positive Vz in local z direction
			Vz[0] = -Q[m][3]
			// positive Tx r.h.r. about local x axis
			Tx[0] = -Q[m][4]
			// positive My -> positive x-z curvature
			My[0] = Q[m][5]
			// positive Mz -> positive x-y curvature
			Mz[0] = -Q[m][6]
			dx_ = float64(dx)
			{
				//  accumulate interior span loads
				for i = 1; i <= nx; i++ {
					// start with gravitational plus uniform loads
					wx = wxg
					wy = wyg
					wz = wzg
					if i == 1 {
						wx_ = wxg
						wy_ = wyg
						wz_ = wzg
						tx_ = tx
					}
					{
						// add trapezoidally-distributed loads
						for n = 1; n <= 10*nE && cW < nW; n++ {
							if int32(W[n][1]) == m {
								if i == nx {
									// load n on element m
									cW ++
								}
								xx1 = float64(W[n][2])
								xx2 = float64(W[n][3])
								wx1 = float64(W[n][4])
								wx2 = float64(W[n][5])
								xy1 = float64(W[n][6])
								xy2 = float64(W[n][7])
								wy1 = float64(W[n][8])
								wy2 = float64(W[n][9])
								xz1 = float64(W[n][10])
								xz2 = float64(W[n][11])
								wz1 = float64(W[n][12])
								wz2 = float64(W[n][13])
								if x[i] > xx1 && x[i] <= xx2 {
									wx += wx1+(wx2-wx1)*(x[i]-xx1)/(xx2-xx1)
								}
								if x[i] > xy1 && x[i] <= xy2 {
									wy += wy1+(wy2-wy1)*(x[i]-xy1)/(xy2-xy1)
								}
								if x[i] > xz1 && x[i] <= xz2 {
									wz += wz1+(wz2-wz1)*(x[i]-xz1)/(xz2-xz1)
								}
							}
						}
					}
					if i == nx {
						// trapezoidal integration of distributed loads
						// for axial forces, shear forces and torques
						dx_ = dxnx
					}
					Nx[i] = Nx[i-1]-0.5*(wx+wx_)*dx_
					Vy[i] = Vy[i-1]-0.5*(wy+wy_)*dx_
					Vz[i] = Vz[i-1]-0.5*(wz+wz_)*dx_
					Tx[i] = Tx[i-1]-0.5*(tx+tx_)*dx_
					// update distributed loads at x[i-1]
					wx_ = wx
					wy_ = wy
					wz_ = wz
					tx_ = tx
					{
						// add interior point loads
						for n = 1; n <= 10*nE && cP < nP; n++ {
							if int32(P[n][1]) == m {
								if i == nx {
									// load n on element m
									cP ++
								}
								xp = float64(P[n][5])
								if x[i] <= xp && xp < x[i]+float64(dx) {
									Nx[i] -= float64(P[n][2])*0.5*(1-(xp-x[i])/float64(dx))
									Vy[i] -= float64(P[n][3])*0.5*(1-(xp-x[i])/float64(dx))
									Vz[i] -= float64(P[n][4])*0.5*(1-(xp-x[i])/float64(dx))
								}
								if x[i]-float64(dx) <= xp && xp < x[i] {
									Nx[i] -= float64(P[n][2])*0.5*(1-(x[i]-float64(dx)-xp)/float64(dx))
									Vy[i] -= float64(P[n][3])*0.5*(1-(x[i]-float64(dx)-xp)/float64(dx))
									Vz[i] -= float64(P[n][4])*0.5*(1-(x[i]-float64(dx)-xp)/float64(dx))
								}
							}
						}
					}
				}
			}
			{
				// linear correction of forces for bias in trapezoidal integration
				for i = 1; i <= nx; i++ {
					Nx[i] -= (Nx[nx]-Q[m][7])*float64(i)/float64(nx)
					Vy[i] -= (Vy[nx]-Q[m][8])*float64(i)/float64(nx)
					Vz[i] -= (Vz[nx]-Q[m][9])*float64(i)/float64(nx)
					Tx[i] -= (Tx[nx]-Q[m][10])*float64(i)/float64(nx)
				}
			}
			// trapezoidal integration of shear force for bending momemnt
			dx_ = float64(dx)
			for i = 1; i <= nx; i++ {
				if i == nx {
					dx_ = dxnx
				}
				My[i] = My[i-1]-0.5*(Vz[i]+Vz[i-1])*dx_
				Mz[i] = Mz[i-1]-0.5*(Vy[i]+Vy[i-1])*dx_
			}
			{
				// linear correction of moments for bias in trapezoidal integration
				for i = 1; i <= nx; i++ {
					My[i] -= (My[nx]+Q[m][11])*float64(i)/float64(nx)
					Mz[i] -= (Mz[nx]-Q[m][12])*float64(i)/float64(nx)
				}
			}
			// find interior transverse displacements
			i1 = 6*(n1-1)
			i2 = 6*(n2-1)
			// compute end deflections in local coordinates
			u1 = t1*D[i1+1]+t2*D[i1+2]+t3*D[i1+3]
			u2 = t4*D[i1+1]+t5*D[i1+2]+t6*D[i1+3]
			u3 = t7*D[i1+1]+t8*D[i1+2]+t9*D[i1+3]
			u4 = t1*D[i1+4]+t2*D[i1+5]+t3*D[i1+6]
			u5 = t4*D[i1+4]+t5*D[i1+5]+t6*D[i1+6]
			u6 = t7*D[i1+4]+t8*D[i1+5]+t9*D[i1+6]
			u7 = t1*D[i2+1]+t2*D[i2+2]+t3*D[i2+3]
			u8 = t4*D[i2+1]+t5*D[i2+2]+t6*D[i2+3]
			u9 = t7*D[i2+1]+t8*D[i2+2]+t9*D[i2+3]
			u10 = t1*D[i2+4]+t2*D[i2+5]+t3*D[i2+6]
			u11 = t4*D[i2+4]+t5*D[i2+5]+t6*D[i2+6]
			u12 = t7*D[i2+4]+t8*D[i2+5]+t9*D[i2+6]
			// rotations and displacements for frame element "m" at (x=0)
			// displacement in  local x dir  at node N1
			Dx[0] = u1
			// displacement in  local y dir  at node N1
			Dy[0] = u2
			// displacement in  local z dir  at node N1
			Dz[0] = u3
			// rotationin about local x axis at node N1
			Rx[0] = u4
			// slope in  local y  direction  at node N1
			Sy[0] = u6
			// slope in  local z  direction  at node N1
			Sz[0] = -u5
			// axial displacement along frame element "m"
			dx_ = float64(dx)
			for i = 1; i <= nx; i++ {
				if i == nx {
					dx_ = dxnx
				}
				Dx[i] = Dx[i-1]+0.5*(Nx[i-1]+Nx[i])/float64(E[m]*Ax[m])*dx_
			}
			{
				// linear correction of axial displacement for bias in trapezoidal integration
				for i = 1; i <= nx; i++ {
					Dx[i] -= (Dx[nx]-u7)*float64(i)/float64(nx)
				}
			}
			// torsional rotation along frame element "m"
			dx_ = float64(dx)
			for i = 1; i <= nx; i++ {
				if i == nx {
					dx_ = dxnx
				}
				Rx[i] = Rx[i-1]+0.5*(Tx[i-1]+Tx[i])/float64(G[m]*Jx[m])*dx_
			}
			{
				// linear correction of torsional rot'n for bias in trapezoidal integration
				for i = 1; i <= nx; i++ {
					Rx[i] -= (Rx[nx]-u10)*float64(i)/float64(nx)
				}
			}
			// transverse slope along frame element "m"
			dx_ = float64(dx)
			for i = 1; i <= nx; i++ {
				if i == nx {
					dx_ = dxnx
				}
				Sy[i] = Sy[i-1]+0.5*(Mz[i-1]+Mz[i])/float64(E[m]*Iz[m])*dx_
				Sz[i] = Sz[i-1]+0.5*(My[i-1]+My[i])/float64(E[m]*Iy[m])*dx_
			}
			{
				// linear correction for bias in trapezoidal integration
				for i = 1; i <= nx; i++ {
					Sy[i] -= (Sy[nx]-u12)*float64(i)/float64(nx)
					Sz[i] -= (Sz[nx]+u11)*float64(i)/float64(nx)
				}
			}
			if shear != 0 {
				// add-in slope due to shear deformation
				for i = 0; i <= nx; i++ {
					Sy[i] += Vy[i]/float64(G[m]*Asy[m])
					Sz[i] += Vz[i]/float64(G[m]*Asz[m])
				}
			}
			// displacement along frame element "m"
			dx_ = float64(dx)
			for i = 1; i <= nx; i++ {
				if i == nx {
					dx_ = dxnx
				}
				Dy[i] = Dy[i-1]+0.5*(Sy[i-1]+Sy[i])*dx_
				Dz[i] = Dz[i-1]+0.5*(Sz[i-1]+Sz[i])*dx_
			}
			{
				// linear correction for bias in trapezoidal integration
				for i = 1; i <= nx; i++ {
					Dy[i] -= (Dy[nx]-u8)*float64(i)/float64(nx)
					Dz[i] -= (Dz[nx]-u9)*float64(i)/float64(nx)
				}
			}
			minNx = Nx[0]
			// initialize the maximum and minimum element forces and displacements
			//  maximum internal forces
			maxNx = minNx
			minVy = Vy[0]
			maxVy = minVy
			minVz = Vz[0]
			maxVz = minVz
			minTx = Tx[0]
			//  maximum internal moments
			maxTx = minTx
			minMy = My[0]
			maxMy = minMy
			minMz = Mz[0]
			maxMz = minMz
			minDx = Dx[0]
			//  maximum element displacements
			maxDx = minDx
			minDy = Dy[0]
			maxDy = minDy
			minDz = Dz[0]
			maxDz = minDz
			minRx = Rx[0]
			//  maximum element rotations
			maxRx = minRx
			minSy = Sy[0]
			maxSy = minSy
			minSz = Sz[0]
			maxSz = minSz
			{
				// find maximum and minimum internal element forces
				for i = 1; i <= nx; i++ {
					if Nx[i] > maxNx {
						maxNx = Nx[i]
					} else {
						maxNx = maxNx
					}
					if Nx[i] < minNx {
						minNx = Nx[i]
					} else {
						minNx = minNx
					}
					if Vy[i] > maxVy {
						maxVy = Vy[i]
					} else {
						maxVy = maxVy
					}
					if Vy[i] < minVy {
						minVy = Vy[i]
					} else {
						minVy = minVy
					}
					if Vz[i] > maxVz {
						maxVz = Vz[i]
					} else {
						maxVz = maxVz
					}
					if Vz[i] < minVz {
						minVz = Vz[i]
					} else {
						minVz = minVz
					}
					if Tx[i] > maxTx {
						maxTx = Tx[i]
					} else {
						maxTx = maxTx
					}
					if Tx[i] < minTx {
						minTx = Tx[i]
					} else {
						minTx = minTx
					}
					if My[i] > maxMy {
						maxMy = My[i]
					} else {
						maxMy = maxMy
					}
					if My[i] < minMy {
						minMy = My[i]
					} else {
						minMy = minMy
					}
					if Mz[i] > maxMz {
						maxMz = Mz[i]
					} else {
						maxMz = maxMz
					}
					if Mz[i] < minMz {
						minMz = Mz[i]
					} else {
						minMz = minMz
					}
				}
			}
			{
				// find maximum and minimum internal element displacements
				for i = 1; i <= nx; i++ {
					if Dx[i] > maxDx {
						maxDx = Dx[i]
					} else {
						maxDx = maxDx
					}
					if Dx[i] < minDx {
						minDx = Dx[i]
					} else {
						minDx = minDx
					}
					if Dy[i] > maxDy {
						maxDy = Dy[i]
					} else {
						maxDy = maxDy
					}
					if Dy[i] < minDy {
						minDy = Dy[i]
					} else {
						minDy = minDy
					}
					if Dz[i] > maxDz {
						maxDz = Dz[i]
					} else {
						maxDz = maxDz
					}
					if Dz[i] < minDz {
						minDz = Dz[i]
					} else {
						minDz = minDz
					}
					if Rx[i] > maxRx {
						maxRx = Rx[i]
					} else {
						maxRx = maxRx
					}
					if Rx[i] < minRx {
						minRx = Rx[i]
					} else {
						minRx = minRx
					}
					if Sy[i] > maxSy {
						maxSy = Sy[i]
					} else {
						maxSy = maxSy
					}
					if Sy[i] < minSy {
						minSy = Sy[i]
					} else {
						minSy = minSy
					}
					if Sz[i] > maxSz {
						maxSz = Sz[i]
					} else {
						maxSz = maxSz
					}
					if Sz[i] < minSz {
						minSz = Sz[i]
					} else {
						minSz = minSz
					}
				}
			}
			// write max and min element forces to the internal frame element force output data file
			noarch.Fprintf(fpif, []byte("#                \tNx        \tVy        \tVz        \tTx        \tMy        \tMz        \tDx        \tDy        \tDz         \tRx\t*\n\x00"))
			noarch.Fprintf(fpif, []byte("# MAXIMUM\t%14.6e\t%14.6e\t%14.6e\t%14.6e\t%14.6e\t%14.6e\t%14.6e\t%14.6e\t%14.6e\t%14.6e\n\x00"), maxNx, maxVy, maxVz, maxTx, maxMy, maxMz, maxDx, maxDy, maxDz, maxRx)
			noarch.Fprintf(fpif, []byte("# MINIMUM\t%14.6e\t%14.6e\t%14.6e\t%14.6e\t%14.6e\t%14.6e\t%14.6e\t%14.6e\t%14.6e\t%14.6e\n\x00"), minNx, minVy, minVz, minTx, minMy, minMz, minDx, minDy, minDz, minRx)
			// write results to the internal frame element force output data file
			noarch.Fprintf(fpif, []byte("#.x                \tNx        \tVy        \tVz        \tTx       \tMy        \tMz        \tDx        \tDy        \tDz        \tRx\t~\n\x00"))
			for i = 0; i <= nx; i++ {
				noarch.Fprintf(fpif, []byte("%14.6e\t\x00"), x[i])
				noarch.Fprintf(fpif, []byte("%14.6e\t%14.6e\t%14.6e\t\x00"), Nx[i], Vy[i], Vz[i])
				noarch.Fprintf(fpif, []byte("%14.6e\t%14.6e\t%14.6e\t\x00"), Tx[i], My[i], Mz[i])
				noarch.Fprintf(fpif, []byte("%14.6e\t%14.6e\t%14.6e\t%14.6e\n\x00"), Dx[i], Dy[i], Dz[i], Rx[i])
			}
			noarch.Fprintf(fpif, []byte("#---------------------------------------\n\n\n\x00"))
			// write max and min element forces to the Frame3DD text output data file
			noarch.Fprintf(fp, []byte(" %5d   max  %10.3f  %10.3f %10.3f %10.3f %10.3f %10.3f\n\x00"), m, maxNx, maxVy, maxVz, maxTx, maxMy, maxMz)
			noarch.Fprintf(fp, []byte(" %5d   min  %10.3f  %10.3f %10.3f %10.3f %10.3f %10.3f\n\x00"), m, minNx, minVy, minVz, minTx, minMy, minMz)
			// write max and min element forces to the Frame3DD CSV output data file
			noarch.Fprintf(fpcsv, []byte(" %5d, \"max\", %10.3f,  %10.3f, %10.3f, %10.3f, %10.3f, %10.3f\n\x00"), m, maxNx, maxVy, maxVz, maxTx, maxMy, maxMz)
			noarch.Fprintf(fpcsv, []byte(" %5d, \"min\", %10.3f,  %10.3f, %10.3f, %10.3f, %10.3f, %10.3f\n\x00"), m, minNx, minVy, minVz, minTx, minMy, minMz)
			//
			//  fprintf(fp," %5d %10.6f  %10.6f  %10.6f  %10.6f  %10.6f  %10.6f\n",
			//    m, maxDx, maxDy, maxDz, maxRx, maxSy, maxSz );
			//  fprintf(fp," %5d %10.6f  %10.6f  %10.6f  %10.6f  %10.6f  %10.6f\n",
			//    m, minDx, minDy, minDz, minRx, minSy, minSz );
			//
			// free memory
			free_dvector(x, 0, nx)
			free_dvector(Nx, 0, nx)
			free_dvector(Vy, 0, nx)
			free_dvector(Vz, 0, nx)
			free_dvector(Tx, 0, nx)
			free_dvector(My, 0, nx)
			free_dvector(Mz, 0, nx)
			free_dvector(Rx, 0, nx)
			free_dvector(Sy, 0, nx)
			free_dvector(Sz, 0, nx)
			free_dvector(Dx, 0, nx)
			free_dvector(Dy, 0, nx)
			free_dvector(Dz, 0, nx)
		}
	}
	// end of loop over all frame elements
	noarch.Fclose(fpif)
	noarch.Fclose(fpcsv)
}
// write_modal_results - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:3118
func write_modal_results(fp *noarch.File, nN int32, nE int32, nI int32, DoF int32, M [][]float64, f []float64, V [][]float64, total_mass float64, struct_mass float64, iter int32, sumR int32, nM int32, shift float64, lump int32, tol float64, ok int32) {
	//
	// * WRITE_MODAL_RESULTS -  save modal frequencies and mode shapes
	// * 16 Aug 2001
	//
	var i int32
	var j int32
	var k int32
	var m int32
	var num_modes int32
	// mode participation factors
	var mpfX float64
	var mpfY float64
	var mpfZ float64
	var msX []float64
	var msY []float64
	var msZ []float64
	var fs float64
	msX = dvector(1, DoF)
	msY = dvector(1, DoF)
	msZ = dvector(1, DoF)
	for i = 1; i <= DoF; i++ {
		msZ[i] = 0
		msY[i] = msZ[i]
		msX[i] = msY[i]
		for j = 1; j <= DoF; j += 6 {
			msX[i] += M[i][j]
		}
		for j = 2; j <= DoF; j += 6 {
			msY[i] += M[i][j]
		}
		for j = 3; j <= DoF; j += 6 {
			msZ[i] += M[i][j]
		}
	}
	if DoF-sumR > nM {
		num_modes = nM
	} else {
		num_modes = DoF-sumR
	}
	noarch.Fprintf(fp, []byte("\nM O D A L   A N A L Y S I S   R E S U L T S\n\x00"))
	noarch.Fprintf(fp, []byte("  Total Mass:  %e   \x00"), total_mass)
	noarch.Fprintf(fp, []byte("  Structural Mass:  %e \n\x00"), struct_mass)
	noarch.Fprintf(fp, []byte("N O D A L   M A S S E S\x00"))
	noarch.Fprintf(fp, []byte("\t(diagonal of the mass matrix)\t\t\t(global)\n\x00"))
	noarch.Fprintf(fp, []byte("  Node  X-mass      Y-mass      Z-mass\x00"))
	noarch.Fprintf(fp, []byte("      X-inrta     Y-inrta     Z-inrta\n\x00"))
	for j = 1; j <= nN; j++ {
		k = 6*(j-1)
		noarch.Fprintf(fp, []byte(" %5d\x00"), j)
		for i = 1; i <= 6; i++ {
			noarch.Fprintf(fp, []byte(" %11.5e\x00"), M[k+i][k+i])
		}
		noarch.Fprintf(fp, []byte("\n\x00"))
	}
	if lump != 0 {
		noarch.Fprintf(fp, []byte("  Lump masses at nodes.\n\x00"))
	} else {
		noarch.Fprintf(fp, []byte("  Use consistent mass matrix.\n\x00"))
	}
	noarch.Fprintf(fp, []byte("N A T U R A L   F R E Q U E N C I E S   & \n\x00"))
	noarch.Fprintf(fp, []byte("M A S S   N O R M A L I Z E D   M O D E   S H A P E S \n\x00"))
	noarch.Fprintf(fp, []byte(" convergence tolerance: %.3e \n\x00"), tol)
	for m = 1; m <= num_modes; m++ {
		mpfX = 0
		for i = 1; i <= DoF; i++ {
			mpfX += V[i][m]*msX[i]
		}
		mpfY = 0
		for i = 1; i <= DoF; i++ {
			mpfY += V[i][m]*msY[i]
		}
		mpfZ = 0
		for i = 1; i <= DoF; i++ {
			mpfZ += V[i][m]*msZ[i]
		}
		noarch.Fprintf(fp, []byte("  MODE %5d:   f= %f Hz,  T= %f sec\n\x00\x00\x00"), m, f[m], 1/f[m])
		noarch.Fprintf(fp, []byte("\t\tX- modal participation factor = %12.4e \n\x00"), mpfX)
		noarch.Fprintf(fp, []byte("\t\tY- modal participation factor = %12.4e \n\x00"), mpfY)
		noarch.Fprintf(fp, []byte("\t\tZ- modal participation factor = %12.4e \n\x00"), mpfZ)
		noarch.Fprintf(fp, []byte("  Node    X-dsp       Y-dsp       Z-dsp\x00"))
		noarch.Fprintf(fp, []byte("       X-rot       Y-rot       Z-rot\n\x00"))
		for j = 1; j <= nN; j++ {
			noarch.Fprintf(fp, []byte(" %5d\x00"), j)
			for i = 5; i >= 0; i-- {
				noarch.Fprintf(fp, []byte(" %11.3e\x00"), V[6*j-i][m])
			}
			noarch.Fprintf(fp, []byte("\n\x00"))
		}
	}
	noarch.Fprintf(fp, []byte("M A T R I X    I T E R A T I O N S: %d\n\x00"), iter)
	fs = math.Sqrt(4*3.141592653589793*3.141592653589793*f[nM]*f[nM]+tol)/(2*3.141592653589793)
	noarch.Fprintf(fp, []byte("There are %d modes below %f Hz.\x00"), -ok, fs)
	if -ok > nM {
		noarch.Fprintf(fp, []byte(" ... %d modes were not found.\n\x00"), -ok-nM)
		noarch.Fprintf(fp, []byte(" Try increasing the number of modes in \n\x00"))
		noarch.Fprintf(fp, []byte(" order to get the missing modes below %f Hz.\n\x00"), fs)
	} else {
		noarch.Fprintf(fp, []byte(" ... All %d modes were found.\n\x00"), nM)
	}
	free_dvector(msX, 1, DoF)
	free_dvector(msY, 1, DoF)
	free_dvector(msZ, 1, DoF)
	noarch.Fflush(fp)
}
// static_mesh - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:3211
func static_mesh(IN_file []byte, infcpath []byte, meshpath []byte, plotpath []byte, title []byte, nN int32, nE int32, nL int32, lc int32, DoF int32, xyz []vec3, L []float64, N1 []int32, N2 []int32, p []float32, D []float64, exagg_static float64, D3_flag int32, anlyz int32, dx float32, scale float32) {
	//
	// * STATIC_MESH  - create mesh data of deformed and undeformed mesh  22 Feb 1999
	// * use gnuplot
	// * useful gnuplot options: unset xtics ytics ztics border view key
	// * This function illustrates how to read the internal force output data file.
	// * The internal force output data file contains all the information required
	// * to plot deformed meshes, internal axial force, internal shear force, internal
	// * torsion, and internal bending moment diagrams.
	//
	var fpif *noarch.File
	var fpm *noarch.File
	// coordinates of the frame element number labels
	var mx float64
	var my float64
	var mz float64
	var fnif []byte = make([]byte, 128)
	var meshfl []byte = make([]byte, 128)
	var D2 byte = '#'
	var D3 byte = '#'
	var errMsg []byte = make([]byte, 512)
	var ch byte = 'a'
	// indicates plotting in 2D or 3D
	// *scanf return value
	var sfrv int32
	var frel int32
	var nx int32
	var n1 int32
	var n2 int32
	// frame element number, number of increments
	// node numbers
	// coordinates of node n1
	var x1 float32
	var y1 float32
	var z1 float32
	var x2 float32
	var y2 float32
	var z2 float32
	// coordinates of node n2
	var j int32
	var m int32
	var n int32
	var X int32
	var Y int32
	var Z int32
	var lw int32 = 1
	//  line width of deformed mesh
	// modern time variable type
	var now noarch.TimeT
	_ = noarch.Time((*[1000000]noarch.TimeT)(unsafe.Pointer(&now))[:])
	{
		// write gnuplot plotting script commands
		// check for three-dimensional frame
		for j = 1; j <= nN; j++ {
			if xyz[j].x != 0 {
				X = 1
			}
			if xyz[j].y != 0 {
				Y = 1
			}
			if xyz[j].z != 0 {
				Z = 1
			}
		}
	}
	if X != 0 && Y != 0 && Z != 0 || D3_flag != 0 {
		D3 = ' '
		D2 = '#'
	} else {
		D3 = '#'
		D2 = ' '
	}
	if lc <= 1 {
		if (func() *noarch.File {
			fpm = noarch.Fopen(plotpath, []byte("w\x00"))
			return fpm
		}()) == nil {
			// open plotting script file for writing
			noarch.Sprintf(errMsg, []byte("\n  error: cannot open gnuplot script file: %s \n\x00"), plotpath)
			errorMsg(errMsg)
			unix.Exit(23)
		}
	} else {
		if (func() *noarch.File {
			fpm = noarch.Fopen(plotpath, []byte("a\x00"))
			return fpm
		}()) == nil {
			// open plotting script file for appending
			noarch.Sprintf(errMsg, []byte("\n  error: cannot open gnuplot script file: %s \n\x00"), plotpath)
			errorMsg(errMsg)
			unix.Exit(24)
		}
	}
	if lc >= 1 && anlyz != 0 {
		// file name for deformed mesh data for load case "lc"
		noarch.Sprintf(meshfl, []byte("%sf.%03d\x00"), meshpath, lc)
	}
	if lc <= 1 {
		// write header, plot-setup cmds, node label, and element label data
		// header & node number & element number labels
		//frame3dd.sf.net/");
		noarch.Fprintf(fpm, []byte("# FRAME3DD ANALYSIS RESULTS  http://frame3dd.sf.net/\x00"))
		noarch.Fprintf(fpm, []byte(" VERSION %s \n\x00"), []byte("20140514+\x00"))
		noarch.Fprintf(fpm, []byte("# %s\n\x00"), title)
		noarch.Fprintf(fpm, []byte("# %s\x00"), noarch.Ctime((*[1000000]noarch.TimeT)(unsafe.Pointer(&now))[:]))
		noarch.Fprintf(fpm, []byte("# G N U P L O T   S C R I P T   F I L E \n\x00"))
		// fprintf(fpm,"#  X=%d , Y=%d , Z=%d, D3=%d  \n", X,Y,Z,D3_flag);
		noarch.Fprintf(fpm, []byte("set autoscale\n\x00"))
		noarch.Fprintf(fpm, []byte("unset border\n\x00"))
		noarch.Fprintf(fpm, []byte("set pointsize 1.0\n\x00"))
		noarch.Fprintf(fpm, []byte("set xtics; set ytics; set ztics; \n\x00"))
		noarch.Fprintf(fpm, []byte("unset zeroaxis\n\x00"))
		noarch.Fprintf(fpm, []byte("unset key\n\x00"))
		noarch.Fprintf(fpm, []byte("unset label\n\x00"))
		noarch.Fprintf(fpm, []byte("set size ratio -1    # 1:1 2D axis scaling \n\x00"))
		noarch.Fprintf(fpm, []byte("# set view equal xyz # 1:1 3D axis scaling \n\x00"))
		noarch.Fprintf(fpm, []byte("# NODE NUMBER LABELS\n\x00"))
		for j = 1; j <= nN; j++ {
			noarch.Fprintf(fpm, []byte("set label ' %d' at %12.4e, %12.4e, %12.4e\n\x00"), j, xyz[j].x, xyz[j].y, xyz[j].z)
		}
		noarch.Fprintf(fpm, []byte("# ELEMENT NUMBER LABELS\n\x00"))
		for m = 1; m <= nE; m++ {
			n1 = N1[m]
			n2 = N2[m]
			mx = 0.5*(xyz[n1].x+xyz[n2].x)
			my = 0.5*(xyz[n1].y+xyz[n2].y)
			mz = 0.5*(xyz[n1].z+xyz[n2].z)
			noarch.Fprintf(fpm, []byte("set label ' %d' at %12.4e, %12.4e, %12.4e\n\x00"), m, mx, my, mz)
		}
		// 3D plot setup commands
		noarch.Fprintf(fpm, []byte("%c set parametric\n\x00"), int32(D3))
		noarch.Fprintf(fpm, []byte("%c set view 60, 70, %5.2f \n\x00"), int32(D3), float64(scale))
		noarch.Fprintf(fpm, []byte("%c set view equal xyz # 1:1 3D axis scaling \n\x00"), int32(D3))
		noarch.Fprintf(fpm, []byte("%c unset key\n\x00"), int32(D3))
		noarch.Fprintf(fpm, []byte("%c set xlabel 'x'\n\x00"), int32(D3))
		noarch.Fprintf(fpm, []byte("%c set ylabel 'y'\n\x00"), int32(D3))
		noarch.Fprintf(fpm, []byte("%c set zlabel 'z'\n\x00"), int32(D3))
	}
	//  fprintf(fpm,"%c unset label\n", D3 );
	// different plot title for each load case
	noarch.Fprintf(fpm, []byte("set title \"%s\\n\x00"), title)
	noarch.Fprintf(fpm, []byte("analysis file: %s \x00"), IN_file)
	if anlyz != 0 {
		noarch.Fprintf(fpm, []byte("  deflection exaggeration: %.1f \x00"), exagg_static)
		noarch.Fprintf(fpm, []byte("  load case %d of %d \"\n\x00"), lc, nL)
	} else {
		noarch.Fprintf(fpm, []byte("  data check only \"\n\x00"))
	}
	noarch.Fprintf(fpm, []byte("unset clip; \nset clip one; set clip two\n\x00"))
	// requires Gnuplot >= 4.6
	noarch.Fprintf(fpm, []byte("set xyplane 0 \n\x00"))
	// 2D plot command
	noarch.Fprintf(fpm, []byte("%c plot '%s' u 2:3 t 'undeformed mesh' w lp \x00"), int32(D2), meshpath)
	if noarch.Not(anlyz) {
		noarch.Fprintf(fpm, []byte("lw %d lt 1 pt 6 \n\x00"), lw)
	} else {
		noarch.Fprintf(fpm, []byte("lw 1 lt 5 pt 6, '%s' u 1:2 t 'load case %d of %d' w l lw %d lt 3\n\x00"), meshfl, lc, nL, lw)
	}
	// 3D plot command
	noarch.Fprintf(fpm, []byte("%c splot '%s' u 2:3:4 t 'load case %d of %d' w lp \x00"), int32(D3), meshpath, lc, nL)
	if noarch.Not(anlyz) {
		noarch.Fprintf(fpm, []byte(" lw %d lt 1 pt 6 \n\x00"), lw)
	} else {
		noarch.Fprintf(fpm, []byte(" lw 1 lt 5 pt 6, '%s' u 1:2:3 t 'load case %d of %d' w l lw %d lt 3\n\x00"), meshfl, lc, nL, lw)
	}
	if lc < nL && anlyz != 0 {
		noarch.Fprintf(fpm, []byte("pause -1\n\x00"))
	}
	noarch.Fclose(fpm)
	if lc <= 1 {
		if (func() *noarch.File {
			fpm = noarch.Fopen(meshpath, []byte("w\x00"))
			return fpm
		}()) == nil {
			// write undeformed mesh data
			// open the undeformed mesh data file for writing
			noarch.Sprintf(errMsg, []byte("\n  error: cannot open gnuplot undeformed mesh data file: %s\n\x00"), meshpath)
			errorMsg(errMsg)
			unix.Exit(21)
		}
		//frame3dd.sf.net/");
		noarch.Fprintf(fpm, []byte("# FRAME3DD ANALYSIS RESULTS  http://frame3dd.sf.net/\x00"))
		noarch.Fprintf(fpm, []byte(" VERSION %s \n\x00"), []byte("20140514+\x00"))
		noarch.Fprintf(fpm, []byte("# %s\n\x00"), title)
		noarch.Fprintf(fpm, []byte("# %s\x00"), noarch.Ctime((*[1000000]noarch.TimeT)(unsafe.Pointer(&now))[:]))
		noarch.Fprintf(fpm, []byte("# U N D E F O R M E D   M E S H   D A T A   (global coordinates)\n\x00"))
		noarch.Fprintf(fpm, []byte("# Node        X            Y            Z \n\x00"))
		for m = 1; m <= nE; m++ {
			// i = 6*(n-1);
			n = N1[m]
			noarch.Fprintf(fpm, []byte("%5d %12.4e %12.4e %12.4e \n\x00"), n, xyz[n].x, xyz[n].y, xyz[n].z)
			// i = 6*(n-1);
			n = N2[m]
			noarch.Fprintf(fpm, []byte("%5d %12.4e %12.4e %12.4e\x00"), n, xyz[n].x, xyz[n].y, xyz[n].z)
			noarch.Fprintf(fpm, []byte("\n\n\n\x00"))
		}
		noarch.Fclose(fpm)
	}
	if noarch.Not(anlyz) {
		// no deformed mesh
		return
	}
	if (func() *noarch.File {
		fpm = noarch.Fopen(meshfl, []byte("w\x00"))
		return fpm
	}()) == nil {
		// write deformed mesh data
		// open the deformed mesh data file for writing
		noarch.Sprintf(errMsg, []byte("\n  error: cannot open gnuplot deformed mesh data file %s \n\x00"), meshfl)
		errorMsg(errMsg)
		unix.Exit(22)
	}
	//frame3dd.sf.net/");
	noarch.Fprintf(fpm, []byte("# FRAME3DD ANALYSIS RESULTS  http://frame3dd.sf.net/\x00"))
	noarch.Fprintf(fpm, []byte(" VERSION %s \n\x00"), []byte("20140514+\x00"))
	noarch.Fprintf(fpm, []byte("# %s\n\x00"), title)
	noarch.Fprintf(fpm, []byte("# L O A D  C A S E   %d  of   %d \n\x00"), lc, nL)
	noarch.Fprintf(fpm, []byte("# %s\x00"), noarch.Ctime((*[1000000]noarch.TimeT)(unsafe.Pointer(&now))[:]))
	noarch.Fprintf(fpm, []byte("# D E F O R M E D   M E S H   D A T A \x00"))
	noarch.Fprintf(fpm, []byte("  deflection exaggeration: %.1f\n\x00"), exagg_static)
	noarch.Fprintf(fpm, []byte("#       X-dsp        Y-dsp        Z-dsp\n\x00"))
	if float64(dx) > 0 && anlyz != 0 {
		// open the interior force data file for reading
		// file name for internal force data for load case "lc"
		noarch.Sprintf(fnif, []byte("%s%02d\x00"), infcpath, lc)
		if (func() *noarch.File {
			fpif = noarch.Fopen(fnif, []byte("r\x00"))
			return fpif
		}()) == nil {
			noarch.Sprintf(errMsg, []byte("\n  error: cannot open interior force data file: %s \n\x00"), fnif)
			errorMsg(errMsg)
			unix.Exit(20)
		}
	}
	{
		// write deformed shape data for each element
		for m = 1; m <= nE; m++ {
			ch = 'a'
			noarch.Fprintf(fpm, []byte("\n# element %5d \n\x00"), m)
			if float64(dx) < 0 && anlyz != 0 {
				cubic_bent_beam(fpm, N1[m], N2[m], xyz, L[m], p[m], D, exagg_static)
			}
			if float64(dx) > 0 && anlyz != 0 {
				for int32(ch) != int32('@') {
					ch = byte(noarch.Fgetc(fpif))
				}
				sfrv = noarch.Fscanf(fpif, []byte("%d %d %d %f %f %f %f %f %f %d\x00"), c4goUnsafeConvert_int32(&frel), c4goUnsafeConvert_int32(&n1), c4goUnsafeConvert_int32(&n2), c4goUnsafeConvert_float32(&x1), c4goUnsafeConvert_float32(&y1), c4goUnsafeConvert_float32(&z1), c4goUnsafeConvert_float32(&x2), c4goUnsafeConvert_float32(&y2), c4goUnsafeConvert_float32(&z2), c4goUnsafeConvert_int32(&nx))
				if sfrv != 10 {
					sferr(fnif)
				}
				if frel != m || N1[m] != n1 || N2[m] != n2 {
					noarch.Fprintf(noarch.Stderr, []byte(" error in static_mesh parsing\n\x00"))
					noarch.Fprintf(noarch.Stderr, []byte("  frel = %d; m = %d; nx = %d \n\x00"), frel, m, nx)
				}
				for int32(ch) != int32('~') {
					// debugging ... check mesh data
					//   printf("  frel = %3d; m = %3d; n1 =%4d; n2 = %4d; nx = %3d L = %f \n", frel,m,n1,n2,nx,L[m] );
					//
					ch = byte(noarch.Fgetc(fpif))
				}
				force_bent_beam(fpm, fpif, fnif, nx, N1[m], N2[m], xyz, L[m], p[m], D, exagg_static)
			}
		}
	}
	if float64(dx) > 0 && anlyz != 0 {
		noarch.Fclose(fpif)
	}
	noarch.Fclose(fpm)
}
// modal_mesh - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:3447
func modal_mesh(IN_file []byte, meshpath []byte, modepath []byte, plotpath []byte, title []byte, nN int32, nE int32, DoF int32, nM int32, xyz []vec3, L []float64, J1 []int32, J2 []int32, p []float32, M [][]float64, f []float64, V [][]float64, exagg_modal float64, D3_flag int32, anlyz int32) {
	//
	// * MODAL_MESH  -  create mesh data of the mode-shape meshes, use gnuplot 19oct98
	// * useful gnuplot options: unset xtics ytics ztics border view key
	//
	var fpm *noarch.File
	// mode participation factors
	var mpfX float64
	var mpfY float64
	var mpfZ float64
	var msX []float64
	var msY []float64
	var msZ []float64
	// a mode-shape vector
	var v []float64
	var i int32
	var j int32
	var m int32
	var n int32
	var X int32
	var Y int32
	var Z int32
	//  line thickness of deformed mesh
	var lw int32 = 1
	// indicate 2D or 3D frame
	var D2 byte = '#'
	var D3 byte = '#'
	var modefl []byte = make([]byte, 128)
	var errMsg []byte = make([]byte, 512)
	msX = dvector(1, DoF)
	msY = dvector(1, DoF)
	msZ = dvector(1, DoF)
	v = dvector(1, DoF)
	{
		// modal participation factors
		for i = 1; i <= DoF; i++ {
			msZ[i] = 0
			msY[i] = msZ[i]
			msX[i] = msY[i]
			for j = 1; j <= DoF; j += 6 {
				msX[i] += M[i][j]
			}
			for j = 2; j <= DoF; j += 6 {
				msY[i] += M[i][j]
			}
			for j = 3; j <= DoF; j += 6 {
				msZ[i] += M[i][j]
			}
		}
	}
	if noarch.Not(anlyz) {
		exagg_modal = 0
	}
	for m = 1; m <= nM; m++ {
		noarch.Sprintf(modefl, []byte("%s-%02d-\x00"), modepath, m)
		if (func() *noarch.File {
			fpm = noarch.Fopen(modefl, []byte("w\x00"))
			return fpm
		}()) == nil {
			noarch.Sprintf(errMsg, []byte("\n  error: cannot open gnuplot modal mesh file: %s \n\x00"), modefl)
			errorMsg(errMsg)
			unix.Exit(27)
		}
		//frame3dd.sf.net/");
		noarch.Fprintf(fpm, []byte("# FRAME3DD ANALYSIS RESULTS  http://frame3dd.sf.net/\x00"))
		noarch.Fprintf(fpm, []byte(" VERSION %s \n\x00"), []byte("20140514+\x00"))
		noarch.Fprintf(fpm, []byte("# %s\n\x00"), title)
		noarch.Fprintf(fpm, []byte("# M O D E   S H A P E   D A T A   F O R   M O D E\x00"))
		noarch.Fprintf(fpm, []byte("   %d\t(global coordinates)\n\x00"), m)
		noarch.Fprintf(fpm, []byte("# deflection exaggeration: %.1f\n\n\x00"), exagg_modal)
		mpfX = 0
		for i = 1; i <= DoF; i++ {
			mpfX += V[i][m]*msX[i]
		}
		mpfY = 0
		for i = 1; i <= DoF; i++ {
			mpfY += V[i][m]*msY[i]
		}
		mpfZ = 0
		for i = 1; i <= DoF; i++ {
			mpfZ += V[i][m]*msZ[i]
		}
		noarch.Fprintf(fpm, []byte("# MODE %5d:   f= %f Hz, T= %f sec\n\x00\x00\x00"), m, f[m], 1/f[m])
		noarch.Fprintf(fpm, []byte("#\t\tX- modal participation factor = %12.4e \n\x00"), mpfX)
		noarch.Fprintf(fpm, []byte("#\t\tY- modal participation factor = %12.4e \n\x00"), mpfY)
		noarch.Fprintf(fpm, []byte("#\t\tZ- modal participation factor = %12.4e \n\x00"), mpfZ)
		for i = 1; i <= DoF; i++ {
			v[i] = V[i][m]
		}
		noarch.Fprintf(fpm, []byte("#      X-dsp       Y-dsp       Z-dsp\n\n\x00"))
		for n = 1; n <= nE; n++ {
			noarch.Fprintf(fpm, []byte("\n# element %5d \n\x00"), n)
			cubic_bent_beam(fpm, J1[n], J2[n], xyz, L[n], p[n], v, exagg_modal)
		}
		noarch.Fclose(fpm)
		{
			// check for three-dimensional frame
			for j = 1; j <= nN; j++ {
				if xyz[j].x != 0 {
					X = 1
				}
				if xyz[j].y != 0 {
					Y = 1
				}
				if xyz[j].z != 0 {
					Z = 1
				}
			}
		}
		if X != 0 && Y != 0 && Z != 0 || D3_flag != 0 {
			D3 = ' '
			D2 = '#'
		} else {
			D3 = '#'
			D2 = ' '
		}
		if (func() *noarch.File {
			fpm = noarch.Fopen(plotpath, []byte("a\x00"))
			return fpm
		}()) == nil {
			noarch.Sprintf(errMsg, []byte("\n  error: cannot append gnuplot script file: %s \n\x00"), plotpath)
			errorMsg(errMsg)
			unix.Exit(25)
		}
		noarch.Fprintf(fpm, []byte("pause -1\n\x00"))
		if m == 1 {
			noarch.Fprintf(fpm, []byte("unset label\n\x00"))
			noarch.Fprintf(fpm, []byte("%c unset key\n\x00"), int32(D3))
		}
		noarch.Fprintf(fpm, []byte("set title '%s     mode %d     %f Hz'\n\x00\x00"), IN_file, m, f[m])
		// 2D plot command
		noarch.Fprintf(fpm, []byte("%c plot '%s' u 2:3 t 'undeformed mesh' w l \x00"), int32(D2), meshpath)
		if noarch.Not(anlyz) {
			noarch.Fprintf(fpm, []byte(" lw %d lt 1 \n\x00"), lw)
		} else {
			noarch.Fprintf(fpm, []byte(" lw 1 lt 5 , '%s' u 1:2 t 'mode-shape %d' w l lw %d lt 3\n\x00"), modefl, m, lw)
		}
		// 3D plot command
		noarch.Fprintf(fpm, []byte("%c splot '%s' u 2:3:4 t 'undeformed mesh' w l \x00"), int32(D3), meshpath)
		if noarch.Not(anlyz) {
			noarch.Fprintf(fpm, []byte(" lw %d lt 1 \n\x00"), lw)
		} else {
			noarch.Fprintf(fpm, []byte(" lw 1 lt 5 , '%s' u 1:2:3 t 'mode-shape %d' w l lw %d lt 3\n\x00"), modefl, m, lw)
		}
		noarch.Fclose(fpm)
	}
	free_dvector(msX, 1, DoF)
	free_dvector(msY, 1, DoF)
	free_dvector(msZ, 1, DoF)
	free_dvector(v, 1, DoF)
}
// animate - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:3575
func animate(IN_file []byte, meshpath []byte, modepath []byte, plotpath []byte, title []byte, anim []int32, nN int32, nE int32, DoF int32, nM int32, xyz []vec3, L []float64, p []float32, J1 []int32, J2 []int32, f []float64, V [][]float64, exagg_modal float64, D3_flag int32, pan float32, scale float32) {
	//
	// * ANIMATE -  create mesh data of animated mode-shape meshes, use gnuplot 16dec98
	// * useful gnuplot options: unset xtics ytics ztics border view key
	// * mpeg movie example:   % convert mesh_file-03-f-*.ps mode-03.mpeg
	// * ... requires ImageMagick and mpeg2vidcodec packages
	//
	// pan rate for animation
	// inital zoom scale in 3D animation
	var fpm *noarch.File
	var x_min float32
	var x_max float32
	var y_min float32
	var y_max float32
	var z_min float32
	var z_max float32
	var Dxyz float32
	var rot_x_init float32 = float32(70)
	var rot_x_final float32 = float32(60)
	var rot_z_init float32 = float32(100)
	var rot_z_final float32 = float32(120)
	var zoom_init float32 = float32(1 * float64(scale))
	var zoom_final float32 = float32(1.1 * float64(scale))
	var frames float32 = 25
	// "diameter" of the structure
	// inital x-rotation in 3D animation
	// final  x-rotation in 3D animation
	// inital z-rotation in 3D animation
	// final  z-rotation in 3D animation
	// init.  zoom scale in 3D animation
	// final  zoom scale in 3D animation
	// number of frames in animation
	// an exageration factor, for animation
	var ex float64 = 10
	var v []float64
	var fr int32
	var i int32
	var j int32
	var m int32
	var n int32
	var X int32
	var Y int32
	var Z int32
	var c int32
	var CYCLES int32 = 3
	var frame_number int32
	var lw int32 = 1
	var total_frames int32
	//  line thickness of deformed mesh
	// total number of frames in animation
	// indicate 2D or 3D frame
	var D2 byte = '#'
	var D3 byte = '#'
	var Movie byte = '#'
	var modefl []byte = make([]byte, 128)
	var framefl []byte = make([]byte, 128)
	// use '#' for no-movie  -OR-  ' ' for movie
	var errMsg []byte = make([]byte, 512)
	{
		// check for three-dimensional frame
		for j = 1; j <= nN; j++ {
			if xyz[j].x != 0 {
				X = 1
			}
			if xyz[j].y != 0 {
				Y = 1
			}
			if xyz[j].z != 0 {
				Z = 1
			}
			if j == 1 {
				x_max = float32(xyz[j].x)
				x_min = x_max
				y_max = float32(xyz[j].y)
				y_min = y_max
				z_max = float32(xyz[j].z)
				z_min = z_max
			}
			if xyz[j].x < float64(x_min) {
				x_min = float32(xyz[j].x)
			}
			if xyz[j].y < float64(y_min) {
				y_min = float32(xyz[j].y)
			}
			if xyz[j].z < float64(z_min) {
				z_min = float32(xyz[j].z)
			}
			if float64(x_max) < xyz[j].x {
				x_max = float32(xyz[j].x)
			}
			if float64(y_max) < xyz[j].y {
				y_max = float32(xyz[j].y)
			}
			if float64(z_max) < xyz[j].z {
				z_max = float32(xyz[j].z)
			}
		}
	}
	if X != 0 && Y != 0 && Z != 0 || D3_flag != 0 {
		D3 = ' '
		D2 = '#'
	} else {
		D3 = '#'
		D2 = ' '
	}
	Dxyz = float32(math.Sqrt(float64((x_max-x_min)*(x_max-x_min)+(y_max-y_min)*(y_max-y_min)+(z_max-z_min)*(z_max-z_min))))
	if (func() *noarch.File {
		fpm = noarch.Fopen(plotpath, []byte("a\x00"))
		return fpm
	}()) == nil {
		noarch.Sprintf(errMsg, []byte("\n  error: cannot append gnuplot script file: %s \n\x00"), plotpath)
		errorMsg(errMsg)
		unix.Exit(26)
	}
	i = 1
	for (func() int32 {
		m = anim[i]
		return m
	}()) != 0 && i < 100 {
		if i == 1 {
			noarch.Fprintf(fpm, []byte("\n# --- M O D E   S H A P E   A N I M A T I O N ---\n\x00"))
			noarch.Fprintf(fpm, []byte("# rot_x_init  = %7.2f\n\x00"), float64(rot_x_init))
			noarch.Fprintf(fpm, []byte("# rot_x_final = %7.2f\n\x00"), float64(rot_x_final))
			noarch.Fprintf(fpm, []byte("# rot_z_init  = %7.2f\n\x00"), float64(rot_z_init))
			noarch.Fprintf(fpm, []byte("# rot_z_final = %7.2f\n\x00"), float64(rot_z_final))
			noarch.Fprintf(fpm, []byte("# zoom_init   = %7.2f\n\x00"), float64(zoom_init))
			noarch.Fprintf(fpm, []byte("# zoom_final  = %7.2f\n\x00"), float64(zoom_init))
			noarch.Fprintf(fpm, []byte("# pan rate    = %7.2f \n\x00"), float64(pan))
			noarch.Fprintf(fpm, []byte("set autoscale\n\x00"))
			noarch.Fprintf(fpm, []byte("unset border\n\x00"))
			noarch.Fprintf(fpm, []byte("%c unset xlabel \n\x00"), int32(D3))
			noarch.Fprintf(fpm, []byte("%c unset ylabel \n\x00"), int32(D3))
			noarch.Fprintf(fpm, []byte("%c unset zlabel \n\x00"), int32(D3))
			noarch.Fprintf(fpm, []byte("%c unset label \n\x00"), int32(D3))
			noarch.Fprintf(fpm, []byte("unset key\n\x00"))
			noarch.Fprintf(fpm, []byte("%c set parametric\n\x00"), int32(D3))
			noarch.Fprintf(fpm, []byte("# x_min = %12.5e     x_max = %12.5e \n\x00"), float64(x_min), float64(x_max))
			noarch.Fprintf(fpm, []byte("# y_min = %12.5e     y_max = %12.5e \n\x00"), float64(y_min), float64(y_max))
			noarch.Fprintf(fpm, []byte("# z_min = %12.5e     z_max = %12.5e \n\x00"), float64(z_min), float64(z_max))
			noarch.Fprintf(fpm, []byte("# Dxyz = %12.5e \n\x00"), float64(Dxyz))
			noarch.Fprintf(fpm, []byte("set xrange [ %f : %f ] \n\x00\x00\x00"), float64(x_min)-0.2*float64(Dxyz), float64(x_max)+0.1*float64(Dxyz))
			noarch.Fprintf(fpm, []byte("set yrange [ %f : %f ] \n\x00\x00\x00"), float64(y_min)-0.2*float64(Dxyz), float64(y_max)+0.1*float64(Dxyz))
			noarch.Fprintf(fpm, []byte("set zrange [ %f : %f ] \n\x00\x00\x00"), float64(z_min)-0.2*float64(Dxyz), float64(z_max)+0.1*float64(Dxyz))
			//
			// *    if ( x_min != x_max )
			// *   fprintf(fpm,"set xrange [ %lf : %lf ] \n",
			// *    x_min-0.2*(x_max-x_min), x_max+0.2*(x_max-x_min) );
			// *    else fprintf(fpm,"set xrange [ %lf : %lf ] \n",
			// *   x_min-exagg_modal, x_max+exagg_modal );
			// *    if (y_min != y_max)
			// *   fprintf(fpm,"set yrange [ %lf : %lf ] \n",
			// *    y_min-0.2*(y_max-y_min), y_max+0.2*(y_max-y_min) );
			// *    else fprintf(fpm,"set yrange [ %lf : %lf ] \n",
			// *   y_min-exagg_modal, y_max+exagg_modal );
			// *    if (z_min != z_max)
			// *     fprintf(fpm,"set zrange [ %lf : %lf ] \n",
			// *      z_min-0.2*(z_max-z_min), z_max+0.2*(z_max-z_min) );
			// *    else fprintf(fpm,"set zrange [ %lf : %lf ] \n",
			// *   z_min-exagg_modal, z_max+exagg_modal );
			//
			noarch.Fprintf(fpm, []byte("unset xzeroaxis; unset yzeroaxis; unset zzeroaxis\n\x00"))
			noarch.Fprintf(fpm, []byte("unset xtics; unset ytics; unset ztics; \n\x00"))
			noarch.Fprintf(fpm, []byte("%c set view 60, 70, %5.2f \n\x00"), int32(D3), float64(scale))
			noarch.Fprintf(fpm, []byte("set size ratio -1    # 1:1 2D axis scaling \n\x00"))
			noarch.Fprintf(fpm, []byte("%c set view equal xyz # 1:1 3D axis scaling \n\x00"), int32(D3))
		}
		noarch.Fprintf(fpm, []byte("pause -1 \n\x00"))
		noarch.Fprintf(fpm, []byte("set title '%s     mode %d      %f Hz'\n\x00\x00"), IN_file, m, f[m])
		frame_number = 0
		total_frames = int32(float32(2*CYCLES)*frames)
		for c = 1; c <= CYCLES; c++ {
			for fr = 0; float32(fr) <= frames; fr++ {
				frame_number ++
				noarch.Sprintf(modefl, []byte("%s-%02d.%03d\x00"), modepath, m, fr)
				noarch.Sprintf(framefl, []byte("%s-%02d-f-%03d.ps\x00"), modepath, m, fr)
				noarch.Fprintf(fpm, []byte("%c plot '%s' u 2:3 w l lw 1 lt 5, \x00"), int32(D2), meshpath)
				noarch.Fprintf(fpm, []byte(" '%s' u 1:2 w l lw %d lt 3 ; \n\x00"), modefl, lw)
				if float64(pan) != 0 {
					noarch.Fprintf(fpm, []byte("%c set view %7.2f, %7.2f, %5.3f # pan = %f\n\x00"), int32(D3), float64(rot_x_init+pan*(rot_x_final-rot_x_init)*float32(frame_number)/float32(total_frames)), float64(rot_z_init+pan*(rot_z_final-rot_z_init)*float32(frame_number)/float32(total_frames)), float64(zoom_init+pan*(zoom_final-zoom_init)*float32(frame_number)/float32(total_frames)), float64(pan))
				}
				noarch.Fprintf(fpm, []byte("%c splot '%s' u 2:3:4 w l lw 1 lt 5, \x00"), int32(D3), meshpath)
				noarch.Fprintf(fpm, []byte(" '%s' u 1:2:3 w l lw %d lt 3;\x00"), modefl, lw)
				if fr == 0 && c == 1 {
					noarch.Fprintf(fpm, []byte("  pause 1.5 \n\x00"))
				} else {
					noarch.Fprintf(fpm, []byte("  pause 0.05 \n\x00"))
				}
				noarch.Fprintf(fpm, []byte("%c  load 'saveplot';\n\x00"), int32(Movie))
				noarch.Fprintf(fpm, []byte("%c  !mv my-plot.ps %s\n\x00"), int32(Movie), framefl)
			}
			for fr = int32(frames-1); fr > 0; fr-- {
				frame_number ++
				noarch.Sprintf(modefl, []byte("%s-%02d.%03d\x00"), modepath, m, fr)
				noarch.Sprintf(framefl, []byte("%s-%02d-f-%03d.ps\x00"), modepath, m, fr)
				noarch.Fprintf(fpm, []byte("%c plot '%s' u 2:3 w l lw 1 lt 5, \x00"), int32(D2), meshpath)
				noarch.Fprintf(fpm, []byte(" '%s' u 1:2 w l lw %d lt 3; \n\x00"), modefl, lw)
				if float64(pan) != 0 {
					noarch.Fprintf(fpm, []byte("%c set view %7.2f, %7.2f, %5.3f # pan = %f\n\x00"), int32(D3), float64(rot_x_init+pan*(rot_x_final-rot_x_init)*float32(frame_number)/float32(total_frames)), float64(rot_z_init+pan*(rot_z_final-rot_z_init)*float32(frame_number)/float32(total_frames)), float64(zoom_init+pan*(zoom_final-zoom_init)*float32(frame_number)/float32(total_frames)), float64(pan))
				}
				noarch.Fprintf(fpm, []byte("%c splot '%s' u 2:3:4 w l lw 1 lt 5, \x00"), int32(D3), meshpath)
				noarch.Fprintf(fpm, []byte(" '%s' u 1:2:3 w l lw %d lt 3;\x00"), modefl, lw)
				noarch.Fprintf(fpm, []byte("  pause 0.05 \n\x00"))
				noarch.Fprintf(fpm, []byte("%c  load 'saveplot';\n\x00"), int32(Movie))
				noarch.Fprintf(fpm, []byte("%c  !mv my-plot.ps %s\n\x00"), int32(Movie), framefl)
			}
		}
		fr = 0
		noarch.Sprintf(modefl, []byte("%s-%02d.%03d\x00"), modepath, m, fr)
		noarch.Fprintf(fpm, []byte("%c plot '%s' u 2:3 w l lw %d lt 5, \x00"), int32(D2), meshpath, lw)
		noarch.Fprintf(fpm, []byte(" '%s' u 1:2 w l lw 3 lt 3 \n\x00"), modefl)
		noarch.Fprintf(fpm, []byte("%c splot '%s' u 2:3:4 w l lw %d lt 5, \x00"), int32(D3), meshpath, lw)
		noarch.Fprintf(fpm, []byte(" '%s' u 1:2:3 w l lw 3 lt 3 \n\x00"), modefl)
		i ++
	}
	noarch.Fclose(fpm)
	v = dvector(1, DoF)
	i = 1
	for (func() int32 {
		m = anim[i]
		return m
	}()) != 0 {
		for fr = 0; float32(fr) <= frames; fr++ {
			noarch.Sprintf(modefl, []byte("%s-%02d.%03d\x00"), modepath, m, fr)
			if (func() *noarch.File {
				fpm = noarch.Fopen(modefl, []byte("w\x00"))
				return fpm
			}()) == nil {
				noarch.Sprintf(errMsg, []byte("\n  error: cannot open gnuplot modal mesh data file: %s \n\x00"), modefl)
				errorMsg(errMsg)
				unix.Exit(28)
			}
			ex = exagg_modal*math.Cos(3.141592653589793*float64(fr)/float64(frames))
			//frame3dd.sf.net/");
			noarch.Fprintf(fpm, []byte("# FRAME3DD ANALYSIS RESULTS  http://frame3dd.sf.net/\x00"))
			noarch.Fprintf(fpm, []byte(" VERSION %s \n\x00"), []byte("20140514+\x00"))
			noarch.Fprintf(fpm, []byte("# %s\n\x00"), title)
			noarch.Fprintf(fpm, []byte("# A N I M A T E D   M O D E   S H A P E   D A T A \n\x00"))
			noarch.Fprintf(fpm, []byte("# deflection exaggeration: %.1f\n\x00"), ex)
			noarch.Fprintf(fpm, []byte("# MODE %5d: f= %f Hz  T= %f sec\n\n\x00\x00\x00"), m, f[m], 1/f[m])
			{
				// mode "m"
				for j = 1; j <= DoF; j++ {
					v[j] = V[j][m]
				}
			}
			noarch.Fprintf(fpm, []byte("#      X-dsp       Y-dsp       Z-dsp\n\n\x00"))
			for n = 1; n <= nE; n++ {
				noarch.Fprintf(fpm, []byte("\n# element %5d \n\x00"), n)
				cubic_bent_beam(fpm, J1[n], J2[n], xyz, L[n], p[n], v, ex)
			}
			noarch.Fclose(fpm)
		}
		i ++
	}
	free_dvector(v, 1, DoF)
}
// cubic_bent_beam - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:3814
func cubic_bent_beam(fpm *noarch.File, n1 int32, n2 int32, xyz []vec3, L float64, p float32, D []float64, exagg float64) {
	//
	// * CUBIC_BENT_BEAM  -  computes cubic deflection functions from end deflections
	// * and end rotations.  Saves deflected shapes to a file.  These bent shapes
	// * are exact for mode-shapes, and for frames loaded at their nodes.
	// * 15 May 2009
	//
	// coord xfmn
	var t1 float64
	var t2 float64
	var t3 float64
	var t4 float64
	var t5 float64
	var t6 float64
	var t7 float64
	var t8 float64
	var t9 float64
	var u1 float64
	var u2 float64
	var u3 float64
	var u4 float64
	var u5 float64
	var u6 float64
	var u7 float64
	var u8 float64
	var u9 float64
	var u10 float64
	var u11 float64
	var u12 float64
	var a []float64
	var b []float64
	var A [][]float64
	var s float64
	var v float64
	var w float64
	var dX float64
	var dY float64
	var dZ float64
	var i1 int32
	var i2 int32
	var pd int32
	var errMsg []byte = make([]byte, 512)
	A = dmatrix(1, 4, 1, 4)
	a = dvector(1, 4)
	b = dvector(1, 4)
	coord_trans(xyz, L, n1, n2, c4goUnsafeConvert_float64(&t1), c4goUnsafeConvert_float64(&t2), c4goUnsafeConvert_float64(&t3), c4goUnsafeConvert_float64(&t4), c4goUnsafeConvert_float64(&t5), c4goUnsafeConvert_float64(&t6), c4goUnsafeConvert_float64(&t7), c4goUnsafeConvert_float64(&t8), c4goUnsafeConvert_float64(&t9), p)
	i1 = 6*(n1-1)
	i2 = 6*(n2-1)
	// compute end deflections in local coordinates
	u1 = exagg*(t1*D[i1+1]+t2*D[i1+2]+t3*D[i1+3])
	u2 = exagg*(t4*D[i1+1]+t5*D[i1+2]+t6*D[i1+3])
	u3 = exagg*(t7*D[i1+1]+t8*D[i1+2]+t9*D[i1+3])
	u4 = exagg*(t1*D[i1+4]+t2*D[i1+5]+t3*D[i1+6])
	u5 = exagg*(t4*D[i1+4]+t5*D[i1+5]+t6*D[i1+6])
	u6 = exagg*(t7*D[i1+4]+t8*D[i1+5]+t9*D[i1+6])
	u7 = exagg*(t1*D[i2+1]+t2*D[i2+2]+t3*D[i2+3])
	u8 = exagg*(t4*D[i2+1]+t5*D[i2+2]+t6*D[i2+3])
	u9 = exagg*(t7*D[i2+1]+t8*D[i2+2]+t9*D[i2+3])
	u10 = exagg*(t1*D[i2+4]+t2*D[i2+5]+t3*D[i2+6])
	u11 = exagg*(t4*D[i2+4]+t5*D[i2+5]+t6*D[i2+6])
	u12 = exagg*(t7*D[i2+4]+t8*D[i2+5]+t9*D[i2+6])
	// curve-fitting problem for a cubic polynomial
	a[1] = u2
	b[1] = u3
	a[2] = u8
	b[2] = u9
	a[3] = u6
	b[3] = -u5
	a[4] = u12
	b[4] = -u11
	u7 += L
	A[1][1] = 1
	A[1][2] = u1
	A[1][3] = u1*u1
	A[1][4] = u1*u1*u1
	A[2][1] = 1
	A[2][2] = u7
	A[2][3] = u7*u7
	A[2][4] = u7*u7*u7
	A[3][1] = 0
	A[3][2] = 1
	A[3][3] = 2*u1
	A[3][4] = 3*u1*u1
	A[4][1] = 0
	A[4][2] = 1
	A[4][3] = 2*u7
	A[4][4] = 3*u7*u7
	u7 -= L
	// solve for cubic coef's
	lu_dcmp(A, 4, a, 1, 1, c4goUnsafeConvert_int32(&pd))
	if noarch.Not(pd) {
		noarch.Sprintf(errMsg, []byte(" n1 = %d  n2 = %d  L = %e  u7 = %e \n\x00"), n1, n2, L, u7)
		errorMsg(errMsg)
		unix.Exit(30)
	}
	// solve for cubic coef's
	lu_dcmp(A, 4, b, 0, 1, c4goUnsafeConvert_int32(&pd))
	{
		// debug ... if deformed mesh exageration is too big, some elements
		// may not be plotted.
		//fprintf( fpm, "# u1=%e  L+u7=%e, dx = %e \n",
		//    u1, fabs(L+u7), fabs(L+u7-u1)/10.0);
		for s = u1; math.Abs(s) <= 1.01*math.Abs(L+u7); s += math.Abs(L+u7-u1)/10 {
			// deformed shape in local coordinates
			v = a[1]+a[2]*s+a[3]*s*s+a[4]*s*s*s
			w = b[1]+b[2]*s+b[3]*s*s+b[4]*s*s*s
			// deformed shape in global coordinates
			dX = t1*s+t4*v+t7*w
			dY = t2*s+t5*v+t8*w
			dZ = t3*s+t6*v+t9*w
			noarch.Fprintf(fpm, []byte(" %12.4e %12.4e %12.4e\n\x00"), xyz[n1].x+dX, xyz[n1].y+dY, xyz[n1].z+dZ)
		}
	}
	noarch.Fprintf(fpm, []byte("\n\n\x00"))
	free_dmatrix(A, 1, 4, 1, 4)
	free_dvector(a, 1, 4)
	free_dvector(b, 1, 4)
}
// force_bent_beam - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:3912
func force_bent_beam(fpm *noarch.File, fpif *noarch.File, fnif []byte, nx int32, n1 int32, n2 int32, xyz []vec3, L float64, p float32, D []float64, exagg float64) {
	//
	// * FORCE_BENT_BEAM  -  reads internal frame element forces and deflections
	// * from the internal force and deflection data file.
	// * Saves deflected shapes to a file.  These bent shapes are exact.
	// * Note: It would not be difficult to adapt this function to plot
	// * internal axial force, shear force, torques, or bending moments.
	// * 9 Jan 2010
	//
	// coord xfmn
	var t1 float64
	var t2 float64
	var t3 float64
	var t4 float64
	var t5 float64
	var t6 float64
	var t7 float64
	var t8 float64
	var t9 float64
	var xi float64
	var dX float64
	var dY float64
	var dZ float64
	var x float32
	var Nx float32
	var Vy float32
	var Vz float32
	var Tx float32
	var My float32
	var Mz float32
	var Dx float32
	var Dy float32
	var Dz float32
	var Rx float32
	var Lx float64
	var Ly float64
	var Lz float64
	var n int32
	// *scanf return value
	var sfrv int32
	Lx = xyz[n2].x-xyz[n1].x
	Ly = xyz[n2].y-xyz[n1].y
	Lz = xyz[n2].z-xyz[n1].z
	coord_trans(xyz, L, n1, n2, c4goUnsafeConvert_float64(&t1), c4goUnsafeConvert_float64(&t2), c4goUnsafeConvert_float64(&t3), c4goUnsafeConvert_float64(&t4), c4goUnsafeConvert_float64(&t5), c4goUnsafeConvert_float64(&t6), c4goUnsafeConvert_float64(&t7), c4goUnsafeConvert_float64(&t8), c4goUnsafeConvert_float64(&t9), p)
	x = float32(-1)
	n = 0
	for xi = 0; xi <= 1.01*L && n < nx; xi += 0.1*L {
		for float64(x) < xi && n < nx {
			// read the deformed shape in local coordinates
			sfrv = noarch.Fscanf(fpif, []byte("%f %f %f %f %f %f %f %f %f %f %f\x00"), c4goUnsafeConvert_float32(&x), c4goUnsafeConvert_float32(&Nx), c4goUnsafeConvert_float32(&Vy), c4goUnsafeConvert_float32(&Vz), c4goUnsafeConvert_float32(&Tx), c4goUnsafeConvert_float32(&My), c4goUnsafeConvert_float32(&Mz), c4goUnsafeConvert_float32(&Dx), c4goUnsafeConvert_float32(&Dy), c4goUnsafeConvert_float32(&Dz), c4goUnsafeConvert_float32(&Rx))
			if sfrv != 11 {
				//      printf("x = %12.4f\n", x );  /* debug */
				sferr(fnif)
			}
			n ++
		}
		// exaggerated deformed shape in global coordinates
		dX = exagg*(t1*float64(Dx)+t4*float64(Dy)+t7*float64(Dz))
		dY = exagg*(t2*float64(Dx)+t5*float64(Dy)+t8*float64(Dz))
		dZ = exagg*(t3*float64(Dx)+t6*float64(Dy)+t9*float64(Dz))
		noarch.Fprintf(fpm, []byte(" %12.4e %12.4e %12.4e\n\x00"), xyz[n1].x+float64(x)/L*Lx+dX, xyz[n1].y+float64(x)/L*Ly+dY, xyz[n1].z+float64(x)/L*Lz+dZ)
	}
	//  printf("...  x = %7.3f  n = %3d  Dx = %10.3e   Dy = %10.3e   Dz = %10.3e \n", x,n,Dx,Dy,Dz ); /* debug */
	//  printf("                           dX = %10.3e   dY = %10.3e   dZ = %10.3e \n", dX,dY,dZ ); /* debug */
	noarch.Fprintf(fpm, []byte("\n\n\x00"))
}
// my_itoa - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:3980
func my_itoa(n int32, s []byte, k int32) {
	//
	// * SFERR  -  Display error message upon an erronous *scanf operation
	// *
	//void sferr ( char s[] ) {
	// char errMsg[MAXL];
	// sprintf(errMsg,">> Input Data file error while reading %s\n",s);
	// errorMsg(errMsg);
	// return;
	//}
	//
	//
	// * MY_ITOA  -  Convert an integer n to charcters in s, from K&R, 1978,   p. 59-60
	// * ... specialized for portability between GNU GCC and DJGPP GCC
	//
	var c int32
	var i int32
	var j int32
	var sign int32
	if (func() int32 {
		sign = n
		return sign
	}()) < 0 {
		// record sign
		// make n positive
		n = -n
	}
	i = 0
	for {
		// generate digits in reverse order
		// get next digit
		s[func() int32 {
			defer func() {
				i ++
			}()
			return i
		}()] = byte(n%10+int32('0'))
		if !(func() int32 {
			n /= 10
			return n
		}() > 0) {
			break
		}
	}
	for i < k {
		// delete it
		// add leading '0'
		s[func() int32 {
			defer func() {
				i ++
			}()
			return i
		}()] = '0'
	}
	if sign < 0 {
		s[func() int32 {
			defer func() {
				i ++
			}()
			return i
		}()] = '-'
	}
	s[i] = '\x00'
	// reverse order of string s
	j = 0
	for int32(s[j]) != int32('\x00') {
		// j is length of s - 1
		j ++
	}
	j --
	for i = 0; i < j; {
		c = int32(s[i])
		s[i] = s[j]
		s[j] = byte(c)
		i ++
		j --
	}
}
// get_file_ext - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:4013
func get_file_ext(filename []byte, ext []byte) int32 {
	//
	// * GET_FILE_EXT  -  get the file extension,
	// *  return 1 if the extension is ".csv"
	// *  return 2 if the extension is ".fmm"
	// *  return 0 otherwise
	//
	var i int32
	var full_len int32
	var len_ int32
	// the length of file filename
	for int32(filename[func() int32 {
		defer func() {
			len_ ++
		}()
		return len_
	}()]) != int32('\x00') {
	}
	full_len = len_
	// the last '.' in filename
	for int32(filename[func() int32 {
		defer func() {
			len_ --
		}()
		return len_
	}()]) != int32('.') && len_ > 0 {
	}
	if len_ == 0 {
		len_ = full_len
	}
	len_ ++
	for i = 0; len_ < full_len; {
		ext[i] = byte(tolower(int32(filename[len_])))
		i ++
		len_ ++
	}
	if noarch.Not(noarch.Strcmp(ext, []byte(".csv\x00"))) {
		// debugging ... check file names
		// printf(" filename '%s' has length %d and extension = '%s' \n",
		//       filename, len, ext);
		// printf(" Is .CSV? ... = %d \n", !strcmp(ext,".csv") );
		//
		return 1
	}
	if noarch.Not(noarch.Strcmp(ext, []byte(".fmm\x00"))) {
		return 2
	}
	return 0
}
// dots - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:4040
func dots(fp *noarch.File, n int32) {
	//
	// * DOTS  -  print a set of dots (periods)
	//
	var i int32
	for i = 1; i <= n; i++ {
		noarch.Fprintf(fp, []byte(".\x00"))
	}
}
// evaluate - transpiled function from  GOPATH/History_frame3DD/src/frame3dd_io.c:4049
func evaluate(error_ float32, rms_resid float32, tol float32, geom int32) {
	//
	// * EVALUATE -  displays a randomly-generated goodbye message.
	//
	var r int32
	r = noarch.Int32()%10
	color(0)
	noarch.Fprintf(noarch.Stdout, []byte("  RMS relative equilibrium error  = %9.3e \x00"), float64(error_))
	if error_ < tol {
		noarch.Fprintf(noarch.Stdout, []byte(" < tol = %7.1e \x00"), float64(tol))
		_ = noarch.Fflush(noarch.Stdout)
		textColor('y', 'b', 'b', 'x')
		noarch.Fprintf(noarch.Stdout, []byte(" ** converged ** \x00"))
	}
	if error_ > tol {
		noarch.Fprintf(noarch.Stdout, []byte(" > tol = %7.1e \x00"), float64(tol))
		_ = noarch.Fflush(noarch.Stdout)
		textColor('y', 'r', 'b', 'x')
		noarch.Fprintf(noarch.Stdout, []byte(" !! not converged !! \x00"))
	}
	_ = noarch.Fflush(noarch.Stdout)
	color(0)
	noarch.Fprintf(noarch.Stdout, []byte("\n\x00"))
	noarch.Fprintf(noarch.Stdout, []byte("  RMS residual incremental displ. = %9.3e \x00"), float64(rms_resid))
	dots(noarch.Stdout, 17)
	_ = noarch.Fflush(noarch.Stdout)
	if float64(rms_resid) < 1e-24 {
		textColor('y', 'b', 'b', 'x')
		switch r {
		case 0:
			noarch.Fprintf(noarch.Stdout, []byte(" * brilliant!  * \x00"))
		case 1:
			noarch.Fprintf(noarch.Stdout, []byte(" *  chuffed!   * \x00"))
		case 2:
			noarch.Fprintf(noarch.Stdout, []byte(" *  woo-hoo!   * \x00"))
		case 3:
			noarch.Fprintf(noarch.Stdout, []byte(" *  wicked!    * \x00"))
		case 4:
			noarch.Fprintf(noarch.Stdout, []byte(" *   beaut!    * \x00"))
		case 5:
			noarch.Fprintf(noarch.Stdout, []byte(" *   flash!    * \x00"))
		case 6:
			noarch.Fprintf(noarch.Stdout, []byte(" *  well done! * \x00"))
		case 7:
			noarch.Fprintf(noarch.Stdout, []byte(" *  priceless! * \x00"))
		case 8:
			noarch.Fprintf(noarch.Stdout, []byte(" *  sweet as!  * \x00"))
		case 9:
			noarch.Fprintf(noarch.Stdout, []byte(" *good as gold!* \x00"))
			break
		}
		_ = noarch.Fflush(noarch.Stdout)
		color(0)
		noarch.Fprintf(noarch.Stdout, []byte("\n\x00"))
		return
	}
	if float64(rms_resid) < 1e-16 {
		textColor('y', 'g', 'b', 'x')
		switch r {
		case 0:
			noarch.Fprintf(noarch.Stdout, []byte("   acceptable!   \x00"))
		case 1:
			noarch.Fprintf(noarch.Stdout, []byte("      bling!     \x00"))
		case 2:
			noarch.Fprintf(noarch.Stdout, []byte("  that will do!  \x00"))
		case 3:
			noarch.Fprintf(noarch.Stdout, []byte("   not shabby!   \x00"))
		case 4:
			noarch.Fprintf(noarch.Stdout, []byte("   reasonable!   \x00"))
		case 5:
			noarch.Fprintf(noarch.Stdout, []byte("   very good!    \x00"))
		case 6:
			noarch.Fprintf(noarch.Stdout, []byte("   up to snuff!  \x00"))
		case 7:
			noarch.Fprintf(noarch.Stdout, []byte("     bully!      \x00"))
		case 8:
			noarch.Fprintf(noarch.Stdout, []byte("      nice!      \x00"))
		case 9:
			noarch.Fprintf(noarch.Stdout, []byte("     choice!     \x00"))
			break
		}
		_ = noarch.Fflush(noarch.Stdout)
		color(0)
		noarch.Fprintf(noarch.Stdout, []byte("\n\x00"))
		return
	}
	if float64(rms_resid) < 1e-12 {
		textColor('y', 'c', 'b', 'x')
		switch r {
		case 0:
			noarch.Fprintf(noarch.Stdout, []byte(" adequate. \x00"))
		case 1:
			noarch.Fprintf(noarch.Stdout, []byte(" passable. \x00"))
		case 2:
			noarch.Fprintf(noarch.Stdout, []byte(" all right. \x00"))
		case 3:
			noarch.Fprintf(noarch.Stdout, []byte(" ok. \x00"))
		case 4:
			noarch.Fprintf(noarch.Stdout, []byte(" not bad. \x00"))
		case 5:
			noarch.Fprintf(noarch.Stdout, []byte(" fine. \x00"))
		case 6:
			noarch.Fprintf(noarch.Stdout, []byte(" fair. \x00"))
		case 7:
			noarch.Fprintf(noarch.Stdout, []byte(" respectable. \x00"))
		case 8:
			noarch.Fprintf(noarch.Stdout, []byte(" tolerable. \x00"))
		case 9:
			noarch.Fprintf(noarch.Stdout, []byte(" just ok. \x00"))
			break
		}
		_ = noarch.Fflush(noarch.Stdout)
		color(0)
		noarch.Fprintf(noarch.Stdout, []byte("\n\x00"))
		return
	}
	if float64(rms_resid) > 1e-12 {
		textColor('y', 'r', 'b', 'x')
		switch r {
		case 0:
			noarch.Fprintf(noarch.Stdout, []byte(" abominable! \x00"))
		case 1:
			noarch.Fprintf(noarch.Stdout, []byte(" puckeroo! \x00"))
		case 2:
			noarch.Fprintf(noarch.Stdout, []byte(" atrocious! \x00"))
		case 3:
			noarch.Fprintf(noarch.Stdout, []byte(" not ok! \x00"))
		case 4:
			noarch.Fprintf(noarch.Stdout, []byte(" wonky! \x00"))
		case 5:
			noarch.Fprintf(noarch.Stdout, []byte(" crappy! \x00"))
		case 6:
			noarch.Fprintf(noarch.Stdout, []byte(" oh noooo! \x00"))
		case 7:
			noarch.Fprintf(noarch.Stdout, []byte(" abominable! \x00"))
		case 8:
			noarch.Fprintf(noarch.Stdout, []byte(" munted! \x00"))
		case 9:
			noarch.Fprintf(noarch.Stdout, []byte(" awful! \x00"))
			break
		}
		_ = noarch.Fflush(noarch.Stdout)
		color(0)
		noarch.Fprintf(noarch.Stdout, []byte("\n\x00"))
		return
	}
}
// coord_trans - transpiled function from  GOPATH/History_frame3DD/src/coordtrans.c:51
func coord_trans(xyz []vec3, L float64, n1 int32, n2 int32, t1 []float64, t2 []float64, t3 []float64, t4 []float64, t5 []float64, t6 []float64, t7 []float64, t8 []float64, t9 []float64, p float32) {
	//
	// This file is part of FRAME3DD:
	// Static and dynamic structural analysis of 2D and 3D frames and trusses with
	// elastic and geometric stiffness.
	// ---------------------------------------------------------------------------
	// http://frame3dd.sourceforge.net/
	// ---------------------------------------------------------------------------
	// Copyright (C) 1992-2009  Henri P. Gavin
	//
	//    FRAME3DD is free software: you can redistribute it and/or modify
	//    it under the terms of the GNU General Public License as published by
	//    the Free Software Foundation, either version 3 of the License, or
	//    (at your option) any later version.
	//
	//    FRAME3DD is distributed in the hope that it will be useful,
	//    but WITHOUT ANY WARRANTY; without even the implied warranty of
	//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	//    GNU General Public License for more details.
	//
	//    You should have received a copy of the GNU General Public License
	//    along with FRAME3DD.  If not, see <http://www.gnu.org/licenses/>.
	//
	// -------------------------------------------------------------------------
	//COORD_TRANS - calculate the 9 elements of the block-diagonal 12-by-12
	//coordinate transformation matrix, t1, t2, ..., t9.
	//
	//These coordinate transformation factors are used to:
	//* transform frame element end forces from the element (local) coordinate system
	//to the structral (global) coordinate system.
	//* transfrom end displacements from the structural (global) coordinate system
	//to the element (local) coordinate system,
	//* transform the frame element stiffness and mass matrices
	//from element (local) coordinates to structral (global) coordinates.
	//
	//Element matrix coordinate transformations are carried out by function ATMA
	//in frame3dd.c
	//
	//Currently coordinate transformations do not consider the effect of
	//finite node sizes ... this needs work, and could require a substantial
	//re-write of much of the code.
	//
	//Currently the effect of finite node sizes is used only in the calculation
	//of the element stiffness matrices.
	//-------------------------------------------------------------------------
	//< the roll angle (radians)
	// direction cosines
	var Cx float64
	var Cy float64
	var Cz float64
	var den float64
	var Cp float64
	var Sp float64
	// cosine and sine of roll angle
	Cx = (xyz[n2].x-xyz[n1].x)/L
	Cy = (xyz[n2].y-xyz[n1].y)/L
	Cz = (xyz[n2].z-xyz[n1].z)/L
	t9[0] = 0
	t8[0] = t9[0]
	t7[0] = t8[0]
	t6[0] = t7[0]
	t5[0] = t6[0]
	t4[0] = t5[0]
	t3[0] = t4[0]
	t2[0] = t3[0]
	t1[0] = t2[0]
	Cp = math.Cos(float64(p))
	Sp = math.Sin(float64(p))
	if math.Abs(Cz) == 1 {
		t3[0] = Cz
		t4[0] = -Cz*Sp
		t5[0] = Cp
		t7[0] = -Cz*Cp
		t8[0] = -Sp
	} else {
		den = math.Sqrt(1-Cz*Cz)
		t1[0] = Cx
		t2[0] = Cy
		t3[0] = Cz
		t4[0] = (-Cx*Cz*Sp-Cy*Cp)/den
		t5[0] = (-Cy*Cz*Sp+Cx*Cp)/den
		t6[0] = Sp*den
		t7[0] = (-Cx*Cz*Cp+Cy*Sp)/den
		t8[0] = (-Cy*Cz*Cp-Cx*Sp)/den
		t9[0] = Cp*den
	}
}
// atma - transpiled function from  GOPATH/History_frame3DD/src/coordtrans.c:131
func atma(t1 float64, t2 float64, t3 float64, t4 float64, t5 float64, t6 float64, t7 float64, t8 float64, t9 float64, m [][]float64, r1 float32, r2 float32) {
	// ------------------------------------------------------------------------------
	// * ATMA  -  perform the coordinate transformation from local to global     6jan96
	// *   include effects of a finite node radii, r1 and r2.     9dec04
	// *   ------------------------------------------------------------------------------
	var a [][]float64
	var ma [][]float64// i - transpiled function from  GOPATH/History_frame3DD/src/coordtrans.c:138
	var i int32// j - transpiled function from  GOPATH/History_frame3DD/src/coordtrans.c:138
	var j int32// k - transpiled function from  GOPATH/History_frame3DD/src/coordtrans.c:138
	var k int32
	a = dmatrix(1, 12, 1, 12)
	ma = dmatrix(1, 12, 1, 12)
	for i = 1; i <= 12; i++ {
		for j = i; j <= 12; j++ {
			a[i][j] = 0
			a[j][i] = a[i][j]
			ma[i][j] = a[j][i]
			ma[j][i] = ma[i][j]
		}
	}
	for i = 0; i <= 3; i++ {
		a[3*i+1][3*i+1] = t1
		a[3*i+1][3*i+2] = t2
		a[3*i+1][3*i+3] = t3
		a[3*i+2][3*i+1] = t4
		a[3*i+2][3*i+2] = t5
		a[3*i+2][3*i+3] = t6
		a[3*i+3][3*i+1] = t7
		a[3*i+3][3*i+2] = t8
		a[3*i+3][3*i+3] = t9
	}
	{
		//  effect of finite node radius on coordinate transformation  ...
		//  this needs work ...
		//
		//   a[5][1] =  r1*t7;
		//   a[5][2] =  r1*t8;
		//   a[5][3] =  r1*t9;
		//   a[6][1] = -r1*t4;
		//   a[6][2] = -r1*t5;
		//   a[6][3] = -r1*t6;
		//
		//   a[11][7] = -r2*t7;
		//   a[11][8] = -r2*t8;
		//   a[11][9] = -r2*t9;
		//   a[12][7] =  r2*t4;
		//   a[12][8] =  r2*t5;
		//   a[12][9] =  r2*t6;
		//
		//  MT = M T
		for j = 1; j <= 12; j++ {
			for i = 1; i <= 12; i++ {
				for k = 1; k <= 12; k++ {
					ma[i][j] += m[i][k]*a[k][j]
				}
			}
		}
	}
	for i = 1; i <= 12; i++ {
		for j = i; j <= 12; j++ {
			m[i][j] = 0
			m[j][i] = m[i][j]
		}
	}
	{
		//  T'MT = T' MT
		for j = 1; j <= 12; j++ {
			for i = 1; i <= 12; i++ {
				for k = 1; k <= 12; k++ {
					m[i][j] += a[k][i]*ma[k][j]
				}
			}
		}
	}
	free_dmatrix(a, 1, 12, 1, 12)
	free_dmatrix(ma, 1, 12, 1, 12)
}
// subspace - transpiled function from  GOPATH/History_frame3DD/src/eig.c:66
func subspace(K [][]float64, M [][]float64, n int32, m int32, w []float64, V [][]float64, tol float64, shift float64, iter []int32, ok []int32, verbose int32) {
	//
	// This file is part of FRAME3DD:
	// Static and dynamic structural analysis of 2D and 3D frames and trusses with
	// elastic and geometric stiffness.
	// ---------------------------------------------------------------------------
	// http://frame3dd.sourceforge.net/
	// ---------------------------------------------------------------------------
	// Copyright (C) 1992-2009  Henri P. Gavin
	//
	//    FRAME3DD is free software: you can redistribute it and/or modify
	//    it under the terms of the GNU General Public License as published by
	//    the Free Software Foundation, either version 3 of the License, or
	//    (at your option) any later version.
	//
	//    FRAME3DD is distributed in the hope that it will be useful,
	//    but WITHOUT ANY WARRANTY; without even the implied warranty of
	//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	//    GNU General Public License for more details.
	//
	//    You should have received a copy of the GNU General Public License
	//    along with FRAME3DD.  If not, see <http://www.gnu.org/licenses/>.
	//
	//
	// @file
	// Routines to solve the generalized eigenvalue problem
	//
	// Henri P. Gavin                                             hpgavin@duke.edu
	// Department of Civil and Environmental Engineering
	// Duke University, Box 90287
	// Durham, NC  27708--0287
	//
	// #define EIG_DEBUG
	// forward declarations
	//-----------------------------------------------------------------------------
	//SUBSPACE - Find the lowest m eigen-values, w, and eigen-vectors, V, of the
	//general eigen-problem  ...       K V = w M V using sub-space / Jacobi iteration
	//where
	//  K is an n by n  symmetric real (stiffness) matrix
	//  M is an n by n  symmetric positive definate real (mass) matrix
	//  w is a diagonal matrix of eigen-values
	//  V is a  rectangular matrix of eigen-vectors
	//
	// H.P. Gavin, Civil Engineering, Duke University, hpgavin@duke.edu  1 March 2007
	// Bathe, Finite Element Procecures in Engineering Analysis, Prentice Hall, 1982
	//-----------------------------------------------------------------------------
	//< DoF and number of required modes
	//< sub-space iterations
	//< Sturm check result
	var Kb [][]float64
	var Mb [][]float64
	var Xb [][]float64
	var Qb [][]float64
	var d []float64
	var u []float64
	var v []float64
	var km float64
	var km_old float64
	var error_ float64 = 1
	var w_old float64
	var i int32
	var j int32
	var k int32
	var modes int32
	var disp int32
	var idx []int32
	// display convergence info.
	var errMsg []byte = make([]byte, 512)
	if m > n {
		noarch.Sprintf(errMsg, []byte("subspace: Number of eigen-values must be less than the problem dimension.\n Desired number of eigen-values=%d \n Dimension of the problem= %d \n\x00"), m, n)
		errorMsg(errMsg)
		unix.Exit(32)
	}
	d = dvector(1, n)
	u = dvector(1, n)
	v = dvector(1, n)
	Kb = dmatrix(1, m, 1, m)
	Mb = dmatrix(1, m, 1, m)
	Xb = dmatrix(1, n, 1, m)
	Qb = dmatrix(1, m, 1, m)
	idx = ivector(1, m)
	for i = 1; i <= m; i++ {
		idx[i] = 0
		for j = i; j <= m; j++ {
			Qb[j][i] = 0
			Qb[i][j] = Qb[j][i]
			Mb[j][i] = Qb[i][j]
			Mb[i][j] = Mb[j][i]
			Kb[j][i] = Mb[i][j]
			Kb[i][j] = Kb[j][i]
		}
	}
	for i = 1; i <= n; i++ {
		for j = 1; j <= m; j++ {
			V[i][j] = 0
			Xb[i][j] = V[i][j]
		}
	}
	if 0.5*float64(m) > float64(m)-8 {
		modes = int32(float64(m) / 2)
	} else {
		modes = m - 8
	}
	{
		// shift eigen-values by this much
		for i = 1; i <= n; i++ {
			for j = i; j <= n; j++ {
				K[i][j] += shift*M[i][j]
			}
		}
	}
	// use L D L' decomp
	ldl_dcmp(K, n, u, v, v, 1, 0, ok)
	for i = 1; i <= n; i++ {
		if M[i][i] <= 0 {
			noarch.Sprintf(errMsg, []byte(" subspace: M[%d][%d] = %e \n\x00"), i, i, M[i][i])
			errorMsg(errMsg)
			unix.Exit(32)
		}
		d[i] = K[i][i]/M[i][i]
	}
	km_old = 0
	for k = 1; k <= m; k++ {
		km = d[1]
		for i = 1; i <= n; i++ {
			if km_old <= d[i] && d[i] <= km {
				ok[0] = 1
				for j = 1; j <= k-1; j++ {
					if i == idx[j] {
						ok[0] = 0
					}
				}
				if ok[0] != 0 {
					km = d[i]
					idx[k] = i
				}
			}
		}
		if idx[k] == 0 {
			i = idx[1]
			for j = 1; j < k; j++ {
				if i < idx[j] {
					i = idx[j]
				}
			}
			idx[k] = i+1
			km = d[i+1]
		}
		km_old = km
	}
	{
		// for (k=1; k<=m; k++) printf(" idx[%d] = %d \n", k, idx[k] ); /*debug*/
		for k = 1; k <= m; k++ {
			V[idx[k]][k] = 1
			ok[0] = idx[k]%6
			switch ok[0] {
			case 1:
				//  printf(" idx[%3d] = %3d   ok = %d \n", k , idx[k], *ok); /*debug*/
				i = 1
				j = 2
			case 2:
				i = -1
				j = 1
			case 3:
				i = -1
				j = -2
			case 4:
				i = 1
				j = 2
			case 5:
				i = -1
				j = 1
			case 0:
				i = -1
				j = -2
				break
			}
			V[idx[k]+i][k] = 0.2
			V[idx[k]+j][k] = 0.2
		}
	}
	// for (i=1; i<=n; i++) V[i][1] = M[i][i]; // diag(M)
	iter[0] = 0
	for {
		{
			// Begin sub-space iterations
			// K Xb = M V (12.10)
			for k = 1; k <= m; k++ {
				prodABj(M, V, v, n, k)
				// LDL bk-sub
				ldl_dcmp(K, n, u, v, d, 0, 1, ok)
				if disp != 0 {
					// improve the solution iteratively
					noarch.Fprintf(noarch.Stdout, []byte("  RMS matrix error:\x00"))
				}
				ok[0] = 1
				error_ = float64(ok[0])
				for {
					ldl_mprove(K, n, u, v, d, c4goUnsafeConvert_float64(&error_), ok)
					if disp != 0 {
						noarch.Fprintf(noarch.Stdout, []byte("%9.2e\x00"), error_)
					}
					if noarch.Not(ok[0]) {
						break
					}
				}
				if disp != 0 {
					noarch.Fprintf(noarch.Stdout, []byte("\n\x00"))
				}
				for i = 1; i <= n; i++ {
					Xb[i][k] = d[i]
				}
			}
		}
		// Kb = Xb' K Xb (12.11)
		xtAx(K, Xb, Kb, n, m)
		// Mb = Xb' M Xb (12.12)
		xtAx(M, Xb, Mb, n, m)
		// (12.13)
		jacobi(Kb, Mb, w, Qb, m)
		// V = Xb Qb (12.14)
		prodAB(Xb, Qb, V, n, m, m)
		eigsort(w, V, n, m)
		if w[modes] == 0 {
			noarch.Sprintf(errMsg, []byte(" subspace: Zero frequency found! \n w[%d] = %e \n\x00"), modes, w[modes])
			errorMsg(errMsg)
			unix.Exit(32)
		}
		error_ = math.Abs(w[modes]-w_old)/w[modes]
		iter[0] ++
		if disp != 0 {
			noarch.Fprintf(noarch.Stdout, []byte(" iter = %d  w[%d] = %f error = %e\n\x00"), iter[0], modes, w[modes], error_)
		}
		w_old = w[modes]
		if iter[0] > 1000 {
			noarch.Sprintf(errMsg, []byte("  subspace: Iteration limit exceeded\n rel. error = %e > %e\n\x00"), error_, tol)
			errorMsg(errMsg)
			unix.Exit(32)
		}
		if !(error_ > tol) {
			break
		}
	}
	{
		// End   sub-space iterations
		// shift eigen-values
		for k = 1; k <= m; k++ {
			if w[k] > shift {
				w[k] = w[k]-shift
			} else {
				w[k] = shift-w[k]
			}
		}
	}
	if verbose != 0 {
		noarch.Fprintf(noarch.Stdout, []byte(" %4d sub-space iterations,   error: %.4e \n\x00"), iter[0], error_)
		for k = 1; k <= m; k++ {
			noarch.Fprintf(noarch.Stdout, []byte("  mode: %2d\tDoF: %5d\t %9.4f Hz\n\x00\x00"), k, idx[k], math.Sqrt(w[k])/(2*3.141592653589793))
		}
	}
	ok[0] = sturm(K, M, n, m, shift, w[modes]+tol, verbose)
	for i = 1; i <= n; i++ {
		for j = i; j <= n; j++ {
			K[i][j] -= shift*M[i][j]
		}
	}
	free_dmatrix(Kb, 1, m, 1, m)
	free_dmatrix(Mb, 1, m, 1, m)
	free_dmatrix(Xb, 1, n, 1, m)
	free_dmatrix(Qb, 1, m, 1, m)
}
// jacobi - transpiled function from  GOPATH/History_frame3DD/src/eig.c:250
func jacobi(K [][]float64, M [][]float64, E []float64, V [][]float64, n int32) {
	//-----------------------------------------------------------------------------
	// JACOBI - Find all eigen-values, E, and eigen-vectors, V,
	// of the general eigen-problem  K V = E M V
	// using Jacobi iteration, with efficient matrix rotations.
	// K is a symmetric real (stiffness) matrix
	// M is a symmetric positive definate real (mass) matrix
	// E is a diagonal matrix of eigen-values
	// V is a  square  matrix of eigen-vectors
	//
	// H.P. Gavin, Civil Engineering, Duke University, hpgavin@duke.edu  1 March 2007
	// Bathe, Finite Element Procecures in Engineering Analysis, Prentice Hall, 1982
	//-----------------------------------------------------------------------------
	var iter int32
	var d int32
	var i int32
	var j int32
	var k int32
	var Kii float64
	var Kjj float64
	var Kij float64
	var Mii float64
	var Mjj float64
	var Mij float64
	var Vki float64
	var Vkj float64
	var alpha float64
	var beta float64
	var gamma float64
	var s float64
	var tol float64
	Vkj = 0
	Vki = Vkj
	Mij = Vki
	Mjj = Mij
	Mii = Mjj
	Kij = Mii
	Kjj = Kij
	Kii = Kjj
	for i = 1; i <= n; i++ {
		for j = i+1; j <= n; j++ {
			V[j][i] = 0
			V[i][j] = V[j][i]
		}
	}
	for d = 1; d <= n; d++ {
		V[d][d] = 1
	}
	{
		// Begin Sweep Iteration
		for iter = 1; iter <= 2*n; iter++ {
			tol = math.Pow(0.01, float64(2*iter))
			tol = 0
			{
				// sweep along upper diagonals
				for d = 1; d <= n-1; d++ {
					{
						// row
						for i = 1; i <= n-d; i++ {
							// column
							j = i+d
							Kij = K[i][j]
							Mij = M[i][j]
							if Kij*Kij/(K[i][i]*K[j][j]) > tol || Mij*Mij/(M[i][i]*M[j][j]) > tol {
								// do a rotation
								Kii = K[i][i]*Mij-Kij*M[i][i]
								Kjj = K[j][j]*Mij-Kij*M[j][j]
								s = K[i][i]*M[j][j]-K[j][j]*M[i][i]
								if s >= 0 {
									gamma = 0.5*s+math.Sqrt(0.25*s*s+Kii*Kjj)
								} else {
									gamma = 0.5*s-math.Sqrt(0.25*s*s+Kii*Kjj)
								}
								alpha = Kjj/gamma
								beta = -Kii/gamma
								// make Kij zero
								rotate(K, n, alpha, beta, i, j)
								// make Mij zero
								rotate(M, n, alpha, beta, i, j)
								{
									//  update eigen-vectors  V = V * P
									for k = 1; k <= n; k++ {
										Vki = V[k][i]
										Vkj = V[k][j]
										V[k][i] = Vki+beta*Vkj
										V[k][j] = Vkj+alpha*Vki
									}
								}
							}
						}
					}
				}
			}
		}
	}
	{
		// rotations complete
		// row
		// diagonal
		// End Sweep Iteration
		// scale eigen-vectors
		for j = 1; j <= n; j++ {
			Mjj = math.Sqrt(M[j][j])
			for i = 1; i <= n; i++ {
				V[i][j] /= Mjj
			}
		}
	}
	for j = 1; j <= n; j++ {
		// eigen-values
		E[j] = K[j][j]/M[j][j]
	}
}
// rotate - transpiled function from  GOPATH/History_frame3DD/src/eig.c:319
func rotate(A [][]float64, n int32, alpha float64, beta float64, i int32, j int32) {
	//-----------------------------------------------------------------------------
	//ROTATE - rotate an n by n symmetric matrix A such that A[i][j] = A[j][i] = 0
	//     A = P' * A * P  where diag(P) = 1 and P[i][j] = alpha and P[j][i] = beta.
	//     Since P is sparse, this matrix multiplcation can be done efficiently.
	//-----------------------------------------------------------------------------
	// elements of A
	var Aii float64
	var Ajj float64
	var Aij float64
	var Ai []float64
	var Aj []float64
	// i-th and j-th rows of A
	var k int32
	Ai = dvector(1, n)
	Aj = dvector(1, n)
	for k = 1; k <= n; k++ {
		Ai[k] = A[i][k]
		Aj[k] = A[j][k]
	}
	Aii = A[i][i]
	Ajj = A[j][j]
	Aij = A[i][j]
	A[i][i] = Aii+2*beta*Aij+beta*beta*Ajj
	A[j][j] = Ajj+2*alpha*Aij+alpha*alpha*Aii
	for k = 1; k <= n; k++ {
		if k != i && k != j {
			A[i][k] = Ai[k]+beta*Aj[k]
			A[k][i] = A[i][k]
			A[j][k] = Aj[k]+alpha*Ai[k]
			A[k][j] = A[j][k]
		}
	}
	A[i][j] = 0
	A[j][i] = A[i][j]
	free_dvector(Ai, 1, n)
	free_dvector(Aj, 1, n)
}
// stodola - transpiled function from  GOPATH/History_frame3DD/src/eig.c:363
func stodola(K [][]float64, M [][]float64, n int32, m int32, w []float64, V [][]float64, tol float64, shift float64, iter []int32, ok []int32, verbose int32) {
	//------------------------------------------------------------------------------
	//STODOLA  -  calculate the lowest m eigen-values and eigen-vectors of the
	//generalized eigen-problem, K v = w M v, using a matrix iteration approach
	//with shifting.         15oct98
	//
	// H.P. Gavin, Civil Engineering, Duke University, hpgavin@duke.edu  12 Jul 2001
	//------------------------------------------------------------------------------
	// stiffness and mass matrices
	// DoF and number of required modes
	// the dynamics matrix, D = K^(-1) M
	var D [][]float64
	var d_min float64
	var d_max float64
	var d_old float64
	var d []float64
	var u []float64
	var v []float64
	var c []float64
	var vMv float64
	var RQ float64
	var RQold float64
	var error_ float64 = 1
	// minimum value of D[i][i]
	// maximum value of D[i][i]
	// previous extreme value of D[i][i]
	// columns of the D, M, and V matrices
	// trial eigen-vector vectors
	// coefficients for lower mode purge
	// factor for mass normalization
	// Raliegh quotient
	// location of minimum value of D[i][i]
	var i_ex int32 = 9999
	var modes int32
	var disp int32
	var i int32
	var j int32
	var k int32
	// number of desired modes
	// 1: display convergence error; 0: dont
	var errMsg []byte = make([]byte, 512)
	D = dmatrix(1, n, 1, n)
	d = dvector(1, n)
	u = dvector(1, n)
	v = dvector(1, n)
	c = dvector(1, m)
	if 0.5*float64(m) > float64(m-8) {
		modes = int32(float64(m) / 2)
	} else {
		modes = m - 8
	}
	{
		// shift eigen-values by this much
		for i = 1; i <= n; i++ {
			for j = i; j <= n; j++ {
				K[i][j] += shift*M[i][j]
			}
		}
	}
	// use L D L' decomp
	ldl_dcmp(K, n, u, v, v, 1, 0, ok)
	if ok[0] < 0 {
		noarch.Sprintf(errMsg, []byte(" Make sure that all six rigid body translation are restrained.\n\x00"))
		errorMsg(errMsg)
		unix.Exit(32)
	}
	{
		// calculate  D = K^(-1) M
		for j = 1; j <= n; j++ {
			for i = 1; i <= n; i++ {
				v[i] = M[i][j]
			}
			// L D L' bk-sub
			ldl_dcmp(K, n, u, v, d, 0, 1, ok)
			if disp != 0 {
				// improve the solution iteratively
				noarch.Fprintf(noarch.Stdout, []byte("  RMS matrix error:\x00"))
			}
			ok[0] = 1
			error_ = float64(ok[0])
			for {
				ldl_mprove(K, n, u, v, d, c4goUnsafeConvert_float64(&error_), ok)
				if disp != 0 {
					noarch.Fprintf(noarch.Stdout, []byte("%9.2e\x00"), error_)
				}
				if noarch.Not(ok[0]) {
					break
				}
			}
			if disp != 0 {
				noarch.Fprintf(noarch.Stdout, []byte("\n\x00"))
			}
			for i = 1; i <= n; i++ {
				D[i][j] = d[i]
			}
		}
	}
	iter[0] = 0
	for i = 1; i <= n; i++ {
		if D[i][i] > d_max {
			d_max = D[i][i]
		}
	}
	d_min = d_max
	d_old = d_min
	for i = 1; i <= n; i++ {
		if D[i][i] < d_min {
			d_min = D[i][i]
		}
	}
	{
		// loop over lowest m modes
		for k = 1; k <= m; k++ {
			d_max = d_min
			{
				// initial guess
				for i = 1; i <= n; i++ {
					u[i] = 0
					if D[i][i] < d_old && D[i][i] > d_max {
						d_max = D[i][i]
						i_ex = i
					}
				}
			}
			u[i_ex] = 1
			u[i_ex+1] = 0.0001
			d_old = d_max
			// mass-normalize
			vMv = xtAy(u, M, u, n, d)
			for i = 1; i <= n; i++ {
				u[i] /= math.Sqrt(vMv)
			}
			{
				// purge lower modes
				for j = 1; j < k; j++ {
					for i = 1; i <= n; i++ {
						v[i] = V[i][j]
					}
					c[j] = xtAy(v, M, u, n, d)
				}
			}
			for j = 1; j < k; j++ {
				for i = 1; i <= n; i++ {
					u[i] -= c[j]*V[i][j]
				}
			}
			// mass-normalize
			vMv = xtAy(u, M, u, n, d)
			for i = 1; i <= n; i++ {
				u[i] /= math.Sqrt(vMv)
			}
			// Raleigh quotient
			RQ = xtAy(u, K, u, n, d)
			for {
				{
					// iterate
					// v = D u
					for i = 1; i <= n; i++ {
						v[i] = 0
						for j = 1; j <= n; j++ {
							v[i] += D[i][j]*u[j]
						}
					}
				}
				// mass-normalize
				vMv = xtAy(v, M, v, n, d)
				for i = 1; i <= n; i++ {
					v[i] /= math.Sqrt(vMv)
				}
				{
					// purge lower modes
					for j = 1; j < k; j++ {
						for i = 1; i <= n; i++ {
							u[i] = V[i][j]
						}
						c[j] = xtAy(u, M, v, n, d)
					}
				}
				for j = 1; j < k; j++ {
					for i = 1; i <= n; i++ {
						v[i] -= c[j]*V[i][j]
					}
				}
				// mass-normalize
				vMv = xtAy(v, M, v, n, d)
				for i = 1; i <= n; i++ {
					u[i] = v[i]/math.Sqrt(vMv)
				}
				RQold = RQ
				// Raleigh quotient
				RQ = xtAy(u, K, u, n, d)
				iter[0] ++
				if iter[0] > 1000 {
					noarch.Sprintf(errMsg, []byte("  stodola: Iteration limit exceeded\n  rel. error = %e > %e\n\x00"), math.Abs(RQ-RQold)/RQ, tol)
					errorMsg(errMsg)
					unix.Exit(32)
				}
				if !(math.Abs(RQ-RQold)/RQ > tol) {
					break
				}
			}
			for i = 1; i <= n; i++ {
				V[i][k] = v[i]
			}
			w[k] = xtAy(u, K, u, n, d)
			if w[k] > shift {
				w[k] = w[k]-shift
			} else {
				w[k] = shift-w[k]
			}
			noarch.Fprintf(noarch.Stdout, []byte("  mode: %2d\tDoF: %5d\t\x00"), k, i_ex)
			noarch.Fprintf(noarch.Stdout, []byte(" %9.4f Hz\t iter: %4d   error: %.4e \n\x00"), math.Sqrt(w[k])/(2*3.141592653589793), iter[0], math.Abs(RQ-RQold)/RQ)
		}
	}
	eigsort(w, V, n, m)
	ok[0] = sturm(K, M, n, m, shift, w[modes]+tol, verbose)
	free_dmatrix(D, 1, n, 1, n)
	free_dvector(d, 1, n)
	free_dvector(u, 1, n)
	free_dvector(v, 1, n)
	free_dvector(c, 1, m)
}
// eigsort - transpiled function from  GOPATH/History_frame3DD/src/eig.c:524
func eigsort(e []float64, v [][]float64, n int32, m int32) {
	//------------------------------------------------------------------------------
	//EIGSORT  -  Given the eigenvallues e[1..m] and eigenvectors v[1..n][1..m],
	//this routine sorts the eigenvalues into ascending order, and rearranges
	//the columns of v correspondingly.  The method is straight insertion.
	//Adapted from Numerical Recipes in C, Ch 11
	//------------------------------------------------------------------------------
	var k int32
	var j int32
	var i int32
	var p float64
	for i = 1; i < m; i++ {
		k = i
		p = e[k]
		for j = i+1; j <= m; j++ {
			if e[j] <= p {
				// find smallest eigen-value
				p = e[(func() int32 {
					k = j
					return k
				}())]
			}
		}
		if k != i {
			// swap eigen-values
			e[k] = e[i]
			e[i] = p
			{
				// swap eigen-vectors
				for j = 1; j <= n; j++ {
					p = v[j][i]
					v[j][i] = v[j][k]
					v[j][k] = p
				}
			}
		}
	}
}
// sturm - transpiled function from  GOPATH/History_frame3DD/src/eig.c:563
func sturm(K [][]float64, M [][]float64, n int32, m int32, shift float64, ws float64, verbose int32) int32 {
	//-----------------------------------------------------------------------------
	//STURM  -  Determine the number of eigenvalues, w, of the general eigen-problem
	//  K V = w M V which are below the value ws,
	//  K is an n by n  symmetric real (stiffness) matrix
	//  M is an n by n  symmetric positive definate real (mass) matrix
	//  w is a diagonal matrix of eigen-values
	//  ws is the limit
	//  n is the number of DoF
	//  m is the number of required modes
	//
	//
	// H.P. Gavin, Civil Engineering, Duke University, hpgavin@duke.edu  30 Aug 2001
	// Bathe, Finite Element Procecures in Engineering Analysis, Prentice Hall, 1982
	//-----------------------------------------------------------------------------
	var ws_shift float64
	var d []float64
	var ok int32
	var i int32
	var j int32
	var modes int32
	d = dvector(1, n)
	if float32(0.5*float64(m)) > float32(float64(m)-8) {
		modes = int32(float64(m) / 2)
	} else {
		modes = m - 8
	}
	// shift [K]
	ws_shift = ws+shift
	for i = 1; i <= n; i++ {
		for j = i; j <= n; j++ {
			K[i][j] -= ws_shift*M[i][j]
		}
	}
	ldl_dcmp(K, n, d, d, d, 1, 0, c4goUnsafeConvert_int32(&ok))
	if verbose != 0 {
		noarch.Fprintf(noarch.Stdout, []byte("  There are %d modes below %f Hz.\x00"), -ok, math.Sqrt(ws)/(2*3.141592653589793))
	}
	if -ok > modes {
		noarch.Fprintf(noarch.Stderr, []byte(" ... %d modes were not found.\n\x00"), -ok-modes)
		noarch.Fprintf(noarch.Stderr, []byte(" Try increasing the number of modes in \n\x00"))
		noarch.Fprintf(noarch.Stderr, []byte(" order to get the missing modes below %f Hz.\n\x00"), math.Sqrt(ws)/(2*3.141592653589793))
	} else if verbose != 0 {
		noarch.Fprintf(noarch.Stdout, []byte("  All %d modes were found.\n\x00"), modes)
	}
	for i = 1; i <= n; i++ {
		for j = i; j <= n; j++ {
			K[i][j] += ws_shift*M[i][j]
		}
	}
	free_dvector(d, 1, n)
	return ok
}
// check_non_negative - transpiled function from  GOPATH/History_frame3DD/src/eig.c:601
func check_non_negative(x float64, i int32) {
	if x <= 1e-100 {
		//----------------------------------------------------------------------------
		//CHECK_NON_NEGATIVE -  checks that a value is non-negative
		//-----------------------------------------------------------------------------
		noarch.Fprintf(noarch.Stderr, []byte(" value %e is less than or equal to zero \x00"), x)
		noarch.Fprintf(noarch.Stderr, []byte(" i = %d \n\x00"), i)
	} else {
		return
	}
}
// gaussj - transpiled function from  GOPATH/History_frame3DD/src/HPGmatrix.c:55
func gaussj(A [][]float32, n int32, B [][]float32, m int32) {
	//
	// * ==========================================================================
	// *
	// *       Filename:  HPGmatrix.c
	// *
	// *    Description:  Matrix math functions
	// *
	// * Version:  1.0
	// * Created:  12/30/11 18:07:41
	// *       Revision:  none
	// *       Compiler:  gcc
	// *
	// *  Author:  Henri P. Gavin (hpgavin), h p gavin ~at~ duke ~dot~ e d v
	// * Company:  Duke Univ.
	// *
	// * ==========================================================================
	//
	//
	// Copyright (C) 2012 Henri P. Gavin
	//
	//    HPGmatrix is free software: you can redistribute it and/or modify
	//    it under the terms of the GNU General Public License as published by
	//    the Free Software Foundation, either version 3 of the License, or
	//    (at your option) any later version.
	//
	//    HPGmatrix is distributed in the hope that it will be useful,
	//    but WITHOUT ANY WARRANTY; without even the implied warranty of
	//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	//    GNU General Public License for more details.
	//
	//    You should have received a copy of the GNU General Public License
	//    along with HPGmatrix.  If not, see <http://www.gnu.org/licenses/>.
	//
	//
	// * GAUSSJ
	// * Linear equation solution by Gauss-Jordan elimination, [A][X]=[B] above. A[1..n][1..n]
	// * is the input matrix. B[1..n][1..m] is input containing the m right-hand side vectors. On
	// * output, a is replaced by its matrix inverse, and B is replaced by the corresponding set of solution
	// * vectors.
	//
	var indxc []int32
	var indxr []int32
	var ipiv []int32
	var i int32
	var icol int32 = 1
	var irow int32 = 1
	var j int32
	var k int32
	var l int32
	var ll int32
	var big float32
	var dum float32
	var pivinv float32
	var temp float32
	// The integer arrays ipiv, indxr, and indxc are used for bookkeeping on the pivoting.
	indxc = ivector(1, n)
	indxr = ivector(1, n)
	ipiv = ivector(1, n)
	for j = 1; j <= n; j++ {
		ipiv[j] = 0
	}
	{
		//  This is the main loop over the columns to be reduced.
		for i = 1; i <= n; i++ {
			big = float32(0)
			{
				//  This is the outer loop for the search for a pivot element.
				for j = 1; j <= n; j++ {
					if ipiv[j] != 1 {
						for k = 1; k <= n; k++ {
							if ipiv[k] == 0 {
								if math.Abs(float64(A[j][k])) >= float64(big) {
									big = float32(math.Abs(float64(A[j][k])))
									irow = j
									icol = k
								}
							} else if ipiv[k] > 1 {
								NRerror([]byte("gaussj: Singular Matrix-1\x00"))
							}
						}
					}
				}
			}
			ipiv[icol] ++
			if irow != icol {
				{
					// We now have the pivot element, so we interchange rows, if needed, to put the pivot
					// * element on the diagonal. The columns are not physically interchanged, only relabeled:
					// * indxc[i], the column of the ith pivot element, is the ith column that is reduced, while
					// * indxr[i] is the row in which that pivot element was originally located. If indxr[i] =
					// * indxc[i] there is an implied column interchange. With this form of bookkeeping, the
					// * solution b's will end up in the correct order, and the inverse matrix will be scrambled
					// * by columns.
					//
					for l = 1; l <= n; l++ {
						temp = A[irow][l]
						A[irow][l] = A[icol][l]
						A[icol][l] = temp
					}
				}
				for l = 1; l <= m; l++ {
					temp = B[irow][l]
					B[irow][l] = B[icol][l]
					B[icol][l] = temp
				}
			}
			indxr[i] = irow
			indxc[i] = icol
			if float64(A[icol][icol]) == 0 {
				// We are now ready to divide the pivot row by the by the pivot element, located at irow,icol
				NRerror([]byte("gaussj: Singular Matrix-2\x00"))
			}
			pivinv = float32(1/float64(A[icol][icol]))
			A[icol][icol] = float32(1)
			for l = 1; l <= n; l++ {
				A[icol][l] *= pivinv
			}
			for l = 1; l <= m; l++ {
				B[icol][l] *= pivinv
			}
			{
				//  Next, we reduce the rows ... except for the pivot one, of course.
				for ll = 1; ll <= n; ll++ {
					if ll != icol {
						dum = A[ll][icol]
						A[ll][icol] = float32(0)
						for l = 1; l <= n; l++ {
							A[ll][l] -= A[icol][l]*dum
						}
						for l = 1; l <= m; l++ {
							B[ll][l] -= B[icol][l]*dum
						}
					}
				}
			}
		}
	}
	{
		// This is the end of the main loop over columns of the reduction. It only remains to unscram-
		// * ble the solution in view of the column interchanges. We do this by interchanging pairs of
		// * columns in the reverse order that the permutation was built up.
		//
		for l = n; l >= 1; l-- {
			if indxr[l] != indxc[l] {
				for k = 1; k <= n; k++ {
					temp = A[k][indxr[l]]
					A[k][indxr[l]] = A[k][indxc[l]]
					A[k][indxc[l]] = temp
				}
			}
		}
	}
	//  And we are done.
	free_ivector(ipiv, 1, n)
	free_ivector(indxr, 1, n)
	free_ivector(indxc, 1, n)
}
// lu_dcmp - transpiled function from  GOPATH/History_frame3DD/src/HPGmatrix.c:154
func lu_dcmp(A [][]float64, n int32, b []float64, reduce int32, solve int32, pd []int32) {
	//
	// * LU_DCMP
	// * Solves [A]{x} = {b} simply and efficiently by performing an
	// * LU - decomposition of [A].  No pivoting is performed.
	// * [A] is a diagonally dominant matrix of dimension [1..n][1..n].
	// * {b} is a r.h.s. vector of dimension [1..n].
	// * {b} is updated using [LU] and then back-substitution is done to obtain {x}.
	// * {b} is replaced by {x} and [A] is replaced by the LU - reduction of itself.
	// *
	// *  usage:  double **A, *b;
	// *   int   n, reduce, solve, pd;
	// *   lu_dcmp ( A, n, b, reduce, solve, &pd );       5may98
	//
	// the system matrix, and it's LU- reduction
	// the dimension of the matrix
	// the right hand side vector, and the solution vector
	// 1: do a forward reduction; 0: don't do the reduction
	// 1: do a back substitution for {x};  0: do no bk-sub'n
	// 1: positive diagonal  and  successful LU decomp'n
	// a diagonal element of [A]
	var pivot float64
	var i int32
	var j int32
	var k int32
	pd[0] = 1
	if reduce != 0 {
		// forward reduction of [A]
		for k = 1; k <= n; k++ {
			if 0 == (func() float64 {
				pivot = A[k][k]
				return pivot
			}()) {
				noarch.Fprintf(noarch.Stderr, []byte(" lu_dcmp: zero found on the diagonal\n\x00"))
				noarch.Fprintf(noarch.Stderr, []byte(" A[%d][%d] = %11.4e\n\x00"), k, k, A[k][k])
				pd[0] = 0
				return
			}
			for i = k+1; i <= n; i++ {
				A[i][k] /= pivot
				for j = k+1; j <= n; j++ {
					A[i][j] -= A[i][k]*A[k][j]
				}
			}
		}
	}
	if solve != 0 {
		{
			// the forward reduction of [A] is now complete
			// back substitution to solve for {x}
			// {b} is run through the same forward reduction as was [A]
			for k = 1; k <= n; k++ {
				for i = k+1; i <= n; i++ {
					b[i] -= A[i][k]*b[k]
				}
			}
		}
		{
			// now back substitution is conducted on {b};  [A] is preserved
			for j = n; j >= 2; j-- {
				for i = 1; i <= j-1; i++ {
					b[i] -= b[j]*A[i][j]/A[j][j]
				}
			}
		}
		{
			// finally we solve for the {x} vector
			for i = 1; i <= n; i++ {
				b[i] /= A[i][i]
			}
		}
	}
	// TAA DAAAAAAAA! {b} is now {x} and is ready to be returned
}
// ldl_dcmp - transpiled function from  GOPATH/History_frame3DD/src/HPGmatrix.c:222
func ldl_dcmp(A [][]float64, n int32, d []float64, b []float64, x []float64, reduce int32, solve int32, pd []int32) {
	//
	// * LDL_DCMP  -  Solves [A]{x} = {b} simply and efficiently by performing an
	// * L D L' - decomposition of [A].  No pivoting is performed.
	// * [A] is a symmetric diagonally-dominant matrix of dimension [1..n][1..n].
	// * {b} is a r.h.s. vector of dimension [1..n].
	// * {b} is updated using L D L' and then back-substitution is done to obtain {x}
	// * {b} is returned unchanged.  ldl_dcmp(A,n,d,x,x,1,1,&pd) is valid.
	// *     The lower triangle of [A] is replaced by the lower triangle L of the
	// *     L D L' reduction.  The diagonal of D is returned in the vector {d}
	// *
	// * usage: double **A, *d, *b, *x;
	// * int   n, reduce, solve, pd;
	// * ldl_dcmp ( A, n, d, b, x, reduce, solve, &pd );
	// *
	// * H.P. Gavin, Civil Engineering, Duke University, hpgavin@duke.edu  9 Oct 2001
	// * Bathe, Finite Element Procecures in Engineering Analysis, Prentice Hall, 1982
	//
	// the system matrix, and L of the L D L' decomp.
	// the dimension of the matrix
	// diagonal of D in the  L D L' - decomp'n
	// the right hand side vector
	// the solution vector
	// 1: do a forward reduction of A; 0: don't
	// 1: do a back substitution for {x}; 0: don't
	// 1: definite matrix and successful L D L' decomp'n
	var i int32
	var j int32
	var k int32
	var m int32
	// number of negative elements on the diagonal of D
	pd[0] = 0
	if reduce != 0 {
		// forward column-wise reduction of [A]
		for j = 1; j <= n; j++ {
			{
				// scan the sky-line
				m = 1
				i = 1
				for i = 1; i < j; i++ {
					if A[i][j] == 0 {
						m ++
					} else {
						break
					}
				}
			}
			for i = m; i < j; i++ {
				A[j][i] = A[i][j]
				for k = m; k < i; k++ {
					A[j][i] -= A[j][k]*A[i][k]
				}
			}
			d[j] = A[j][j]
			for i = m; i < j; i++ {
				d[j] -= A[j][i]*A[j][i]/d[i]
			}
			for i = m; i < j; i++ {
				A[j][i] /= d[i]
			}
			if d[j] == 0 {
				noarch.Fprintf(noarch.Stderr, []byte(" ldl_dcmp(): zero found on diagonal ...\n\x00"))
				noarch.Fprintf(noarch.Stderr, []byte(" d[%d] = %11.4e\n\x00"), j, d[j])
				return
			}
			if d[j] < 0 {
				pd[0] --
			}
		}
	}
	if solve != 0 {
		{
			// the forward reduction of [A] is now complete
			// back substitution to solve for {x}
			// {x} is run through the same forward reduction as was [A]
			for i = 1; i <= n; i++ {
				x[i] = b[i]
				for j = 1; j < i; j++ {
					x[i] -= A[i][j]*x[j]
				}
			}
		}
		for i = 1; i <= n; i++ {
			x[i] /= d[i]
		}
		{
			// now back substitution is conducted on {x};  [A] is preserved
			for i = n; i > 1; i-- {
				for j = 1; j < i; j++ {
					x[j] -= A[i][j]*x[i]
				}
			}
		}
	}
}
// ldl_mprove - transpiled function from  GOPATH/History_frame3DD/src/HPGmatrix.c:295
func ldl_mprove(A [][]float64, n int32, d []float64, b []float64, x []float64, rms_resid []float64, ok []int32) {
	//
	// * LDL_MPROVE  Improves a solution vector x[1..n] of the linear set of equations
	// * [A]{x} = {b}.  The matrix A[1..n][1..n], and the vectors b[1..n] and x[1..n]
	// * are input, as is the dimension n.   The matrix [A] is the L D L'
	// * decomposition of the original system matrix, as returned by ldl_dcmp().
	// * Also input is the diagonal vector, {d} of [D] of the L D L' decompositon.
	// * On output, only {x} is modified to an improved set of values.
	// *
	// * usage: double **A, *d, *b, *x, rms_resid;
	// *  int   n, ok;
	// *  ldl_mprove ( A, n, d, b, x, &rms_resid, &ok );
	// *
	// * H.P. Gavin, Civil Engineering, Duke University, hpgavin@duke.edu  4 May 2001
	//
	// accumulate the r.h.s. in double precision
	var sdp float64
	// the residual error
	var resid []float64
	var rms_resid_new float64// j - transpiled function from  GOPATH/History_frame3DD/src/HPGmatrix.c:303
	// the RMS error of the mprvd solution
	// allocate memory for a vector	of doubles
	var j int32// i - transpiled function from  GOPATH/History_frame3DD/src/HPGmatrix.c:303
	var i int32// pd - transpiled function from  GOPATH/History_frame3DD/src/HPGmatrix.c:303
	var pd int32
	resid = dvector(1, n)
	{
		// calculate the r.h.s. of
		for i = 1; i <= n; i++ {
			// [A]{r} = {b} - [A]{x+r}
			sdp = b[i]
			{
				// A in upper triangle only
				for j = 1; j <= n; j++ {
					if i <= j {
						sdp -= A[i][j]*x[j]
					} else {
						sdp -= A[j][i]*x[j]
					}
				}
			}
			resid[i] = sdp
		}
	}
	// solve for the error term
	ldl_dcmp(A, n, d, resid, resid, 0, 1, c4goUnsafeConvert_int32(&pd))
	for i = 1; i <= n; i++ {
		rms_resid_new += resid[i]*resid[i]
	}
	rms_resid_new = math.Sqrt(rms_resid_new/float64(n))
	ok[0] = 0
	if rms_resid_new/rms_resid[0] < 0.9 {
		{
			// good improvement
			// subtract the error from the old solution
			for i = 1; i <= n; i++ {
				x[i] += resid[i]
			}
		}
		rms_resid[0] = rms_resid_new
		// the solution has improved
		ok[0] = 1
	}
	free_dvector(resid, 1, n)
}
// ldl_dcmp_pm - transpiled function from  GOPATH/History_frame3DD/src/HPGmatrix.c:366
func ldl_dcmp_pm(A [][]float64, n int32, d []float64, b []float64, x []float64, c []float64, q []int32, r []int32, reduce int32, solve int32, pd []int32) {
	//
	// * LDL_DCMP_PM  -  Solves partitioned matrix equations
	// *
	// *           [A_qq]{x_q} + [A_qr]{x_r} = {b_q}
	// *           [A_rq]{x_q} + [A_rr]{x_r} = {b_r}+{c_r}
	// *           where {b_q}, {b_r}, and {x_r} are known and
	// *           where {x_q} and {c_r} are unknown
	// *
	// * via L D L' - decomposition of [A_qq].  No pivoting is performed.
	// * [A] is a symmetric diagonally-dominant matrix of dimension [1..n][1..n].
	// * {b} is a r.h.s. vector of dimension [1..n].
	// * {b} is updated using L D L' and then back-substitution is done to obtain {x}
	// * {b_q} and {b_r}  are returned unchanged.
	// * {c_r} is returned as a vector of [1..n] with {c_q}=0.
	// * {q} is a vector of the indexes of known values {b_q}
	// * {r} is a vector of the indexes of known values {x_r}
	// *     The lower triangle of [A_qq] is replaced by the lower triangle L of its
	// *     L D L' reduction.  The diagonal of D is returned in the vector {d}
	// *
	// * usage: double **A, *d, *b, *x;
	// * int   n, reduce, solve, pd;
	// * ldl_dcmp_pm ( A, n, d, b, x, c, q, r, reduce, solve, &pd );
	// *
	// * H.P. Gavin, Civil Engineering, Duke University, hpgavin@duke.edu
	// * Bathe, Finite Element Procecures in Engineering Analysis, Prentice Hall, 1982
	// * 2014-05-14
	//
	//< the system matrix, and L of the L D L' decomp.
	//< the dimension of the matrix
	//< diagonal of D in the  L D L' - decomp'n
	//< the right hand side vector
	//< part of the solution vector
	//< the part of the solution vector in the rhs
	//< q[j]=1 if  b[j] is known; q[j]=0 otherwise
	//< r[j]=1 if  x[j] is known; r[j]=0 otherwise
	//< 1: do a forward reduction of A; 0: don't
	//< 1: do a back substitution for {x}; 0: don't
	//< 1: definite matrix and successful L D L' decomp'n
	var i int32
	var j int32
	var k int32
	var m int32
	// number of negative elements on the diagonal of D
	pd[0] = 0
	if reduce != 0 {
		// forward column-wise reduction of [A]
		for j = 1; j <= n; j++ {
			d[j] = 0
			if q[j] != 0 {
				{
					// reduce column j, except where q[i]==0
					// scan the sky-line
					m = 1
					i = 1
					for i = 1; i < j; i++ {
						if A[i][j] == 0 {
							m ++
						} else {
							break
						}
					}
				}
				for i = m; i < j; i++ {
					if q[i] != 0 {
						A[j][i] = A[i][j]
						for k = m; k < i; k++ {
							if q[k] != 0 {
								A[j][i] -= A[j][k]*A[i][k]
							}
						}
					}
				}
				d[j] = A[j][j]
				for i = m; i < j; i++ {
					if q[i] != 0 {
						d[j] -= A[j][i]*A[j][i]/d[i]
					}
				}
				for i = m; i < j; i++ {
					if q[i] != 0 {
						A[j][i] /= d[i]
					}
				}
				if d[j] == 0 {
					noarch.Fprintf(noarch.Stderr, []byte(" ldl_dcmp_pm(): zero found on diagonal ...\n\x00"))
					noarch.Fprintf(noarch.Stderr, []byte(" d[%d] = %11.4e\n\x00"), j, d[j])
					return
				}
				if d[j] < 0 {
					pd[0] --
				}
			}
		}
	}
	if solve != 0 {
		{
			// the forward reduction of [A] is now complete
			// back substitution to solve for {x}
			for i = 1; i <= n; i++ {
				if q[i] != 0 {
					x[i] = b[i]
					for j = 1; j <= n; j++ {
						if r[j] != 0 {
							x[i] -= A[i][j]*x[j]
						}
					}
				}
			}
		}
		{
			// {x} is run through the same forward reduction as was [A]
			for i = 1; i <= n; i++ {
				if q[i] != 0 {
					for j = 1; j < i; j++ {
						if q[j] != 0 {
							x[i] -= A[i][j]*x[j]
						}
					}
				}
			}
		}
		for i = 1; i <= n; i++ {
			if q[i] != 0 {
				x[i] /= d[i]
			}
		}
		{
			// now back substitution is conducted on {x};  [A] is preserved
			for i = n; i > 1; i-- {
				if q[i] != 0 {
					for j = 1; j < i; j++ {
						if q[j] != 0 {
							x[j] -= A[i][j]*x[i]
						}
					}
				}
			}
		}
		{
			// finally, evaluate c_r
			for i = 1; i <= n; i++ {
				c[i] = 0
				if r[i] != 0 {
					// changed from 0.0 to -b[i]; 2014-05-14
					c[i] = -b[i]
					for j = 1; j <= n; j++ {
						c[i] += A[i][j]*x[j]
					}
				}
			}
		}
	}
}
// ldl_mprove_pm - transpiled function from  GOPATH/History_frame3DD/src/HPGmatrix.c:479
func ldl_mprove_pm(A [][]float64, n int32, d []float64, b []float64, x []float64, c []float64, q []int32, r []int32, rms_resid []float64, ok []int32) {
	//
	// * LDL_MPROVE_PM
	// * Improves a solution vector x[1..n] of the partitioned set of linear equations
	// *           [A_qq]{x_q} + [A_qr]{x_r} = {b_q}
	// *           [A_rq]{x_q} + [A_rr]{x_r} = {b_r}+{c_r}
	// *           where {b_q}, {b_r}, and {x_r} are known and
	// *           where {x_q} and {c_r} are unknown
	// * by reducing the residual r_q
	// *           A_qq r_q = {b_q} - [A_qq]{x_q+r_q} + [A_qr]{x_r}
	// * The matrix A[1..n][1..n], and the vectors b[1..n] and x[1..n]
	// * are input, as is the dimension n.   The matrix [A_qq] is the L D L'
	// * decomposition of the original system matrix, as returned by ldl_dcmp_pm().
	// * Also input is the diagonal vector, {d} of [D] of the L D L' decompositon.
	// * On output, only {x} and {c} are modified to an improved set of values.
	// * The partial right-hand-side vectors, {b_q} and {b_r}, are returned unchanged.
	// * Further, the calculations in ldl_mprove_pm do not involve b_r.
	// *
	// * usage: double **A, *d, *b, *x, rms_resid;
	// *  int   n, ok, *q, *r;
	// *  ldl_mprove_pm ( A, n, d, b, x, q, r, &rms_resid, &ok );
	// *
	// * H.P. Gavin, Civil Engineering, Duke University, hpgavin@duke.edu
	// * 2001-05-01, 2014-05-14
	//
	//< the system matrix, and L of the L D L' decomp.
	//< the dimension of the matrix
	//< diagonal of D in the  L D L' - decomp'n
	//< the right hand side vector
	//< part of the solution vector
	//< the part of the solution vector in the rhs
	//< q[j]=1 if  b[j] is known; q[j]=0 otherwise
	//< r[j]=1 if  x[j] is known; r[j]=0 otherwise
	//< root-mean-square of residual error
	//< 1: >10% reduction in rms_resid; 0: not
	// accumulate the r.h.s. in double precision
	var sdp float64
	// the residual error
	var dx []float64
	var dc []float64
	var rms_resid_new float64// j - transpiled function from  GOPATH/History_frame3DD/src/HPGmatrix.c:496
	// update to partial r.h.s. vector, c
	// the RMS error of the mprvd solution
	// allocate memory for a vector	of doubles
	var j int32// i - transpiled function from  GOPATH/History_frame3DD/src/HPGmatrix.c:496
	var i int32// pd - transpiled function from  GOPATH/History_frame3DD/src/HPGmatrix.c:496
	var pd int32
	dx = dvector(1, n)
	dc = dvector(1, n)
	for i = 1; i <= n; i++ {
		dx[i] = 0
	}
	{
		// calculate the r.h.s. of ...
		//  [A_qq]{dx_q} = {b_q} - [A_qq]*{x_q} - [A_qr]*{x_r}
		//  {dx_r} is left unchanged at 0.0;
		for i = 1; i <= n; i++ {
			if q[i] != 0 {
				sdp = b[i]
				for j = 1; j <= n; j++ {
					if q[j] != 0 {
						if i <= j {
							// A_qq in upper triangle only
							sdp -= A[i][j]*x[j]
						} else {
							sdp -= A[j][i]*x[j]
						}
					}
				}
				for j = 1; j <= n; j++ {
					if r[j] != 0 {
						sdp -= A[i][j]*x[j]
					}
				}
				dx[i] = sdp
			}
		}
	}
	// else dx[i] = 0.0; // x[i];
	// solve for the residual error term, A is already factored
	ldl_dcmp_pm(A, n, d, dx, dx, dc, q, r, 0, 1, c4goUnsafeConvert_int32(&pd))
	for i = 1; i <= n; i++ {
		if q[i] != 0 {
			rms_resid_new += dx[i]*dx[i]
		}
	}
	rms_resid_new = math.Sqrt(rms_resid_new/float64(n))
	ok[0] = 0
	if rms_resid_new/rms_resid[0] < 0.9 {
		{
			//  enough improvement
			//  update the solution 2014-05-14
			for i = 1; i <= n; i++ {
				if q[i] != 0 {
					x[i] += dx[i]
				}
				if r[i] != 0 {
					c[i] += dc[i]
				}
			}
		}
		// return the new residual
		rms_resid[0] = rms_resid_new
		// the solution has improved
		ok[0] = 1
	}
	free_dvector(dx, 1, n)
	free_dvector(dc, 1, n)
}
// PSB_update - transpiled function from  GOPATH/History_frame3DD/src/HPGmatrix.c:553
func PSB_update(B [][]float64, f []float64, d []float64, n int32) {
	//
	// * PSB_UPDATE
	// * Update secant stiffness matrix via the Powell-Symmetric-Broyden update eqn.
	// *
	// *       B = B - (f*d' + d*f') / (d' * d) + f'*d * d*d' / (d' * d)^2 ;
	// *
	// * H.P. Gavin, Civil Engineering, Duke University, hpgavin@duke.edu  24 Oct 2012
	//
	//< secant stiffness matrix
	//< out-of-balance force vector
	//< incremental displacement vector
	//< matrix dimension is n-by-n
	var i int32
	var j int32
	var dtd float64
	var ftd float64
	var dtd2 float64
	for i = 1; i <= n; i++ {
		dtd += d[i]*d[i]
	}
	dtd2 = dtd*dtd
	for i = 1; i <= n; i++ {
		ftd += f[i]*d[i]
	}
	{
		//  update upper triangle of B[i][j]
		for i = 1; i <= n; i++ {
			for j = i; j <= n; j++ {
				B[i][j] -= (f[i]*d[j]+f[j]*d[i])/dtd-ftd*d[i]*d[j]/dtd2
			}
		}
	}
}
// pseudo_inv - transpiled function from  GOPATH/History_frame3DD/src/HPGmatrix.c:580
func pseudo_inv(A [][]float64, Ai [][]float64, n int32, m int32, beta float64, verbose int32) {
	var diag []float64
	var b []float64
	var x []float64
	var AtA [][]float64
	var AtAi [][]float64
	var tmp float64
	var tr_AtA float64// error_ - transpiled function from  GOPATH/History_frame3DD/src/HPGmatrix.c:583
	//
	// * PSEUDO_INV - calculate the pseudo-inverse of A ,
	// * 	     Ai = inv ( A'*A + beta * trace(A'*A) * I ) * A'
	// *	     beta is a regularization factor, which should be small (1e-10)
	// *	     A is m by n      Ai is m by n			      8oct01
	//
	var error_ float64// i - transpiled function from  GOPATH/History_frame3DD/src/HPGmatrix.c:585
	var i int32// j - transpiled function from  GOPATH/History_frame3DD/src/HPGmatrix.c:585
	var j int32// k - transpiled function from  GOPATH/History_frame3DD/src/HPGmatrix.c:585
	var k int32// ok - transpiled function from  GOPATH/History_frame3DD/src/HPGmatrix.c:585
	var ok int32
	diag = dvector(1, n)
	b = dvector(1, n)
	x = dvector(1, n)
	AtA = dmatrix(1, n, 1, n)
	AtAi = dmatrix(1, n, 1, n)
	if beta > 1 {
		noarch.Fprintf(noarch.Stderr, []byte(" pseudo_inv: warning beta = %f\n\x00\x00"), beta)
	}
	for i = 1; i <= n; i++ {
		b[i] = 0
		x[i] = b[i]
		diag[i] = x[i]
		for j = i; j <= n; j++ {
			AtA[j][i] = 0
			AtA[i][j] = AtA[j][i]
		}
	}
	{
		// compute A' * A
		for i = 1; i <= n; i++ {
			for j = 1; j <= n; j++ {
				tmp = 0
				for k = 1; k <= m; k++ {
					tmp += A[k][i]*A[k][j]
				}
				AtA[i][j] = tmp
			}
		}
	}
	{
		// make symmetric
		for i = 1; i <= n; i++ {
			for j = i; j <= n; j++ {
				AtA[j][i] = 0.5*(AtA[i][j]+AtA[j][i])
				AtA[i][j] = AtA[j][i]
			}
		}
	}
	tr_AtA = 0
	{
		// trace of AtA
		for i = 1; i <= n; i++ {
			tr_AtA += AtA[i][i]
		}
	}
	{
		// add beta I
		for i = 1; i <= n; i++ {
			AtA[i][i] += beta*tr_AtA
		}
	}
	//  L D L'  decomp
	ldl_dcmp(AtA, n, diag, b, x, 1, 0, c4goUnsafeConvert_int32(&ok))
	{
		// compute inv(AtA)
		for j = 1; j <= n; j++ {
			for k = 1; k <= n; k++ {
				b[k] = 0
			}
			b[j] = 1
			// L D L' bksbtn
			ldl_dcmp(AtA, n, diag, b, x, 0, 1, c4goUnsafeConvert_int32(&ok))
			if verbose != 0 {
				//improve the solution
				noarch.Fprintf(noarch.Stdout, []byte("  RMS matrix error:\x00"))
			}
			error_ = 1
			ok = 1
			for {
				ldl_mprove(AtA, n, diag, b, x, c4goUnsafeConvert_float64(&error_), c4goUnsafeConvert_int32(&ok))
				if verbose != 0 {
					noarch.Fprintf(noarch.Stdout, []byte("%9.2e\x00"), error_)
				}
				if noarch.Not(ok) {
					break
				}
			}
			if verbose != 0 {
				noarch.Fprintf(noarch.Stdout, []byte("\n\x00"))
			}
			{
				// save inv(AtA)
				for k = 1; k <= n; k++ {
					AtAi[k][j] = x[k]
				}
			}
		}
	}
	{
		// make symmetric
		for i = 1; i <= n; i++ {
			for j = i; j <= n; j++ {
				AtAi[j][i] = 0.5*(AtAi[i][j]+AtAi[j][i])
				AtAi[i][j] = AtAi[j][i]
			}
		}
	}
	{
		// compute inv(A'*A)*A'
		for i = 1; i <= n; i++ {
			for j = 1; j <= m; j++ {
				tmp = 0
				for k = 1; k <= n; k++ {
					tmp += AtAi[i][k]*A[j][k]
				}
				Ai[i][j] = tmp
			}
		}
	}
	free_dmatrix(AtAi, 1, n, 1, n)
	free_dmatrix(AtA, 1, n, 1, n)
	free_dvector(x, 1, n)
	free_dvector(b, 1, n)
	free_dvector(diag, 1, n)
}
// prodABj - transpiled function from  GOPATH/History_frame3DD/src/HPGmatrix.c:662
func prodABj(A [][]float64, B [][]float64, u []float64, n int32, j int32) {
	//
	// * PRODABj -  matrix-matrix multiplication for symmetric A       27apr01
	// *                                                           u = A * B(:,j)
	//
	var i int32
	var k int32
	for i = 1; i <= n; i++ {
		u[i] = 0
	}
	for i = 1; i <= n; i++ {
		for k = 1; k <= n; k++ {
			if i <= k {
				u[i] += A[i][k]*B[k][j]
			} else {
				u[i] += A[k][i]*B[k][j]
			}
		}
	}
}
// prodAB - transpiled function from  GOPATH/History_frame3DD/src/HPGmatrix.c:681
func prodAB(A [][]float64, B [][]float64, C [][]float64, I int32, J int32, K int32) {
	//
	// * prodAB - matrix-matrix multiplication      C = A * B   27apr01
	//
	var i int32
	var j int32
	var k int32
	for i = 1; i <= I; i++ {
		for k = 1; k <= K; k++ {
			C[i][k] = 0
		}
	}
	for i = 1; i <= I; i++ {
		for k = 1; k <= K; k++ {
			for j = 1; j <= J; j++ {
				C[i][k] += A[i][j]*B[j][k]
			}
		}
	}
}
// invAB - transpiled function from  GOPATH/History_frame3DD/src/HPGmatrix.c:701
func invAB(A [][]float64, B [][]float64, n int32, m int32, AiB [][]float64, ok []int32, verbose int32) {
	//
	// * INVAB  -  calculate product inv(A) * B
	// *  A is n by n      B is n by m        6jun07
	//
	var diag []float64
	var b []float64
	var x []float64
	var error_ float64
	var i int32
	var j int32
	var k int32
	diag = dvector(1, n)
	x = dvector(1, n)
	b = dvector(1, n)
	for i = 1; i <= n; i++ {
		x[i] = 0
		diag[i] = x[i]
	}
	//   L D L'  decomp
	ldl_dcmp(A, n, diag, b, x, 1, 0, ok)
	if ok[0] < 0 {
		noarch.Fprintf(noarch.Stderr, []byte(" Make sure that all six\x00"))
		noarch.Fprintf(noarch.Stderr, []byte(" rigid body translations are restrained!\n\x00"))
	}
	for j = 1; j <= m; j++ {
		for k = 1; k <= n; k++ {
			b[k] = B[k][j]
		}
		//   L D L'  bksbtn
		ldl_dcmp(A, n, diag, b, x, 0, 1, ok)
		if verbose != 0 {
			noarch.Fprintf(noarch.Stdout, []byte("    LDL' RMS matrix precision:\x00"))
		}
		ok[0] = 1
		error_ = float64(ok[0])
		for {
			// improve the solution
			ldl_mprove(A, n, diag, b, x, c4goUnsafeConvert_float64(&error_), ok)
			if verbose != 0 {
				noarch.Fprintf(noarch.Stdout, []byte("%9.2e\x00"), error_)
			}
			if noarch.Not(ok[0]) {
				break
			}
		}
		if verbose != 0 {
			noarch.Fprintf(noarch.Stdout, []byte("\n\x00"))
		}
		for i = 1; i <= n; i++ {
			AiB[i][j] = x[i]
		}
	}
	free_dvector(diag, 1, n)
	free_dvector(x, 1, n)
	free_dvector(b, 1, n)
}
// xtinvAy - transpiled function from  GOPATH/History_frame3DD/src/HPGmatrix.c:744
func xtinvAy(X [][]float64, A [][]float64, Y [][]float64, n int32, m int32, Ac [][]float64, verbose int32) {
	//
	// * XTinvAY  -  calculate quadratic form with inverse matrix   X' * inv(A) * Y
	// *    A is n by n    X is n by m     Y is n by m      15sep01
	//
	var diag []float64
	var x []float64
	var y []float64
	var error_ float64
	var i int32
	var j int32
	var k int32
	var ok int32
	diag = dvector(1, n)
	x = dvector(1, n)
	y = dvector(1, n)
	for i = 1; i <= n; i++ {
		x[i] = 0
		diag[i] = x[i]
	}
	//   L D L'  decomp
	ldl_dcmp(A, n, diag, y, x, 1, 0, c4goUnsafeConvert_int32(&ok))
	for j = 1; j <= m; j++ {
		for k = 1; k <= n; k++ {
			y[k] = Y[k][j]
		}
		//   L D L'  bksbtn
		ldl_dcmp(A, n, diag, y, x, 0, 1, c4goUnsafeConvert_int32(&ok))
		if verbose != 0 {
			noarch.Fprintf(noarch.Stdout, []byte("    LDL' RMS matrix precision:\x00"))
		}
		ok = 1
		error_ = float64(ok)
		for {
			// improve the solution
			ldl_mprove(A, n, diag, y, x, c4goUnsafeConvert_float64(&error_), c4goUnsafeConvert_int32(&ok))
			if verbose != 0 {
				noarch.Fprintf(noarch.Stdout, []byte("%9.2e\x00"), error_)
			}
			if noarch.Not(ok) {
				break
			}
		}
		if verbose != 0 {
			noarch.Fprintf(noarch.Stdout, []byte("\n\x00"))
		}
		for i = 1; i <= m; i++ {
			Ac[i][j] = 0
			for k = 1; k <= n; k++ {
				Ac[i][j] += X[k][i]*x[k]
			}
		}
	}
	free_dvector(diag, 1, n)
	free_dvector(x, 1, n)
	free_dvector(y, 1, n)
}
// coord_xfrm - transpiled function from  GOPATH/History_frame3DD/src/HPGmatrix.c:787
func coord_xfrm(Rr [][]float32, R [][]float32, theta float32, n int32) {
	//  COORD_XFRM - coordinate transform of a matrix of column 2-vectors
	// *
	// * Rr  = [ cosd(theta) -sind(theta) ; sind(theta) cosd(theta) ]*[ Rx ; Ry ];
	//
	var R1 float32
	var R2 float32
	var i int32
	for i = 1; i <= n; i++ {
		R1 = float32(math.Cos(math.Mod(float64(theta), 360)*3.141592653589793/180)*float64(R[1][i])-math.Sin(math.Mod(float64(theta), 360)*3.141592653589793/180)*float64(R[2][i]))
		R2 = float32(math.Sin(math.Mod(float64(theta), 360)*3.141592653589793/180)*float64(R[1][i])+math.Cos(math.Mod(float64(theta), 360)*3.141592653589793/180)*float64(R[2][i]))
		Rr[1][i] = R1
		Rr[2][i] = R2
	}
}
// xtAx - transpiled function from  GOPATH/History_frame3DD/src/HPGmatrix.c:806
func xtAx(A [][]float64, X [][]float64, C [][]float64, N int32, J int32) {
	//
	// * xtAx - carry out matrix-matrix-matrix multiplication for symmetric A  7nov02
	// *  C = X' A X     C is J by J      X is N by J     A is N by N
	//
	var AX [][]float64
	var i int32
	var j int32
	var k int32
	AX = dmatrix(1, N, 1, J)
	for i = 1; i <= J; i++ {
		for j = 1; j <= J; j++ {
			C[i][j] = 0
		}
	}
	for i = 1; i <= N; i++ {
		for j = 1; j <= J; j++ {
			AX[i][j] = 0
		}
	}
	{
		//  use upper triangle of A
		for i = 1; i <= N; i++ {
			for j = 1; j <= J; j++ {
				for k = 1; k <= N; k++ {
					if i <= k {
						AX[i][j] += A[i][k]*X[k][j]
					} else {
						AX[i][j] += A[k][i]*X[k][j]
					}
				}
			}
		}
	}
	for i = 1; i <= J; i++ {
		for j = 1; j <= J; j++ {
			for k = 1; k <= N; k++ {
				C[i][j] += X[k][i]*AX[k][j]
			}
		}
	}
	{
		//  make  C  symmetric
		for i = 1; i <= J; i++ {
			for j = i; j <= J; j++ {
				C[j][i] = 0.5*(C[i][j]+C[j][i])
				C[i][j] = C[j][i]
			}
		}
	}
	free_dmatrix(AX, 1, N, 1, J)
}
// xtAy - transpiled function from  GOPATH/History_frame3DD/src/HPGmatrix.c:843
func xtAy(x []float64, A [][]float64, y []float64, n int32, d []float64) float64 {
	//
	// * xtAy - carry out vector-matrix-vector multiplication for symmetric A  7apr94
	//
	var xtAy float64
	var i int32
	var j int32
	{
		//  d = A y
		for i = 1; i <= n; i++ {
			d[i] = 0
			{
				//  A in upper triangle only
				for j = 1; j <= n; j++ {
					if i <= j {
						d[i] += A[i][j]*y[j]
					} else {
						d[i] += A[j][i]*y[j]
					}
				}
			}
		}
	}
	{
		//  xAy = x' A y
		for i = 1; i <= n; i++ {
			xtAy += x[i]*d[i]
		}
	}
	return xtAy
}
// invAXinvA - transpiled function from  GOPATH/History_frame3DD/src/HPGmatrix.c:866
func invAXinvA(A [][]float64, X [][]float64, n int32, verbose int32) {
	//
	// * invAXinvA -  calculate quadratic form with inverse matrix
	// *    replace X with inv(A) * X * inv(A)
	// *    A is n by n and symmetric   X is n by n and symmetric    15sep01
	//
	var diag []float64
	var b []float64
	var x []float64
	var Ai [][]float64
	var XAi [][]float64
	var Aij float64
	var error_ float64
	var i int32
	var j int32
	var k int32
	var ok int32
	diag = dvector(1, n)
	x = dvector(1, n)
	b = dvector(1, n)
	Ai = dmatrix(1, n, 1, n)
	XAi = dmatrix(1, n, 1, n)
	for i = 1; i <= n; i++ {
		b[i] = 0
		x[i] = b[i]
		diag[i] = x[i]
		for j = 1; j <= n; j++ {
			Ai[i][j] = 0
			XAi[i][j] = Ai[i][j]
		}
	}
	//   L D L'  decomp
	ldl_dcmp(A, n, diag, b, x, 1, 0, c4goUnsafeConvert_int32(&ok))
	{
		//  compute inv(A)
		for j = 1; j <= n; j++ {
			for k = 1; k <= n; k++ {
				b[k] = 0
			}
			b[j] = 1
			//   L D L'  bksbtn
			ldl_dcmp(A, n, diag, b, x, 0, 1, c4goUnsafeConvert_int32(&ok))
			if verbose != 0 {
				noarch.Fprintf(noarch.Stdout, []byte("    LDL' RMS matrix precision:\x00"))
			}
			ok = 1
			error_ = float64(ok)
			for {
				// improve the solution
				ldl_mprove(A, n, diag, b, x, c4goUnsafeConvert_float64(&error_), c4goUnsafeConvert_int32(&ok))
				if verbose != 0 {
					noarch.Fprintf(noarch.Stdout, []byte("%9.2e\x00"), error_)
				}
				if noarch.Not(ok) {
					break
				}
			}
			if verbose != 0 {
				noarch.Fprintf(noarch.Stdout, []byte("\n\x00"))
			}
			{
				//  save inv(A)
				for k = 1; k <= n; k++ {
					Ai[j][k] = x[k]
				}
			}
		}
	}
	{
		//  make symmetric
		for i = 1; i <= n; i++ {
			for j = i; j <= n; j++ {
				Ai[j][i] = 0.5*(Ai[i][j]+Ai[j][i])
				Ai[i][j] = Ai[j][i]
			}
		}
	}
	{
		//  compute X * inv(A)
		for i = 1; i <= n; i++ {
			for j = 1; j <= n; j++ {
				Aij = 0
				for k = 1; k <= n; k++ {
					Aij += X[i][k]*Ai[k][j]
				}
				XAi[i][j] = Aij
			}
		}
	}
	{
		//  compute inv(A) * X * inv(A)
		for i = 1; i <= n; i++ {
			for j = 1; j <= n; j++ {
				Aij = 0
				for k = 1; k <= n; k++ {
					Aij += Ai[i][k]*XAi[k][j]
				}
				X[i][j] = Aij
			}
		}
	}
	{
		//  make symmetric
		for i = 1; i <= n; i++ {
			for j = i; j <= n; j++ {
				X[j][i] = 0.5*(X[i][j]+X[j][i])
				X[i][j] = X[j][i]
			}
		}
	}
	free_dvector(diag, 1, n)
	free_dvector(x, 1, n)
	free_dvector(b, 1, n)
	free_dmatrix(Ai, 1, n, 1, n)
	free_dmatrix(XAi, 1, n, 1, n)
}
// relative_norm - transpiled function from  GOPATH/History_frame3DD/src/HPGmatrix.c:939
func relative_norm(N []float64, D []float64, n int32) float64 {
	//
	// *  RELATIVE_NORM -  compute the relative 2-norm between two vectors       26dec01
	// *       compute the relative 2-norm between two vectors N and D
	// *        return  ( sqrt(sum(N[i]*N[i]) / sqrt(D[i]*D[i]) )
	// *
	//
	var nN float64
	var nD float64
	var i int32
	for i = 1; i <= n; i++ {
		nN += N[i]*N[i]
	}
	for i = 1; i <= n; i++ {
		nD += D[i]*D[i]
	}
	return math.Sqrt(nN) / math.Sqrt(nD)
}
// Legendre - transpiled function from  GOPATH/History_frame3DD/src/HPGmatrix.c:955
func Legendre(order int32, t []float32, n int32, P [][]float32, Pp [][]float32, Ppp [][]float32) {
	//
	// *  Legendre
	// *  compute matrix of the Legendre polynomials and its first two derivitives
	//
	var k int32
	var p int32
	{
		// save_vector( n, t, "t.dat");
		for p = 1; p <= n; p++ {
			P[0][p] = float32(1)
			P[1][p] = t[p]
			P[2][p] = float32(1.5*float64(t[p])*float64(t[p])-0.5)
			P[3][p] = float32(2.5*float64(t[p])*float64(t[p])*float64(t[p])-1.5*float64(t[p]))
			Pp[0][p] = float32(0)
			Pp[1][p] = float32(1)
			Pp[2][p] = float32(3*float64(t[p]))
			Pp[3][p] = float32(7.5*float64(t[p])*float64(t[p])-1.5)
			Ppp[0][p] = float32(0)
			Ppp[1][p] = float32(0)
			Ppp[2][p] = float32(3)
			Ppp[3][p] = float32(15*float64(t[p]))
			for k = 4; k <= order; k++ {
				P[k][p] = float32((2-1/float64(k))*float64(t[p])*float64(P[k-1][p])-(1-1/float64(k))*float64(P[k-2][p]))
				Pp[k][p] = float32((2-1/float64(k))*float64(P[k-1][p]+t[p]*Pp[k-1][p])-(1-1/float64(k))*float64(Pp[k-2][p]))
				Ppp[k][p] = float32((2-1/float64(k))*float64(2*Pp[k-1][p]+t[p]*Ppp[k-1][p])-(1-1/float64(k))*float64(Ppp[k-2][p]))
			}
		}
	}
}
// color - transpiled function from  GOPATH/History_frame3DD/src/HPGutil.c:35
func color(colorCode int32) {
	//  HPGutil.c  ---  library of general-purpose utility functions
	//
	// Copyright (C) 2012 Henri P. Gavin
	//
	//    HPGutil is free software: you can redistribute it and/or modify
	//    it under the terms of the GNU General Public License as published by
	//    the Free Software Foundation, either version 3 of the License, or
	//    (at your option) any later version.
	//
	//    HPGutil is distributed in the hope that it will be useful,
	//    but WITHOUT ANY WARRANTY; without even the implied warranty of
	//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	//    GNU General Public License for more details.
	//
	//    You should have received a copy of the GNU General Public License
	//    along with HPGutil.  If not, see <http://www.gnu.org/licenses/>.
	//
	//
	// * COLOR - change color on the screen ...
	// * Screen   Color  Scheme  : 0 = white on black, 1 = bright
	// * first digit= 3  for text color   first digit= 4  for  background color
	// * second digit codes:
	// * 0=black, 1=red, 2=green, 3=gold, 4=blue, 5=magenta, 6=cyan, 7=white
	// * http://en.wikipedia.org/wiki/ANSI_escape_code
	//
	//  change the screen color
	noarch.Fprintf(noarch.Stderr, []byte("\x1b[%02dm\x00"), colorCode)
	_ = noarch.Fflush(noarch.Stderr)
}
// textColor - transpiled function from  GOPATH/History_frame3DD/src/HPGutil.c:53
func textColor(tColor byte, bColor byte, nbf byte, uline byte) {
	//
	// * TEXTCOLOR - change color of text and background
	// * tColor : text color : one of 'k' 'r' 'g' 'y' 'b' 'm' 'c' 'w'
	// * bColor : back color : one of 'k' 'r' 'g' 'y' 'b' 'm' 'c' 'w'
	// * nbf    : 'n' = normal, 'b' = bright/bold, 'f' = faint
	// * uline  : 'u' = underline
	// * http://en.wikipedia.org/wiki/ANSI_escape_code
	//
	// Control Sequence Introducer & reset
	noarch.Fprintf(noarch.Stderr, []byte("\x1b[%02d\x00"), 0)
	if int32(bColor) == int32('k') {
		// background colors
		// black
		noarch.Fprintf(noarch.Stderr, []byte(";%02d\x00"), 40)
	}
	if int32(bColor) == int32('r') {
		// red
		noarch.Fprintf(noarch.Stderr, []byte(";%02d\x00"), 41)
	}
	if int32(bColor) == int32('g') {
		// green
		noarch.Fprintf(noarch.Stderr, []byte(";%02d\x00"), 42)
	}
	if int32(bColor) == int32('y') {
		// yellow
		noarch.Fprintf(noarch.Stderr, []byte(";%02d\x00"), 43)
	}
	if int32(bColor) == int32('b') {
		// blue
		noarch.Fprintf(noarch.Stderr, []byte(";%02d\x00"), 44)
	}
	if int32(bColor) == int32('m') {
		// magenta
		noarch.Fprintf(noarch.Stderr, []byte(";%02d\x00"), 45)
	}
	if int32(bColor) == int32('c') {
		// cyan
		noarch.Fprintf(noarch.Stderr, []byte(";%02d\x00"), 46)
	}
	if int32(bColor) == int32('w') {
		// white
		noarch.Fprintf(noarch.Stderr, []byte(";%02d\x00"), 47)
	}
	if int32(tColor) == int32('k') {
		// text colors
		// black
		noarch.Fprintf(noarch.Stderr, []byte(";%02d\x00"), 30)
	}
	if int32(tColor) == int32('r') {
		// red
		noarch.Fprintf(noarch.Stderr, []byte(";%02d\x00"), 31)
	}
	if int32(tColor) == int32('g') {
		// green
		noarch.Fprintf(noarch.Stderr, []byte(";%02d\x00"), 32)
	}
	if int32(tColor) == int32('y') {
		// yellow
		noarch.Fprintf(noarch.Stderr, []byte(";%02d\x00"), 33)
	}
	if int32(tColor) == int32('b') {
		// blue
		noarch.Fprintf(noarch.Stderr, []byte(";%02d\x00"), 34)
	}
	if int32(tColor) == int32('m') {
		// magenta
		noarch.Fprintf(noarch.Stderr, []byte(";%02d\x00"), 35)
	}
	if int32(tColor) == int32('c') {
		// cyan
		noarch.Fprintf(noarch.Stderr, []byte(";%02d\x00"), 36)
	}
	if int32(tColor) == int32('w') {
		// white
		noarch.Fprintf(noarch.Stderr, []byte(";%02d\x00"), 37)
	}
	if int32(nbf) == int32('b') {
		// printf(" tColor = %c   bColor = %c   nbf = %c\n", tColor, bColor, nbf );
		// bright
		noarch.Fprintf(noarch.Stderr, []byte(";%02d\x00"), 1)
	}
	if int32(nbf) == int32('f') {
		// faint
		noarch.Fprintf(noarch.Stderr, []byte(";%02d\x00"), 2)
	}
	if int32(uline) == int32('u') {
		// underline
		noarch.Fprintf(noarch.Stderr, []byte(";%02d\x00"), 4)
	}
	// Select Graphic Rendition (SGR)
	noarch.Fprintf(noarch.Stderr, []byte("m\x00"))
	_ = noarch.Fflush(noarch.Stderr)
}
// errorMsg - transpiled function from  GOPATH/History_frame3DD/src/HPGutil.c:94
func errorMsg(errString []byte) {
	//
	// * ERRORMSG -  write a diagnostic error message in color
	//
	noarch.Fprintf(noarch.Stderr, []byte("\n\n\x00"))
	noarch.Fflush(noarch.Stderr)
	color(1)
	color(41)
	color(37)
	noarch.Fprintf(noarch.Stderr, []byte("  %s  \x00"), errString)
	noarch.Fflush(noarch.Stderr)
	color(0)
	noarch.Fprintf(noarch.Stderr, []byte("\n\n\x00"))
}
// openFile - transpiled function from  GOPATH/History_frame3DD/src/HPGutil.c:114
func openFile(path []byte, fileName []byte, mode []byte, usage []byte) (c4goDefaultReturn *noarch.File) {
	//
	// * OPENFILE  -  open a file or print a diagnostic error message
	//
	var fp *noarch.File
	var pathToFile []byte = make([]byte, 512)
	var errMsg []byte = make([]byte, 512)
	if len(mode) == 0 {
		return nil
	}
	noarch.Sprintf(pathToFile, []byte("%s%s\x00"), path, fileName)
	if (func() *noarch.File {
		fp = noarch.Fopen(pathToFile, mode)
		return fp
	}()) == nil {
		// open file
		noarch.Sprintf(errMsg, []byte(" openFile: \x00"))
		switch int32(mode[0]) {
		case 'w':
			noarch.Sprintf(errMsg, []byte("%s%s\n  usage: %s\x00"), []byte("cannot write to file: \x00"), pathToFile, usage)
		case 'r':
			noarch.Sprintf(errMsg, []byte("%s%s\n  usage: %s\x00"), []byte("cannot read from file: \x00"), pathToFile, usage)
		case 'a':
			noarch.Sprintf(errMsg, []byte("%s%s\n  usage: %s\x00"), []byte("cannot append to file: \x00"), pathToFile, usage)
		default:
			noarch.Sprintf(errMsg, []byte("%s%s\n  usage: %s\x00"), []byte("cannot open file: \x00"), pathToFile, usage)
		}
		errorMsg(errMsg)
		unix.Exit(1)
	} else {
		return fp
	}
	return
}
// scanLine - transpiled function from  GOPATH/History_frame3DD/src/HPGutil.c:155
func scanLine(fp *noarch.File, lim int32, s []byte, a byte) int32 {
	//
	// * SCANLINE -  scan through a line until a 'a' is reached, like getline() 3feb94
	//
	var c int32
	var i int32 = -1
	for func() int32 {
		lim --
		return lim
	}() > 0 && (func() int32 {
		c = noarch.Fgetc(fp)
		return c
	}()) != -1 && c != int32(a) {
		s[func() int32 {
			i ++
			return i
		}()] = byte(c)
	}
	s[func() int32 {
		i ++
		return i
	}()] = '\x00'
	return i
}
// scanLabel - transpiled function from  GOPATH/History_frame3DD/src/HPGutil.c:168
func scanLabel(fp *noarch.File, lim int32, s []byte, a byte) int32 {
	//
	// * SCANLABEL -  scan through a line until a '"' is reached, like getline()
	//
	var c int32
	var i int32 = -1
	for func() int32 {
		lim --
		return lim
	}() > 0 && (func() int32 {
		c = noarch.Fgetc(fp)
		return c
	}()) != -1 && c != int32(a) {
	}
	for func() int32 {
		lim --
		return lim
	}() > 0 && (func() int32 {
		c = noarch.Fgetc(fp)
		return c
	}()) != -1 && c != int32(a) {
		// scan to first delimitter char
		// read the label between delimitters
		s[func() int32 {
			i ++
			return i
		}()] = byte(c)
	}
	s[func() int32 {
		i ++
		return i
	}()] = '\x00'
	return i
}
// scanFile - transpiled function from  GOPATH/History_frame3DD/src/HPGutil.c:185
func scanFile(fp *noarch.File, head_lines int32, start_chnl int32, stop_chnl int32) int32 {
	//
	// * SCANFILE -  count the number of lines of multi-column data in a data file,
	// * skipping over "head_lines" lines of header information
	//
	var points int32
	var i int32
	var chn int32
	var ok int32 = 1
	var data_value float32
	var ch byte
	{
		// scan through the header
		for i = 1; i <= head_lines; i++ {
			for int32((func() byte {
				ch = byte(noarch.Fgetc(fp))
				return ch
			}())) != int32('\n') {
			}
		}
	}
	for {
		{
			// count the number of lines of data
			for chn = start_chnl; chn <= stop_chnl; chn++ {
				ok = noarch.Fscanf(fp, []byte("%f\x00"), c4goUnsafeConvert_float32(&data_value))
				if ok == 1 {
					points ++
				}
			}
		}
		if ok > 0 {
			for int32((func() byte {
				ch = byte(noarch.Fgetc(fp))
				return ch
			}())) != int32('\n') {
			}
		}
		if !(ok == 1) {
			break
		}
	}
	points = points/(stop_chnl-start_chnl+1)
	// printf ("%% %d data points\n", points);
	noarch.Rewind(fp)
	return points
}
// getLine - transpiled function from  GOPATH/History_frame3DD/src/HPGutil.c:217
func getLine(fp *noarch.File, lim int32, s []byte) int32 {
	//
	// * GETLINE -  get line form a stream into a character string, return length
	// * from K&R        3feb94
	//
	var c int32
	var i int32
	for func() int32 {
		lim --
		return lim
	}() > 0 && (func() int32 {
		c = noarch.Fgetc(fp)
		return c
	}()) != -1 && c != int32('\n') {
		s[func() int32 {
			defer func() {
				i ++
			}()
			return i
		}()] = byte(c)
	}
	// if (c == '\n')  s[i++] = c;
	s[func() int32 {
		defer func() {
			i ++
		}()
		return i
	}()] = '\x00'
	return i
}
// getTime - transpiled function from  GOPATH/History_frame3DD/src/HPGutil.c:235
func getTime(s []byte, y int32, m int32, d int32, hr int32, mn int32, sc int32, os_ int32) noarch.TimeT {
	//
	// * getTime  parse a numeric time string similar to YYYYMMDDhhmmss
	// * The input variables y, m, d, hr, mn, sc are the indices of the string s[]
	// * which start the YYYY, MM, DD, hh, mm, ss sections of the time string.
	// * The corresponding time is returned in "time_t" format.
	//
	var temp []byte = make([]byte, 16)
	var t_tm noarch.Tm
	var t_time noarch.TimeT
	t_tm.TmYear = noarch.Atoi(noarch.Strncpy(temp, s[0+y:], int32(4)))-1900
	temp[2] = '\x00'
	t_tm.TmMon = noarch.Atoi(noarch.Strncpy(temp, s[0+m:], int32(2)))-1
	t_tm.TmMday = noarch.Atoi(noarch.Strncpy(temp, s[0+d:], int32(2)))
	t_tm.TmHour = noarch.Atoi(noarch.Strncpy(temp, s[0+hr:], int32(2)))
	t_tm.TmMin = noarch.Atoi(noarch.Strncpy(temp, s[0+mn:], int32(2)))
	t_tm.TmSec = noarch.Atoi(noarch.Strncpy(temp, s[0+sc:], int32(2)))+os_
	//  all times are Universal Time never daylight savings time
	t_tm.TmIsdst = -1
	// normalize t_tm
	t_time = noarch.Mktime((*[1000000]noarch.Tm)(unsafe.Pointer(&t_tm))[:])
	// printf("%d ... %s", (int) t_time, ctime(&t_time) );
	return t_time
}
// showProgress - transpiled function from  GOPATH/History_frame3DD/src/HPGutil.c:265
func showProgress(i int32, n int32, count int32) {
	//
	// * SHOW_PROGRESS  -   show the progress of long computations
	//
	var k int32
	var j int32
	var line_length int32 = 55
	var percent_done float32
	percent_done = float32(i)/float32(n)
	j = int32(math.Ceil(float64(percent_done*float32(line_length))))
	for k = 1; k <= line_length+13; k++ {
		noarch.Fprintf(noarch.Stderr, []byte("\b\x00"))
	}
	for k = 1; k < j; k++ {
		noarch.Fprintf(noarch.Stderr, []byte(">\x00"))
	}
	for k = j; k < line_length; k++ {
		noarch.Fprintf(noarch.Stderr, []byte(" \x00"))
	}
	noarch.Fprintf(noarch.Stderr, []byte(" %5.1f%%\x00"), float64(percent_done)*100)
	noarch.Fprintf(noarch.Stderr, []byte(" %5d\x00"), count)
	noarch.Fflush(noarch.Stderr)
}
// sferr - transpiled function from  GOPATH/History_frame3DD/src/HPGutil.c:288
func sferr(s []byte) {
	//
	// * SFERR  -  Display error message upon an erronous *scanf operation
	//
	var errMsg []byte = make([]byte, 512)
	noarch.Sprintf(errMsg, []byte(">> Input Data file error while reading %s\n\x00"), s)
	errorMsg(errMsg)
}
// NRerror - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:24
func NRerror(error_text []byte) {
	// @file
	// Memory allocation functions from Numerical Recipes in C, by Press,
	// Cambridge University Press, 1988
	// http://www.nr.com/public-domain.html
	//
	// Numerical Recipes standard error handler
	noarch.Fprintf(noarch.Stderr, []byte("Numerical Recipes run-time error...\n\x00"))
	noarch.Fprintf(noarch.Stderr, []byte("%s\n\x00"), error_text)
	noarch.Fprintf(noarch.Stderr, []byte("...now exiting to system...\n\x00"))
	unix.Exit(1000)
}
// vector - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:33
func vector(nl int32, nh int32) []float32 {
	// allocate a float vector with subscript range v[nl..nh]
	var v []float32
	v = make([]float32, uint32(uint32(nh-nl+1+1)*uint32(1)))
	if v == nil {
		NRerror([]byte("allocation failure in vector()\x00"))
	}
	return c4goPointerArithFloat32Slice(c4goPointerArithFloat32Slice(v, int(-nl)), int(1))
}
// ivector - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:43
func ivector(nl int32, nh int32) []int32 {
	// allocate an int vector with subscript range v[nl..nh]
	var v []int32
	v = make([]int32, uint32(uint32(nh-nl+1+1)*uint32(1)))
	if v == nil {
		NRerror([]byte("allocation failure in ivector()\x00"))
	}
	return c4goPointerArithInt32Slice(c4goPointerArithInt32Slice(v, int(-nl)), int(1))
}
// u16vector - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:54
// Warning (*ast.FunctionDecl): {prefix: n:u16vector,t1:uint16_t *(long, long),t2:}.  GOPATH/History_frame3DD/src/NRutil.c:54 :ReturnType: uint16_t *. cannot resolve type 'uint16_t *' : cannot resolve star `*` for uint16_t * : cannot resolve type 'uint16_t' : I couldn't find an appropriate Go type for the C type 'uint16_t'.
func u16vector(nl int32, nh int32) (c4goDefaultReturn []uint16_t) {
	// Warning (*ast.ReturnStmt):  GOPATH/History_frame3DD/src/NRutil.c:61 :cannot transpileToStmt : cannot transpileReturnStmt. err = cannot transpileToExpr. err = cannot transpile BinaryOperator with type 'uint16_t *' : result type = {unknown52}. Error: operator is `+`. cannot atomic for left part. cannot transpileToExpr. err = cannot transpile BinaryOperator with type 'uint16_t *' : result type = {}. Error: operator is `-`. pointer operation is not valid : cannot transpile pointerArithmetic. err = cannot transpile pointerArithmetic. err = cannot resolve type 'uint16_t *' : cannot resolve star `*` for uint16_t * : cannot resolve type 'uint16_t' : I couldn't find an appropriate Go type for the C type 'uint16_t'.
	{
		// allocate an int vector with subscript range v[nl..nh]
		var// Warning (*ast.VarDecl):  GOPATH/History_frame3DD/src/NRutil.c:57 :unknown type used C type, because cannot resolve type 'uint16_t *' : cannot resolve star `*` for uint16_t * : cannot resolve type 'uint16_t' : I couldn't find an appropriate Go type for the C type 'uint16_t'.
		v uint16_t *
		// Warning (*ast.BinaryOperator):  GOPATH/History_frame3DD/src/NRutil.c:59 :cannot transpile BinaryOperator with type 'uint16_t *' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. cannot transpileToExpr. err = cannot transpileImplicitCastExpr. err = cannot transpileToExpr. err = error in transpileCallExpr : name of call function is malloc. function: calloc. err = cannot resolve type 'uint16_t' : I couldn't find an appropriate Go type for the C type 'uint16_t'.
		if v == nil {
			// Warning (*ast.BinaryOperator):  GOPATH/History_frame3DD/src/NRutil.c:59 :cannot transpileToStmt : cannot transpileToExpr. err = cannot transpile BinaryOperator with type 'uint16_t *' : result type = {unknown53}. Error: operator is `=`. cannot atomic for right part. cannot transpileToExpr. err = cannot transpileImplicitCastExpr. err = cannot transpileToExpr. err = error in transpileCallExpr : name of call function is malloc. function: calloc. err = cannot resolve type 'uint16_t' : I couldn't find an appropriate Go type for the C type 'uint16_t'.
			NRerror([]byte("allocation failure in u16vector()\x00"))
		}
		// Warning (*ast.BinaryOperator):  GOPATH/History_frame3DD/src/NRutil.c:61 :cannot transpile BinaryOperator with type 'uint16_t *' : result type = {}. Error: operator is `-`. pointer operation is not valid : cannot transpile pointerArithmetic. err = cannot transpile pointerArithmetic. err = cannot resolve type 'uint16_t *' : cannot resolve star `*` for uint16_t * : cannot resolve type 'uint16_t' : I couldn't find an appropriate Go type for the C type 'uint16_t'.
		// Warning (*ast.BinaryOperator):  GOPATH/History_frame3DD/src/NRutil.c:61 :cannot transpile BinaryOperator with type 'uint16_t *' : result type = {unknown52}. Error: operator is `+`. cannot atomic for left part. cannot transpileToExpr. err = cannot transpile BinaryOperator with type 'uint16_t *' : result type = {}. Error: operator is `-`. pointer operation is not valid : cannot transpile pointerArithmetic. err = cannot transpile pointerArithmetic. err = cannot resolve type 'uint16_t *' : cannot resolve star `*` for uint16_t * : cannot resolve type 'uint16_t' : I couldn't find an appropriate Go type for the C type 'uint16_t'.
	}
	return
}
// cvector - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:65
func cvector(nl int32, nh int32) []uint8 {
	// allocate an unsigned char vector with subscript range v[nl..nh]
	var v []uint8
	v = make([]uint8, uint32(uint32(nh-nl+1+1)*uint32(1)))
	if v == nil {
		NRerror([]byte("allocation failure in cvector()\x00"))
	}
	return c4goPointerArithUint8Slice(c4goPointerArithUint8Slice(v, int(-nl)), int(1))
}
// lvector - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:75
func lvector(nl int32, nh int32) []uint32 {
	// allocate an unsigned long vector with subscript range v[nl..nh]
	var v []uint32
	v = (*[1000000]uint32)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := make([]int32, uint32(uint32(nh-nl+1+1)*uint32(1)))
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[:]
	if v == nil {
		NRerror([]byte("allocation failure in lvector()\x00"))
	}
	return c4goPointerArithUint32Slice(c4goPointerArithUint32Slice(v, int(-nl)), int(1))
}
// dvector - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:85
func dvector(nl int32, nh int32) []float64 {
	// allocate a double vector with subscript range v[nl..nh]
	var v []float64
	v = make([]float64, uint32(uint32(nh-nl+1+1)*uint32(1)))
	if v == nil {
		NRerror([]byte("allocation failure in dvector()\x00"))
	}
	return c4goPointerArithFloat64Slice(c4goPointerArithFloat64Slice(v, int(-nl)), int(1))
}
// matrix - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:95
func matrix(nrl int32, nrh int32, ncl int32, nch int32) [][]float32 {
	// allocate a float matrix with subscript range m[nrl..nrh][ncl..nch]
	var i int32
	var nrow int32 = nrh - nrl + 1
	var ncol int32 = nch - ncl + 1
	var m [][]float32
	// allocate pointers to rows
	m = make([][]float32, uint32(uint32(nrow+1)*uint32(1)))
	if m == nil {
		NRerror([]byte("allocation failure 1 in matrix()\x00"))
	}
	m = m[0+1:]
	m = c4goPointerArithFloat32SliceSlice(m, int(-nrl))
	// allocate rows and set pointers to them
	m[nrl] = make([]float32, uint32(uint32(nrow*ncol+1)*uint32(1)))
	if m[nrl] == nil {
		NRerror([]byte("allocation failure 2 in matrix()\x00"))
	}
	m[nrl] = (m[nrl])[0+1:]
	m[nrl] = c4goPointerArithFloat32Slice(m[nrl], int(-ncl))
	for i = nrl+1; i <= nrh; i++ {
		m[i] = c4goPointerArithFloat32Slice(m[i-1], int(ncol))
	}
	// return pointer to array of pointers to rows
	return m
}
// dmatrix - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:119
func dmatrix(nrl int32, nrh int32, ncl int32, nch int32) [][]float64 {
	// allocate a double matrix with subscript range m[nrl..nrh][ncl..nch]
	var i int32
	var nrow int32 = nrh - nrl + 1
	var ncol int32 = nch - ncl + 1
	var m [][]float64
	// allocate pointers to rows
	m = make([][]float64, uint32(uint32(nrow+1)*uint32(1)))
	if m == nil {
		NRerror([]byte("allocation failure 1 in matrix()\x00"))
	}
	m = m[0+1:]
	m = c4goPointerArithFloat64SliceSlice(m, int(-nrl))
	// allocate rows and set pointers to them
	m[nrl] = make([]float64, uint32(uint32(nrow*ncol+1)*uint32(1)))
	if m[nrl] == nil {
		NRerror([]byte("allocation failure 2 in matrix()\x00"))
	}
	m[nrl] = (m[nrl])[0+1:]
	m[nrl] = c4goPointerArithFloat64Slice(m[nrl], int(-ncl))
	for i = nrl+1; i <= nrh; i++ {
		m[i] = c4goPointerArithFloat64Slice(m[i-1], int(ncol))
	}
	// return pointer to array of pointers to rows
	return m
}
// imatrix - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:143
func imatrix(nrl int32, nrh int32, ncl int32, nch int32) [][]int32 {
	// allocate a int matrix with subscript range m[nrl..nrh][ncl..nch]
	var i int32
	var nrow int32 = nrh - nrl + 1
	var ncol int32 = nch - ncl + 1
	var m [][]int32
	// allocate pointers to rows
	m = make([][]int32, uint32(uint32(nrow+1)*uint32(1)))
	if m == nil {
		NRerror([]byte("allocation failure 1 in matrix()\x00"))
	}
	m = m[0+1:]
	m = c4goPointerArithInt32SliceSlice(m, int(-nrl))
	// allocate rows and set pointers to them
	m[nrl] = make([]int32, uint32(uint32(nrow*ncol+1)*uint32(1)))
	if m[nrl] == nil {
		NRerror([]byte("allocation failure 2 in matrix()\x00"))
	}
	m[nrl] = (m[nrl])[0+1:]
	m[nrl] = c4goPointerArithInt32Slice(m[nrl], int(-ncl))
	for i = nrl+1; i <= nrh; i++ {
		m[i] = c4goPointerArithInt32Slice(m[i-1], int(ncol))
	}
	// return pointer to array of pointers to rows
	return m
}
// subMatrix - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:168
func subMatrix(a [][]float32, oldrl int32, oldrh int32, oldcl int32, oldch int32, newrl int32, newcl int32) [][]float32 {
	// point a subMatrix [newrl..][newcl..] to a[oldrl..oldrh][oldcl..oldch]
	var i int32
	var j int32
	var nrow int32 = oldrh - oldrl + 1
	var ncol int32 = oldcl - newcl
	var m [][]float32
	// allocate array of pointers to rows
	m = make([][]float32, uint32(uint32(nrow+1)*uint32(1)))
	if m == nil {
		NRerror([]byte("allocation failure in subMatrix()\x00"))
	}
	m = m[0+1:]
	m = c4goPointerArithFloat32SliceSlice(m, int(-newrl))
	{
		// set pointers to rows
		i = oldrl
		j = newrl
		for j = newrl; i <= oldrh; {
			m[j] = (a[i])[0+ncol:]
			i ++
			j ++
		}
	}
	// return pointer to array of pointers to rows
	return m
}
// convert_matrix - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:188
func convert_matrix(a []float32, nrl int32, nrh int32, ncl int32, nch int32) [][]float32 {
	// allocate a float matrix m[nrl..nrh][ncl..nch] that points to the matrix
	//declared in the standard C manner as a[nrow][ncol], where nrow=nrh-nrl+1
	//and ncol=nch-ncl+1. The routine should be called with the address
	//&a[0][0] as the first argument.
	var i int32
	var j int32
	var nrow int32 = nrh - nrl + 1
	var ncol int32 = nch - ncl + 1
	var m [][]float32
	// allocate pointers to rows
	m = make([][]float32, uint32(uint32(nrow+1)*uint32(1)))
	if m == nil {
		NRerror([]byte("allocation failure in convert_matrix()\x00"))
	}
	m = m[0+1:]
	m = c4goPointerArithFloat32SliceSlice(m, int(-nrl))
	// set pointers to rows
	m[nrl] = c4goPointerArithFloat32Slice(a, int(-ncl))
	{
		i = 1
		j = nrl+1
		for j = nrl+1; i < nrow; {
			m[j] = c4goPointerArithFloat32Slice(m[j-1], int(ncol))
			i ++
			j ++
		}
	}
	// return pointer to array of pointers to rows
	return m
}
// f3tensor - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:210
func f3tensor(nrl int32, nrh int32, ncl int32, nch int32, ndl int32, ndh int32) [][][]float32 {
	// allocate a float 3tensor with range t[nrl..nrh][ncl..nch][ndl..ndh]
	var i int32
	var j int32
	var nrow int32 = nrh - nrl + 1
	var ncol int32 = nch - ncl + 1
	var ndep int32 = ndh - ndl + 1
	var t [][][]float32
	// allocate pointers to pointers to rows
	t = make([][][]float32, uint32(uint32(nrow+1)*uint32(1)))
	if t == nil {
		NRerror([]byte("allocation failure 1 in f3tensor()\x00"))
	}
	t = t[0+1:]
	t = c4goPointerArithFloat32SliceSliceSlice(t, int(-nrl))
	// allocate pointers to rows and set pointers to them
	t[nrl] = make([][]float32, uint32(uint32(nrow*ncol+1)*uint32(1)))
	if t[nrl] == nil {
		NRerror([]byte("allocation failure 2 in f3tensor()\x00"))
	}
	t[nrl] = (t[nrl])[0+1:]
	t[nrl] = c4goPointerArithFloat32SliceSlice(t[nrl], int(-ncl))
	// allocate rows and set pointers to them
	t[nrl][ncl] = make([]float32, uint32(uint32(nrow*ncol*ndep+1)*uint32(1)))
	if t[nrl][ncl] == nil {
		NRerror([]byte("allocation failure 3 in f3tensor()\x00"))
	}
	t[nrl][ncl] = (t[nrl][ncl])[0+1:]
	t[nrl][ncl] = c4goPointerArithFloat32Slice(t[nrl][ncl], int(-ndl))
	for j = ncl+1; j <= nch; j++ {
		t[nrl][j] = c4goPointerArithFloat32Slice(t[nrl][j-1], int(ndep))
	}
	for i = nrl+1; i <= nrh; i++ {
		t[i] = c4goPointerArithFloat32SliceSlice(t[i-1], int(ncol))
		t[i][ncl] = c4goPointerArithFloat32Slice(t[i-1][ncl], int(ncol*ndep))
		for j = ncl+1; j <= nch; j++ {
			t[i][j] = c4goPointerArithFloat32Slice(t[i][j-1], int(ndep))
		}
	}
	// return pointer to array of pointers to rows
	return t
}
// free_vector - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:245
func free_vector(v []float32, nl int32, nh int32) {
	_ = (*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := c4goPointerArithFloat32Slice(v[0+nl:], int(-1))
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[:]
	// free a float vector allocated with vector()
}
// free_ivector - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:251
func free_ivector(v []int32, nl int32, nh int32) {
	_ = (*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := c4goPointerArithInt32Slice(v[0+nl:], int(-1))
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[:]
	// free an int vector allocated with ivector()
}
// free_u16vector - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:257
// Warning (*ast.FunctionDecl): {prefix: n:free_u16vector,t1:void (uint16_t *, long, long),t2:}.  GOPATH/History_frame3DD/src/NRutil.c:257 :FieldList type: uint16_t *. cannot resolve type 'uint16_t *' : cannot resolve star `*` for uint16_t * : cannot resolve type 'uint16_t' : I couldn't find an appropriate Go type for the C type 'uint16_t'.
func free_u16vector(v C4GO_UNDEFINE_TYPE, nl int32, nh int32) {
	// Warning (*ast.CallExpr):  GOPATH/History_frame3DD/src/NRutil.c:260 :cannot transpileToStmt : cannot transpileToExpr. err = error in transpileCallExpr : name of call function is _. argument position is 0. cannot transpileToExpr. err = cannot transpileImplicitCastExpr. err = cannot transpileToExpr. err = cannot transpileImplicitCastExpr. err = cannot transpileToExpr. err = cannot transpile ParenExpr. err = cannot transpileToExpr. err = cannot transpile BinaryOperator with type 'uint16_t *' : result type = {}. Error: operator is `-`. pointer operation is not valid : cannot transpile pointerArithmetic. err = cannot transpile pointerArithmetic. err = cannot resolve type 'uint16_t *' : cannot resolve star `*` for uint16_t * : cannot resolve type 'uint16_t' : I couldn't find an appropriate Go type for the C type 'uint16_t'.
	{
		// free an uint_16 vector allocated with ivector()
		// Warning (*ast.BinaryOperator):  GOPATH/History_frame3DD/src/NRutil.c:260 :cannot transpile BinaryOperator with type 'uint16_t *' : result type = {}. Error: operator is `-`. pointer operation is not valid : cannot transpile pointerArithmetic. err = cannot transpile pointerArithmetic. err = cannot resolve type 'uint16_t *' : cannot resolve star `*` for uint16_t * : cannot resolve type 'uint16_t' : I couldn't find an appropriate Go type for the C type 'uint16_t'.
		// Warning (*ast.ParenExpr):  GOPATH/History_frame3DD/src/NRutil.c:260 :cannot transpile ParenExpr. err = cannot transpileToExpr. err = cannot transpile BinaryOperator with type 'uint16_t *' : result type = {}. Error: operator is `-`. pointer operation is not valid : cannot transpile pointerArithmetic. err = cannot transpile pointerArithmetic. err = cannot resolve type 'uint16_t *' : cannot resolve star `*` for uint16_t * : cannot resolve type 'uint16_t' : I couldn't find an appropriate Go type for the C type 'uint16_t'.
		// Warning (*ast.ImplicitCastExpr):  GOPATH/History_frame3DD/src/NRutil.c:260 :argument position is 0. cannot transpileToExpr. err = cannot transpileImplicitCastExpr. err = cannot transpileToExpr. err = cannot transpileImplicitCastExpr. err = cannot transpileToExpr. err = cannot transpile ParenExpr. err = cannot transpileToExpr. err = cannot transpile BinaryOperator with type 'uint16_t *' : result type = {}. Error: operator is `-`. pointer operation is not valid : cannot transpile pointerArithmetic. err = cannot transpile pointerArithmetic. err = cannot resolve type 'uint16_t *' : cannot resolve star `*` for uint16_t * : cannot resolve type 'uint16_t' : I couldn't find an appropriate Go type for the C type 'uint16_t'.
	}
}
// free_cvector - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:264
func free_cvector(v []uint8, nl int32, nh int32) {
	_ = (*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := c4goPointerArithUint8Slice(v[0+nl:], int(-1))
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[:]
	// free an unsigned char vector allocated with cvector()
}
// free_lvector - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:270
func free_lvector(v []uint32, nl int32, nh int32) {
	_ = (*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := c4goPointerArithUint32Slice(v[0+nl:], int(-1))
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[:]
	// free an unsigned long vector allocated with lvector()
}
// free_dvector - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:276
func free_dvector(v []float64, nl int32, nh int32) {
	_ = (*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := c4goPointerArithFloat64Slice(v[0+nl:], int(-1))
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[:]
	// free a double vector allocated with dvector()
}
// free_matrix - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:282
func free_matrix(m [][]float32, nrl int32, nrh int32, ncl int32, nch int32) {
	_ = (*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := c4goPointerArithFloat32Slice((m[nrl])[0+ncl:], int(-1))
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[:]
	// free a float matrix allocated by matrix()
	_ = (*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := c4goPointerArithFloat32SliceSlice(m[0+nrl:], int(-1))
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[:]
}
// free_dmatrix - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:289
func free_dmatrix(m [][]float64, nrl int32, nrh int32, ncl int32, nch int32) {
	_ = (*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := c4goPointerArithFloat64Slice((m[nrl])[0+ncl:], int(-1))
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[:]
	// free a double matrix allocated by dmatrix()
	_ = (*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := c4goPointerArithFloat64SliceSlice(m[0+nrl:], int(-1))
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[:]
}
// free_imatrix - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:296
func free_imatrix(m [][]int32, nrl int32, nrh int32, ncl int32, nch int32) {
	_ = (*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := c4goPointerArithInt32Slice((m[nrl])[0+ncl:], int(-1))
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[:]
	// free an int matrix allocated by imatrix()
	_ = (*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := c4goPointerArithInt32SliceSlice(m[0+nrl:], int(-1))
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[:]
}
// free_subMatrix - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:303
func free_subMatrix(b [][]float32, nrl int32, nrh int32, ncl int32, nch int32) {
	_ = (*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := c4goPointerArithFloat32SliceSlice(b[0+nrl:], int(-1))
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[:]
	// free a subMatrix allocated by subMatrix()
}
// free_convert_matrix - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:309
func free_convert_matrix(b [][]float32, nrl int32, nrh int32, ncl int32, nch int32) {
	_ = (*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := c4goPointerArithFloat32SliceSlice(b[0+nrl:], int(-1))
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[:]
	// free a matrix allocated by convert_matrix()
}
// free_f3tensor - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:315
func free_f3tensor(t [][][]float32, nrl int32, nrh int32, ncl int32, nch int32, ndl int32, ndh int32) {
	_ = (*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := c4goPointerArithFloat32Slice((t[nrl][ncl])[0+ndl:], int(-1))
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[:]
	// free a float f3tensor allocated by f3tensor()
	_ = (*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := c4goPointerArithFloat32SliceSlice((t[nrl])[0+ncl:], int(-1))
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[:]
	_ = (*[1000000]byte)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := c4goPointerArithFloat32SliceSliceSlice(t[0+nrl:], int(-1))
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[:]
}
// Cvector - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:323
func Cvector(nl int32, nh int32) []fcomplex {
	// allocate storage for a complex vector
	var v []fcomplex
	v = make([]fcomplex, uint32(nh-nl+1)*uint32(1))
	if v == nil {
		NRerror([]byte("allocation failure in Cvector()\x00"))
	}
	var position int32 = int32(-nl)
	slice := v
	if position < 0 {
		position = -position
		var hdr reflect.SliceHeader
		sliceLen := len(slice)
		hdr.Data = uintptr(unsafe.Pointer(&slice[0])) - (uintptr(position))*unsafe.Sizeof(slice[0])
		runtime.KeepAlive(&slice[0])
		hdr.Len = sliceLen + int(position)
		hdr.Cap = hdr.Len
		slice = *((*[]fcomplex)(unsafe.Pointer(&hdr)))
		return slice
	}
	return slice[position:]
}
// Cmatrix - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:334
func Cmatrix(nrl int32, nrh int32, ncl int32, nch int32) [][]fcomplex {
	// allocate storage for a Complex matrix
	var i int32
	var m [][]fcomplex
	m = make([][]fcomplex, uint32(nrh-nrl+1)*uint32(1))
	if m == nil {
		NRerror([]byte("allocation failure 1 in Cmatrix()\x00"))
	}
	m = func() [][]fcomplex {
		var position int32 = int32(-nrl)
		slice := m
		if position < 0 {
			position = -position
			var hdr reflect.SliceHeader
			sliceLen := len(slice)
			hdr.Data = uintptr(unsafe.Pointer(&slice[0])) - (uintptr(position))*unsafe.Sizeof(slice[0])
			runtime.KeepAlive(&slice[0])
			hdr.Len = sliceLen + int(position)
			hdr.Cap = hdr.Len
			slice = *((*[][]fcomplex)(unsafe.Pointer(&hdr)))
			return slice
		}
		return slice[position:]
	}()
	for i = nrl; i <= nrh; i++ {
		m[i] = make([]fcomplex, uint32(nch-ncl+1)*uint32(1))
		if m[i] == nil {
			NRerror([]byte("allocation failure 2 in Cmatrix()\x00"))
		}
		m[i] = func() []fcomplex {
			var position int32 = int32(-ncl)
			slice := m[i]
			if position < 0 {
				position = -position
				var hdr reflect.SliceHeader
				sliceLen := len(slice)
				hdr.Data = uintptr(unsafe.Pointer(&slice[0])) - (uintptr(position))*unsafe.Sizeof(slice[0])
				runtime.KeepAlive(&slice[0])
				hdr.Len = sliceLen + int(position)
				hdr.Cap = hdr.Len
				slice = *((*[]fcomplex)(unsafe.Pointer(&hdr)))
				return slice
			}
			return slice[position:]
		}()
	}
	return m
}
// D3matrix - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:352
func D3matrix(nrl int32, nrh int32, ncl int32, nch int32, nzl int32, nzh int32) [][][]float32 {
	// storage for a 3-D matrix
	var i int32
	var j int32
	var m [][][]float32
	m = (*[1000000][][]float32)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := make([][]float32, uint32(nrh-nrl+1)*uint32(1))
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[:]
	if m == nil {
		NRerror([]byte("alloc failure 1 in 3Dmatrix()\x00"))
	}
	m = c4goPointerArithFloat32SliceSliceSlice(m, int(-nrl))
	for i = nrl; i <= nrh; i++ {
		m[i] = make([][]float32, uint32(nch-ncl+1)*uint32(1))
		if m[i] == nil {
			NRerror([]byte("alloc failure 2 in 3Dmatrix()\x00"))
		}
		m[i] = c4goPointerArithFloat32SliceSlice(m[i], int(-ncl))
		for j = ncl; j <= nch; j++ {
			m[i][j] = make([]float32, uint32(nzh-nzl+1)*uint32(1))
			if m[i][j] == nil {
				NRerror([]byte("alloc failure 3 in 3Dmatrix()\x00"))
			}
			m[i][j] = c4goPointerArithFloat32Slice(m[i][j], int(-nzl))
		}
	}
	return m
}
// D3dmatrix - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:375
func D3dmatrix(nrl int32, nrh int32, ncl int32, nch int32, nzl int32, nzh int32) [][][]float64 {
	// storage for a 3-D matrix
	var i int32
	var j int32
	var m [][][]float64
	m = (*[1000000][][]float64)(unsafe.Pointer(uintptr(func() int64 {
		c4go_temp_name := make([][]float64, uint32(nrh-nrl+1)*uint32(1))
		return int64(uintptr(unsafe.Pointer(*(**byte)(unsafe.Pointer(&c4go_temp_name)))))
	}())))[:]
	if m == nil {
		NRerror([]byte("alloc failure 1 in 3Ddmatrix()\x00"))
	}
	m = c4goPointerArithFloat64SliceSliceSlice(m, int(-nrl))
	for i = nrl; i <= nrh; i++ {
		m[i] = make([][]float64, uint32(nch-ncl+1)*uint32(1))
		if m[i] == nil {
			NRerror([]byte("alloc failure 2 in 3Dmatrix()\x00"))
		}
		m[i] = c4goPointerArithFloat64SliceSlice(m[i], int(-ncl))
		for j = ncl; j <= nch; j++ {
			m[i][j] = make([]float64, uint32(nzh-nzl+1)*uint32(1))
			if m[i][j] == nil {
				NRerror([]byte("alloc failure 3 in 3Ddmatrix()\x00"))
			}
			m[i][j] = c4goPointerArithFloat64Slice(m[i][j], int(-nzl))
		}
	}
	return m
}
// free_Cvector - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:400
func free_Cvector(v []fcomplex, nl int32, nh int32) {
	_ = (*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&v[0+nl]))) / int64(1))))[:]
}
// free_Cmatrix - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:405
func free_Cmatrix(m [][]fcomplex, nrl int32, nrh int32, ncl int32, nch int32) {
	var i int32
	for i = nrh; i >= nrl; i-- {
		_ = (*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&(m[i])[0+ncl]))) / int64(1))))[:]
	}
	_ = (*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&m[0+nrl]))) / int64(1))))[:]
}
// free_D3matrix - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:413
func free_D3matrix(m [][][]float32, nrl int32, nrh int32, ncl int32, nch int32, nzl int32, nzh int32) {
	var r int32
	var c int32
	for r = nrh; r >= nrl; r-- {
		for c = nch; c >= ncl; c-- {
			_ = (*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&(m[r][c])[0+nzl]))) / int64(1))))[:]
		}
		_ = (*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&(m[r])[0+ncl]))) / int64(1))))[:]
	}
	_ = (*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&m[0+nrl]))) / int64(1))))[:]
}
// free_D3dmatrix - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:426
func free_D3dmatrix(m [][][]float64, nrl int32, nrh int32, ncl int32, nch int32, nzl int32, nzh int32) {
	var r int32
	var c int32
	for r = nrh; r >= nrl; r-- {
		for c = nch; c >= ncl; c-- {
			_ = (*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&(m[r][c])[0+nzl]))) / int64(1))))[:]
		}
		_ = (*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&(m[r])[0+ncl]))) / int64(1))))[:]
	}
	_ = (*[1000000]byte)(unsafe.Pointer(uintptr(int64(uintptr(unsafe.Pointer(&m[0+nrl]))) / int64(1))))[:]
}
// show_vector - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:771
func show_vector(A []float32, n int32) {
	//---------------------------------------------------------------------------
	//SHOW_VECTOR  -  display a vector of dimension [1..n]
	//----------------------------------------------------------------------------
	var j int32
	for j = 1; j <= n; j++ {
		if A[j] != 0 {
			noarch.Fprintf(noarch.Stdout, []byte("%14.6e\x00"), float64(A[j]))
		} else {
			noarch.Fprintf(noarch.Stdout, []byte("   0       \x00"))
		}
	}
	noarch.Fprintf(noarch.Stdout, []byte(" ]';\n\n\x00"))
}
// show_dvector - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:786
func show_dvector(A []float64, n int32) {
	//---------------------------------------------------------------------------
	//SHOW_DVECTOR  -  display a vector of dimension [1..n]
	//----------------------------------------------------------------------------
	var j int32
	for j = 1; j <= n; j++ {
		if A[j] != 0 {
			noarch.Fprintf(noarch.Stdout, []byte("%14.6e\x00"), A[j])
		} else {
			noarch.Fprintf(noarch.Stdout, []byte("   0       \x00"))
		}
	}
	noarch.Fprintf(noarch.Stdout, []byte(" ]';\n\n\x00"))
}
// show_ivector - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:801
func show_ivector(A []int32, n int32) {
	//---------------------------------------------------------------------------
	//SHOW_IVECTOR  -  display a vector of integers of dimension [1..n]
	//----------------------------------------------------------------------------
	var j int32
	for j = 1; j <= n; j++ {
		if A[j] != 0 {
			noarch.Fprintf(noarch.Stdout, []byte("%11d\x00"), A[j])
		} else {
			noarch.Fprintf(noarch.Stdout, []byte("   0       \x00"))
		}
	}
	noarch.Fprintf(noarch.Stdout, []byte(" ]';\n\n\x00"))
}
// show_matrix - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:817
func show_matrix(A [][]float32, m int32, n int32) {
	//---------------------------------------------------------------------------
	//SHOW_MATRIX  -  display a matrix of dimension [1..m][1..n]
	//----------------------------------------------------------------------------
	var i int32
	var j int32
	for i = 1; i <= m; i++ {
		for j = 1; j <= n; j++ {
			if A[i][j] != 0 {
				noarch.Fprintf(noarch.Stdout, []byte("%14.6e\x00"), float64(A[i][j]))
			} else {
				noarch.Fprintf(noarch.Stdout, []byte("   0       \x00"))
			}
		}
		if i == m {
			noarch.Fprintf(noarch.Stdout, []byte(" ];\n\n\x00"))
		} else {
			noarch.Fprintf(noarch.Stdout, []byte(" \n\x00"))
		}
	}
}
// show_dmatrix - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:835
func show_dmatrix(A [][]float64, m int32, n int32) {
	//---------------------------------------------------------------------------
	//SHOW_DMATRIX  - display a matrix of dimension [1..m][1..n]
	//----------------------------------------------------------------------------
	var i int32
	var j int32
	for i = 1; i <= m; i++ {
		for j = 1; j <= n; j++ {
			if math.Abs(A[i][j]) > 1e-99 {
				noarch.Fprintf(noarch.Stdout, []byte("%11.3e\x00"), A[i][j])
			} else {
				noarch.Fprintf(noarch.Stdout, []byte("   0       \x00"))
			}
		}
		if i == m {
			noarch.Fprintf(noarch.Stdout, []byte(" ];\n\n\x00"))
		} else {
			noarch.Fprintf(noarch.Stdout, []byte(" \n\x00"))
		}
	}
}
// save_vector - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:854
func save_vector(filename []byte, V []float32, nl int32, nh int32, mode []byte) {
	//---------------------------------------------------------------------------
	//SAVE_VECTOR  -  save a vector of dimension [1..n] to the named file
	//----------------------------------------------------------------------------
	var fp_v *noarch.File
	var i int32// now - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:859
	var now noarch.TimeT
	if (func() *noarch.File {
		fp_v = noarch.Fopen(filename, mode)
		return fp_v
	}()) == nil {
		noarch.Printf([]byte(" error: cannot open file: '%s' \n\x00"), filename)
		unix.Exit(1011)
	}
	_ = noarch.Time((*[1000000]noarch.TimeT)(unsafe.Pointer(&now))[:])
	noarch.Fprintf(fp_v, []byte("%% filename: %s - %s\x00"), filename, noarch.Ctime((*[1000000]noarch.TimeT)(unsafe.Pointer(&now))[:]))
	noarch.Fprintf(fp_v, []byte("%% type: vector\n\x00"))
	noarch.Fprintf(fp_v, []byte("%% rows: %d\n\x00"), 1)
	noarch.Fprintf(fp_v, []byte("%% columns: %d\n\x00"), nh-nl+1)
	for i = nl; i <= nh; i++ {
		if V[i] != 0 {
			noarch.Fprintf(fp_v, []byte("%15.6e\x00"), float64(V[i]))
		} else {
			noarch.Fprintf(fp_v, []byte("    0         \x00"))
		}
		noarch.Fprintf(fp_v, []byte("\n\x00"))
	}
	noarch.Fclose(fp_v)
}
// save_dvector - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:882
func save_dvector(filename []byte, V []float64, nl int32, nh int32, mode []byte) {
	//---------------------------------------------------------------------------
	//SAVE_DVECTOR  -  save a vector of dimension [1..n] to the named file
	//----------------------------------------------------------------------------
	var fp_v *noarch.File
	var i int32// now - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:887
	var now noarch.TimeT
	if (func() *noarch.File {
		fp_v = noarch.Fopen(filename, mode)
		return fp_v
	}()) == nil {
		noarch.Printf([]byte(" error: cannot open file: '%s' \n\x00"), filename)
		unix.Exit(1011)
	}
	_ = noarch.Time((*[1000000]noarch.TimeT)(unsafe.Pointer(&now))[:])
	noarch.Fprintf(fp_v, []byte("%% filename: %s - %s\x00"), filename, noarch.Ctime((*[1000000]noarch.TimeT)(unsafe.Pointer(&now))[:]))
	noarch.Fprintf(fp_v, []byte("%% type: vector\n\x00"))
	noarch.Fprintf(fp_v, []byte("%% rows: %d\n\x00"), 1)
	noarch.Fprintf(fp_v, []byte("%% columns: %d\n\x00"), nh-nl+1)
	for i = nl; i <= nh; i++ {
		if V[i] != 0 {
			noarch.Fprintf(fp_v, []byte("%21.12e\x00"), V[i])
		} else {
			noarch.Fprintf(fp_v, []byte("    0                \x00"))
		}
		noarch.Fprintf(fp_v, []byte("\n\x00"))
	}
	noarch.Fclose(fp_v)
}
// save_ivector - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:910
func save_ivector(filename []byte, V []int32, nl int32, nh int32, mode []byte) {
	//---------------------------------------------------------------------------
	//SAVE_IVECTOR  -  save an integer vector of dimension [1..n] to the named file
	//----------------------------------------------------------------------------
	var fp_v *noarch.File
	var i int32// now - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:915
	var now noarch.TimeT
	if (func() *noarch.File {
		fp_v = noarch.Fopen(filename, mode)
		return fp_v
	}()) == nil {
		noarch.Printf([]byte(" error: cannot open file: '%s' \n\x00"), filename)
		unix.Exit(1012)
	}
	_ = noarch.Time((*[1000000]noarch.TimeT)(unsafe.Pointer(&now))[:])
	noarch.Fprintf(fp_v, []byte("%% filename: %s - %s\x00"), filename, noarch.Ctime((*[1000000]noarch.TimeT)(unsafe.Pointer(&now))[:]))
	noarch.Fprintf(fp_v, []byte("%% type: vector\n\x00"))
	noarch.Fprintf(fp_v, []byte("%% rows: %d\n\x00"), 1)
	noarch.Fprintf(fp_v, []byte("%% columns: %d\n\x00"), nh-nl+1)
	for i = nl; i <= nh; i++ {
		if V[i] != 0 {
			noarch.Fprintf(fp_v, []byte("%15d\x00"), V[i])
		} else {
			noarch.Fprintf(fp_v, []byte("   0         \x00"))
		}
		noarch.Fprintf(fp_v, []byte("\n\x00"))
	}
	noarch.Fclose(fp_v)
}
// save_matrix - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:938
func save_matrix(filename []byte, A [][]float32, ml int32, mh int32, nl int32, nh int32, transpose int32, mode []byte) {
	//---------------------------------------------------------------------------
	//SAVE_MATRIX  -  save a matrix of dimension [ml..mh][nl..nh] to the named file
	//----------------------------------------------------------------------------
	var fp_m *noarch.File
	var i int32
	var j int32
	var rows int32
	var cols int32// now - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:943
	var now noarch.TimeT
	if transpose != 0 {
		rows = nh-nl+1
	} else {
		rows = mh-ml+1
	}
	if transpose != 0 {
		cols = mh-ml+1
	} else {
		cols = nh-nl+1
	}
	if (func() *noarch.File {
		fp_m = noarch.Fopen(filename, mode)
		return fp_m
	}()) == nil {
		noarch.Printf([]byte(" error: cannot open file: %s \n\x00"), filename)
		unix.Exit(1013)
	}
	_ = noarch.Time((*[1000000]noarch.TimeT)(unsafe.Pointer(&now))[:])
	noarch.Fprintf(fp_m, []byte("%% filename: %s - %s\x00"), filename, noarch.Ctime((*[1000000]noarch.TimeT)(unsafe.Pointer(&now))[:]))
	noarch.Fprintf(fp_m, []byte("%% type: matrix \n\x00"))
	noarch.Fprintf(fp_m, []byte("%% rows: %d\n\x00"), rows)
	noarch.Fprintf(fp_m, []byte("%% columns: %d\n\x00"), cols)
	if transpose != 0 {
		for j = nl; j <= nh; j++ {
			for i = ml; i <= mh; i++ {
				if A[i][j] != 0 {
					noarch.Fprintf(fp_m, []byte("%15.6e\x00"), float64(A[i][j]))
				} else {
					noarch.Fprintf(fp_m, []byte("    0          \x00"))
				}
			}
			noarch.Fprintf(fp_m, []byte("\n\x00"))
		}
	} else {
		for i = ml; i <= mh; i++ {
			for j = nl; j <= nh; j++ {
				if A[i][j] != 0 {
					noarch.Fprintf(fp_m, []byte("%15.6e\x00"), float64(A[i][j]))
				} else {
					noarch.Fprintf(fp_m, []byte("    0          \x00"))
				}
			}
			noarch.Fprintf(fp_m, []byte("\n\x00"))
		}
	}
	noarch.Fclose(fp_m)
}
// save_dmatrix - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:981
func save_dmatrix(filename []byte, A [][]float64, ml int32, mh int32, nl int32, nh int32, transpose int32, mode []byte) {
	//---------------------------------------------------------------------------
	//SAVE_DMATRIX  - save a matrix of dimension [ml..mh][nl..nh] to the named file
	//----------------------------------------------------------------------------
	var fp_m *noarch.File
	var i int32
	var j int32
	var rows int32
	var cols int32// now - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:986
	var now noarch.TimeT
	if transpose != 0 {
		rows = nh-nl+1
	} else {
		rows = mh-ml+1
	}
	if transpose != 0 {
		cols = mh-ml+1
	} else {
		cols = nh-nl+1
	}
	if (func() *noarch.File {
		fp_m = noarch.Fopen(filename, mode)
		return fp_m
	}()) == nil {
		noarch.Printf([]byte(" error: cannot open file: %s \n\x00"), filename)
		unix.Exit(1014)
	}
	_ = noarch.Time((*[1000000]noarch.TimeT)(unsafe.Pointer(&now))[:])
	noarch.Fprintf(fp_m, []byte("%% filename: %s - %s\x00"), filename, noarch.Ctime((*[1000000]noarch.TimeT)(unsafe.Pointer(&now))[:]))
	noarch.Fprintf(fp_m, []byte("%% type: matrix \n\x00"))
	noarch.Fprintf(fp_m, []byte("%% rows: %d\n\x00"), mh-ml+1)
	noarch.Fprintf(fp_m, []byte("%% columns: %d\n\x00"), nh-nl+1)
	if transpose != 0 {
		for j = nl; j <= nh; j++ {
			for i = ml; i <= mh; i++ {
				if math.Abs(A[i][j]) > 1e-99 {
					noarch.Fprintf(fp_m, []byte("%21.12e\x00"), A[i][j])
				} else {
					noarch.Fprintf(fp_m, []byte("    0                \x00"))
				}
			}
			noarch.Fprintf(fp_m, []byte("\n\x00"))
		}
	} else {
		for i = ml; i <= mh; i++ {
			for j = nl; j <= nh; j++ {
				if math.Abs(A[i][j]) > 1e-99 {
					noarch.Fprintf(fp_m, []byte("%21.12e\x00"), A[i][j])
				} else {
					noarch.Fprintf(fp_m, []byte("    0                \x00"))
				}
			}
			noarch.Fprintf(fp_m, []byte("\n\x00"))
		}
	}
	noarch.Fclose(fp_m)
}
// save_ut_matrix - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:1026
func save_ut_matrix(filename []byte, A [][]float32, n int32, mode []byte) {
	//---------------------------------------------------------------------------
	//SAVE_UT_MATRIX  -            23apr01
	// save a symmetric matrix of dimension [1..n][1..n] to the named file
	// use only upper-triangular part
	//----------------------------------------------------------------------------
	var fp_m *noarch.File
	var i int32
	var j int32// now - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:1031
	var now noarch.TimeT
	if (func() *noarch.File {
		fp_m = noarch.Fopen(filename, mode)
		return fp_m
	}()) == nil {
		noarch.Printf([]byte(" error: cannot open file: %s \n\x00"), filename)
		unix.Exit(1015)
	}
	_ = noarch.Time((*[1000000]noarch.TimeT)(unsafe.Pointer(&now))[:])
	noarch.Fprintf(fp_m, []byte("%% filename: %s - %s\x00"), filename, noarch.Ctime((*[1000000]noarch.TimeT)(unsafe.Pointer(&now))[:]))
	noarch.Fprintf(fp_m, []byte("%% type: matrix \n\x00"))
	noarch.Fprintf(fp_m, []byte("%% rows: %d\n\x00"), n)
	noarch.Fprintf(fp_m, []byte("%% columns: %d\n\x00"), n)
	for i = 1; i <= n; i++ {
		for j = 1; j <= n; j++ {
			if i > j {
				if math.Abs(float64(A[j][i])) > 1e-99 {
					noarch.Fprintf(fp_m, []byte("%15.6e\x00"), float64(A[j][i]))
				} else {
					noarch.Fprintf(fp_m, []byte("    0          \x00"))
				}
			} else {
				if math.Abs(float64(A[i][j])) > 1e-99 {
					noarch.Fprintf(fp_m, []byte("%15.6e\x00"), float64(A[i][j]))
				} else {
					noarch.Fprintf(fp_m, []byte("    0          \x00"))
				}
			}
		}
		noarch.Fprintf(fp_m, []byte("\n\x00"))
	}
	noarch.Fclose(fp_m)
}
// save_ut_dmatrix - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:1063
func save_ut_dmatrix(filename []byte, A [][]float64, n int32, mode []byte) {
	//---------------------------------------------------------------------------
	//SAVE_UT_DMATRIX  -       23apr01
	//  save a symetric matrix of dimension [1..n][1..n] to the named file
	//  use only upper-triangular part
	//----------------------------------------------------------------------------
	var fp_m *noarch.File
	var i int32
	var j int32// now - transpiled function from  GOPATH/History_frame3DD/src/NRutil.c:1068
	var now noarch.TimeT
	if (func() *noarch.File {
		fp_m = noarch.Fopen(filename, mode)
		return fp_m
	}()) == nil {
		noarch.Printf([]byte(" error: cannot open file: %s \n\x00"), filename)
		unix.Exit(1016)
	}
	_ = noarch.Time((*[1000000]noarch.TimeT)(unsafe.Pointer(&now))[:])
	noarch.Fprintf(fp_m, []byte("%% filename: %s - %s\n\x00"), filename, noarch.Ctime((*[1000000]noarch.TimeT)(unsafe.Pointer(&now))[:]))
	noarch.Fprintf(fp_m, []byte("%% type: matrix \n\x00"))
	noarch.Fprintf(fp_m, []byte("%% rows: %d\n\x00"), n)
	noarch.Fprintf(fp_m, []byte("%% columns: %d\n\x00"), n)
	for i = 1; i <= n; i++ {
		for j = 1; j <= n; j++ {
			if i > j {
				if math.Abs(A[j][i]) > 1e-99 {
					noarch.Fprintf(fp_m, []byte("%21.12e\x00"), A[j][i])
				} else {
					noarch.Fprintf(fp_m, []byte("    0                \x00"))
				}
			} else {
				if math.Abs(A[i][j]) > 1e-99 {
					noarch.Fprintf(fp_m, []byte("%21.12e\x00"), A[i][j])
				} else {
					noarch.Fprintf(fp_m, []byte("    0                \x00"))
				}
			}
		}
		noarch.Fprintf(fp_m, []byte("\n\x00"))
	}
	noarch.Fclose(fp_m)
}
// c4goUnsafeConvert_float32 : created by c4go
func c4goUnsafeConvert_float32(c4go_name *float32) []float32 {
	return (*[1000000]float32)(unsafe.Pointer(c4go_name))[:]
}
// c4goUnsafeConvert_float64 : created by c4go
func c4goUnsafeConvert_float64(c4go_name *float64) []float64 {
	return (*[1000000]float64)(unsafe.Pointer(c4go_name))[:]
}
// c4goUnsafeConvert_int32 : created by c4go
func c4goUnsafeConvert_int32(c4go_name *int32) []int32 {
	return (*[1000000]int32)(unsafe.Pointer(c4go_name))[:]
}
//
//	Vector difference/subtraction.
//	@return the vector (A - B)
//
//
//	Calculate the angle between two vectors, in radians.
//
//
//	Calculate the angle between two vectors, in radians. Also return
//	the cross-product of the two vectors, useful with vec3_rotate.
//
//
//static float sqrarg;
//#define SQR(a) ((sqrarg=(a)) == 0.0 ? 0.0 : sqrarg*sqrarg)
//
//static double dsqrarg;
//#define DSQR(a) ((dsqrarg=(a)) == 0.0 ? 0.0 : dsqrarg*dsqrarg)
//
//static double dmaxarg1,dmaxarg2;
//#define DMAX(a,b) (dmaxarg1=(a),dmaxarg2=(b),(dmaxarg1) > (dmaxarg2) ?\
//        (dmaxarg1) : (dmaxarg2))
//
//static double dminarg1,dminarg2;
//#define DMIN(a,b) (dminarg1=(a),dminarg2=(b),(dminarg1) < (dminarg2) ?\
//        (dminarg1) : (dminarg2))
//
//static float maxarg1,maxarg2;
//#define FMAX(a,b) (maxarg1=(a),maxarg2=(b),(maxarg1) > (maxarg2) ?\
//        (maxarg1) : (maxarg2))
//
//static float minarg1,minarg2;
//#define FMIN(a,b) (minarg1=(a),minarg2=(b),(minarg1) < (minarg2) ?\
//        (minarg1) : (minarg2))
//
//static long lmaxarg1,lmaxarg2;
//#define LMAX(a,b) (lmaxarg1=(a),lmaxarg2=(b),(lmaxarg1) > (lmaxarg2) ?\
//        (lmaxarg1) : (lmaxarg2))
//
//static long lminarg1,lminarg2;
//#define LMIN(a,b) (lminarg1=(a),lminarg2=(b),(lminarg1) < (lminarg2) ?\
//        (lminarg1) : (lminarg2))
//
//static int imaxarg1,imaxarg2;
//#define IMAX(a,b) (imaxarg1=(a),imaxarg2=(b),(imaxarg1) > (imaxarg2) ?\
//        (imaxarg1) : (imaxarg2))
//
//static int iminarg1,iminarg2;
//#define IMIN(a,b) (iminarg1=(a),iminarg2=(b),(iminarg1) < (iminarg2) ?\
//        (iminarg1) : (iminarg2))
//
//#define SIGN(a,b) ((b) >= 0.0 ? fabs(a) : -fabs(a))
//
// itoa moved to frame3dd_io.c 
// removed strcat -- it's in <string.h> in the standard C library 
// removed strcpy -- it's in <string.h> in the standard C library 
// dots moved to frame3dd_io.c 

// __assert_fail from assert.h
// c function : bool __assert_fail(const char*, const char*, unsigned int, const char*)
// dep pkg    : fmt os github.com/Konstantin8105/c4go/noarch
// dep func   :
func __assert_fail(
	expression, filePath []byte,
	lineNumber uint32,
	functionName []byte,
) bool {
	fmt.Fprintf(
		os.Stderr,
		"a.out: %s:%d: %s: Assertion %s%s' failed.\n",
		noarch.CStringToString(filePath),
		lineNumber,
		noarch.CStringToString(functionName),
		string(byte(96)),
		noarch.CStringToString(expression),
	)
	os.Exit(134)

	return true
}



// tolower from ctype.h
// c function : int tolower(int)
// dep pkg    : unicode
// dep func   :
func tolower (_c int32) int32 {
	return int32(unicode.ToLower(rune(_c)))
}




// getopt - add c-binding for implemention function
func getopt(arg0 int32, arg1 [][]byte, arg2 []byte) int32 {
	return int32(C.getopt(C.int(arg0), unsafe.Pointer(&arg1), (*C.char)(unsafe.Pointer(&arg2[0]))))
}



// c4goPointerArithFloat64Slice - function of pointer arithmetic. generated by c4go 
func c4goPointerArithFloat64Slice(slice []float64, position int)[]float64 {
	if position < 0 {
		// invert sign
		position = -position

		// Example from: go101.org/article/unsafe.html
		// repair size of slice
		var hdr reflect.SliceHeader
		sliceLen := len(slice)
		hdr.Data = uintptr(unsafe.Pointer(&slice[0])) - (uintptr(position))*unsafe.Sizeof(slice[0])
		runtime.KeepAlive(&slice[0]) // needed!
		hdr.Len = sliceLen + int(position)
		hdr.Cap = hdr.Len
		slice = *((*[]float64)(unsafe.Pointer(&hdr)))
		return slice
	}
	// position >= 0:
	return slice[position:]
}



// c4goPointerArithFloat32SliceSliceSlice - function of pointer arithmetic. generated by c4go 
func c4goPointerArithFloat32SliceSliceSlice(slice [][][]float32, position int)[][][]float32 {
	if position < 0 {
		// invert sign
		position = -position

		// Example from: go101.org/article/unsafe.html
		// repair size of slice
		var hdr reflect.SliceHeader
		sliceLen := len(slice)
		hdr.Data = uintptr(unsafe.Pointer(&slice[0])) - (uintptr(position))*unsafe.Sizeof(slice[0])
		runtime.KeepAlive(&slice[0]) // needed!
		hdr.Len = sliceLen + int(position)
		hdr.Cap = hdr.Len
		slice = *((*[][][]float32)(unsafe.Pointer(&hdr)))
		return slice
	}
	// position >= 0:
	return slice[position:]
}



// c4goPointerArithInt32SliceSlice - function of pointer arithmetic. generated by c4go 
func c4goPointerArithInt32SliceSlice(slice [][]int32, position int)[][]int32 {
	if position < 0 {
		// invert sign
		position = -position

		// Example from: go101.org/article/unsafe.html
		// repair size of slice
		var hdr reflect.SliceHeader
		sliceLen := len(slice)
		hdr.Data = uintptr(unsafe.Pointer(&slice[0])) - (uintptr(position))*unsafe.Sizeof(slice[0])
		runtime.KeepAlive(&slice[0]) // needed!
		hdr.Len = sliceLen + int(position)
		hdr.Cap = hdr.Len
		slice = *((*[][]int32)(unsafe.Pointer(&hdr)))
		return slice
	}
	// position >= 0:
	return slice[position:]
}



// c4goPointerArithFloat64SliceSliceSlice - function of pointer arithmetic. generated by c4go 
func c4goPointerArithFloat64SliceSliceSlice(slice [][][]float64, position int)[][][]float64 {
	if position < 0 {
		// invert sign
		position = -position

		// Example from: go101.org/article/unsafe.html
		// repair size of slice
		var hdr reflect.SliceHeader
		sliceLen := len(slice)
		hdr.Data = uintptr(unsafe.Pointer(&slice[0])) - (uintptr(position))*unsafe.Sizeof(slice[0])
		runtime.KeepAlive(&slice[0]) // needed!
		hdr.Len = sliceLen + int(position)
		hdr.Cap = hdr.Len
		slice = *((*[][][]float64)(unsafe.Pointer(&hdr)))
		return slice
	}
	// position >= 0:
	return slice[position:]
}



// c4goPointerArithFloat32Slice - function of pointer arithmetic. generated by c4go 
func c4goPointerArithFloat32Slice(slice []float32, position int)[]float32 {
	if position < 0 {
		// invert sign
		position = -position

		// Example from: go101.org/article/unsafe.html
		// repair size of slice
		var hdr reflect.SliceHeader
		sliceLen := len(slice)
		hdr.Data = uintptr(unsafe.Pointer(&slice[0])) - (uintptr(position))*unsafe.Sizeof(slice[0])
		runtime.KeepAlive(&slice[0]) // needed!
		hdr.Len = sliceLen + int(position)
		hdr.Cap = hdr.Len
		slice = *((*[]float32)(unsafe.Pointer(&hdr)))
		return slice
	}
	// position >= 0:
	return slice[position:]
}



// c4goPointerArithInt32Slice - function of pointer arithmetic. generated by c4go 
func c4goPointerArithInt32Slice(slice []int32, position int)[]int32 {
	if position < 0 {
		// invert sign
		position = -position

		// Example from: go101.org/article/unsafe.html
		// repair size of slice
		var hdr reflect.SliceHeader
		sliceLen := len(slice)
		hdr.Data = uintptr(unsafe.Pointer(&slice[0])) - (uintptr(position))*unsafe.Sizeof(slice[0])
		runtime.KeepAlive(&slice[0]) // needed!
		hdr.Len = sliceLen + int(position)
		hdr.Cap = hdr.Len
		slice = *((*[]int32)(unsafe.Pointer(&hdr)))
		return slice
	}
	// position >= 0:
	return slice[position:]
}



// c4goPointerArithUint8Slice - function of pointer arithmetic. generated by c4go 
func c4goPointerArithUint8Slice(slice []uint8, position int)[]uint8 {
	if position < 0 {
		// invert sign
		position = -position

		// Example from: go101.org/article/unsafe.html
		// repair size of slice
		var hdr reflect.SliceHeader
		sliceLen := len(slice)
		hdr.Data = uintptr(unsafe.Pointer(&slice[0])) - (uintptr(position))*unsafe.Sizeof(slice[0])
		runtime.KeepAlive(&slice[0]) // needed!
		hdr.Len = sliceLen + int(position)
		hdr.Cap = hdr.Len
		slice = *((*[]uint8)(unsafe.Pointer(&hdr)))
		return slice
	}
	// position >= 0:
	return slice[position:]
}



// c4goPointerArithUint32Slice - function of pointer arithmetic. generated by c4go 
func c4goPointerArithUint32Slice(slice []uint32, position int)[]uint32 {
	if position < 0 {
		// invert sign
		position = -position

		// Example from: go101.org/article/unsafe.html
		// repair size of slice
		var hdr reflect.SliceHeader
		sliceLen := len(slice)
		hdr.Data = uintptr(unsafe.Pointer(&slice[0])) - (uintptr(position))*unsafe.Sizeof(slice[0])
		runtime.KeepAlive(&slice[0]) // needed!
		hdr.Len = sliceLen + int(position)
		hdr.Cap = hdr.Len
		slice = *((*[]uint32)(unsafe.Pointer(&hdr)))
		return slice
	}
	// position >= 0:
	return slice[position:]
}



// c4goPointerArithFloat32SliceSlice - function of pointer arithmetic. generated by c4go 
func c4goPointerArithFloat32SliceSlice(slice [][]float32, position int)[][]float32 {
	if position < 0 {
		// invert sign
		position = -position

		// Example from: go101.org/article/unsafe.html
		// repair size of slice
		var hdr reflect.SliceHeader
		sliceLen := len(slice)
		hdr.Data = uintptr(unsafe.Pointer(&slice[0])) - (uintptr(position))*unsafe.Sizeof(slice[0])
		runtime.KeepAlive(&slice[0]) // needed!
		hdr.Len = sliceLen + int(position)
		hdr.Cap = hdr.Len
		slice = *((*[][]float32)(unsafe.Pointer(&hdr)))
		return slice
	}
	// position >= 0:
	return slice[position:]
}



// c4goPointerArithFloat64SliceSlice - function of pointer arithmetic. generated by c4go 
func c4goPointerArithFloat64SliceSlice(slice [][]float64, position int)[][]float64 {
	if position < 0 {
		// invert sign
		position = -position

		// Example from: go101.org/article/unsafe.html
		// repair size of slice
		var hdr reflect.SliceHeader
		sliceLen := len(slice)
		hdr.Data = uintptr(unsafe.Pointer(&slice[0])) - (uintptr(position))*unsafe.Sizeof(slice[0])
		runtime.KeepAlive(&slice[0]) // needed!
		hdr.Len = sliceLen + int(position)
		hdr.Cap = hdr.Len
		slice = *((*[][]float64)(unsafe.Pointer(&hdr)))
		return slice
	}
	// position >= 0:
	return slice[position:]
}

